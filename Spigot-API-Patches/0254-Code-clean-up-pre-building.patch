From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Moderocky <admin@moderocky.com>
Date: Fri, 25 Sep 2020 12:28:38 +0100
Subject: [PATCH] Code clean-up pre-building.


diff --git a/src/main/java/mx/kenzie/wellspring/Wellspring.java b/src/main/java/mx/kenzie/wellspring/Wellspring.java
index db16f747ebf77ae7ccb1453c6c78adb080155d71..b5aaff4d9b1da7880ba3de64b5114c6547b66fb4 100644
--- a/src/main/java/mx/kenzie/wellspring/Wellspring.java
+++ b/src/main/java/mx/kenzie/wellspring/Wellspring.java
@@ -9,7 +9,7 @@ import org.jetbrains.annotations.NotNull;
 
 /**
  * A second interface to evade Bukkit's Bukkit/Server parity tests.
- *
+ * <p>
  * This generally should not be used by plugins, but is technically
  * an instance of CraftServer.
  *
@@ -17,20 +17,22 @@ import org.jetbrains.annotations.NotNull;
  */
 public interface Wellspring extends Server {
 
-    static @NotNull Wellspring getInstance() {
+    static @NotNull
+    Wellspring getInstance() {
         return (Wellspring) Bukkit.getServer();
     }
 
     @NotNull
     EnchantmentBuilder createEnchantment(@NotNull NamespacedKey key, @NotNull String name);
 
-    @NotNull Bridge getBridge();
+    @NotNull
+    Bridge getBridge();
 
     /**
      * This provides a bridging utility for accessing the craft server.
      * It is preferable to implementing the methods directly into {@link org.bukkit.Bukkit}
      * since that class is cluttered and unnecessarily static.
-     *
+     * <p>
      * This implementation also makes changeover much easier.
      */
     abstract class Bridge {
diff --git a/src/main/java/mx/kenzie/wellspring/clientside/entity/ClientsideEntity.java b/src/main/java/mx/kenzie/wellspring/clientside/entity/ClientsideEntity.java
index c6f99c7688c06d0553da45d9ecb6632ffd158e0b..a5e9b093251853f316490bb30438fb760435da86 100644
--- a/src/main/java/mx/kenzie/wellspring/clientside/entity/ClientsideEntity.java
+++ b/src/main/java/mx/kenzie/wellspring/clientside/entity/ClientsideEntity.java
@@ -37,13 +37,13 @@ public abstract class ClientsideEntity implements Entity {
     private final EntityType type;
     private transient Vector motion;
     private transient Location location;
-    private transient World world;
+    private final transient World world;
     private float pitch, yaw, head;
     private boolean nameVisible, glowing, invisible, silent;
 
     private BaseComponent[] name;
 
-    private transient Wellspring server = ((Wellspring) Bukkit.getServer());
+    private final transient Wellspring server = ((Wellspring) Bukkit.getServer());
 
     protected ClientsideEntity(int id, @NotNull UUID uuid, @NotNull EntityType type) {
         this.id = id;
@@ -65,17 +65,17 @@ public abstract class ClientsideEntity implements Entity {
         return loc.set(location.getX(), location.getY(), location.getZ());
     }
 
-    @Override
-    public void setVelocity(@NotNull Vector velocity) {
-        motion = velocity.clone();
-    }
-
     @NotNull
     @Override
     public Vector getVelocity() {
         return motion.clone();
     }
 
+    @Override
+    public void setVelocity(@NotNull Vector velocity) {
+        motion = velocity.clone();
+    }
+
     @Override
     public double getHeight() {
         return server.getBridge().getHeight(type);
@@ -89,7 +89,7 @@ public abstract class ClientsideEntity implements Entity {
     @NotNull
     @Override
     public BoundingBox getBoundingBox() {
-        double x = getWidth()/2, y = getHeight()/2, z = getWidth()/2;
+        double x = getWidth() / 2, y = getHeight() / 2, z = getWidth() / 2;
         return BoundingBox.of(getLocation().add(x, y, z), x, y, z);
     }
 
@@ -151,13 +151,13 @@ public abstract class ClientsideEntity implements Entity {
     }
 
     @Override
-    public int getMaxFireTicks() {
-        return -1;
+    public void setFireTicks(int ticks) {
+
     }
 
     @Override
-    public void setFireTicks(int ticks) {
-
+    public int getMaxFireTicks() {
+        return -1;
     }
 
     @Override
@@ -254,17 +254,17 @@ public abstract class ClientsideEntity implements Entity {
 
     }
 
-    @Override
-    public void setLastDamageCause(@Nullable EntityDamageEvent event) {
-
-    }
-
     @Nullable
     @Override
     public EntityDamageEvent getLastDamageCause() {
         return null;
     }
 
+    @Override
+    public void setLastDamageCause(@Nullable EntityDamageEvent event) {
+
+    }
+
     @NotNull
     @Override
     public UUID getUniqueId() {
@@ -309,19 +309,14 @@ public abstract class ClientsideEntity implements Entity {
         return null;
     }
 
-    @Override
-    public void setCustomNameVisible(boolean flag) {
-        nameVisible = flag;
-    }
-
     @Override
     public boolean isCustomNameVisible() {
         return nameVisible;
     }
 
     @Override
-    public void setGlowing(boolean flag) {
-        glowing = flag;
+    public void setCustomNameVisible(boolean flag) {
+        nameVisible = flag;
     }
 
     @Override
@@ -330,8 +325,8 @@ public abstract class ClientsideEntity implements Entity {
     }
 
     @Override
-    public void setInvulnerable(boolean flag) {
-
+    public void setGlowing(boolean flag) {
+        glowing = flag;
     }
 
     @Override
@@ -339,6 +334,11 @@ public abstract class ClientsideEntity implements Entity {
         return true;
     }
 
+    @Override
+    public void setInvulnerable(boolean flag) {
+
+    }
+
     @Override
     public boolean isSilent() {
         return silent;
diff --git a/src/main/java/mx/kenzie/wellspring/enchantment/EnchantmentBuilder.java b/src/main/java/mx/kenzie/wellspring/enchantment/EnchantmentBuilder.java
index d6e4f35a7c401f071c49534418d4aadd9a981d6f..403335799ece202c9b6f8937957ed2b00891b9cf 100644
--- a/src/main/java/mx/kenzie/wellspring/enchantment/EnchantmentBuilder.java
+++ b/src/main/java/mx/kenzie/wellspring/enchantment/EnchantmentBuilder.java
@@ -1,6 +1,5 @@
 package mx.kenzie.wellspring.enchantment;
 
-import com.sun.org.apache.xpath.internal.operations.Bool;
 import mx.kenzie.wellspring.Wellspring;
 import net.md_5.bungee.api.ChatColor;
 import net.md_5.bungee.api.chat.BaseComponent;
@@ -40,16 +39,6 @@ public abstract class EnchantmentBuilder {
     protected boolean treasure, curse, tradable, discoverable;
     protected int minLevel = 1, maxLevel = 1, minCost = 1, maxCost = 1;
 
-    /**
-     * Create a new enchantment builder.
-     * @param key The key to register this under
-     * @param name The enchantment's name (used in messages, etc.)
-     * @return The builder
-     */
-    public static @NotNull EnchantmentBuilder create(@NotNull NamespacedKey key, @NotNull String name) {
-        return Wellspring.getInstance().createEnchantment(key, name);
-    }
-
     protected EnchantmentBuilder(@NotNull NamespacedKey key, @NotNull String name) {
         this.key = key;
         this.name = name;
@@ -63,11 +52,24 @@ public abstract class EnchantmentBuilder {
         };
     }
 
+    /**
+     * Create a new enchantment builder.
+     *
+     * @param key  The key to register this under
+     * @param name The enchantment's name (used in messages, etc.)
+     * @return The builder
+     */
+    public static @NotNull
+    EnchantmentBuilder create(@NotNull NamespacedKey key, @NotNull String name) {
+        return Wellspring.getInstance().createEnchantment(key, name);
+    }
+
     /**
      * Governs the rarity of the enchantment, which
      * determines how common it is.
      */
-    public @NotNull EnchantmentBuilder setRarity(@NotNull Rarity rarity) {
+    public @NotNull
+    EnchantmentBuilder setRarity(@NotNull Rarity rarity) {
         this.rarity = rarity;
         return this;
     }
@@ -75,7 +77,8 @@ public abstract class EnchantmentBuilder {
     /**
      * Which types of items this can be applied to.
      */
-    public @NotNull EnchantmentBuilder setTarget(@NotNull Target target) {
+    public @NotNull
+    EnchantmentBuilder setTarget(@NotNull Target target) {
         this.target = target;
         this.canEnchant = null;
         return this;
@@ -85,7 +88,8 @@ public abstract class EnchantmentBuilder {
      * Is this a 'treasure' enchantment found only in
      * loot chests (e.g. Mending, Frost Walker.)
      */
-    public @NotNull EnchantmentBuilder setTreasure(boolean treasure) {
+    public @NotNull
+    EnchantmentBuilder setTreasure(boolean treasure) {
         this.treasure = treasure;
         return this;
     }
@@ -93,7 +97,8 @@ public abstract class EnchantmentBuilder {
     /**
      * Is this a 'curse' enchantment - not removable via grindstone.
      */
-    public @NotNull EnchantmentBuilder setCurse(boolean curse) {
+    public @NotNull
+    EnchantmentBuilder setCurse(boolean curse) {
         this.curse = curse;
         return this;
     }
@@ -101,7 +106,8 @@ public abstract class EnchantmentBuilder {
     /**
      * Will this appear within the villager trading set, like Mending?
      */
-    public @NotNull EnchantmentBuilder setTradable(boolean tradable) {
+    public @NotNull
+    EnchantmentBuilder setTradable(boolean tradable) {
         this.tradable = tradable;
         return this;
     }
@@ -110,10 +116,11 @@ public abstract class EnchantmentBuilder {
      * Exact purpose is unknown.
      * Currently, soul speed is the only enchantment with this marked
      * as FALSE. All others are true by default.
-     *
+     * <p>
      * May have something to do with enchantment tables?
      */
-    public @NotNull EnchantmentBuilder setDiscoverable(boolean discoverable) {
+    public @NotNull
+    EnchantmentBuilder setDiscoverable(boolean discoverable) {
         this.discoverable = discoverable;
         return this;
     }
@@ -121,7 +128,8 @@ public abstract class EnchantmentBuilder {
     /**
      * The minimum (starting) level, almost always 1.
      */
-    public @NotNull EnchantmentBuilder setMinLevel(int minLevel) {
+    public @NotNull
+    EnchantmentBuilder setMinLevel(int minLevel) {
         this.minLevel = minLevel;
         return this;
     }
@@ -129,7 +137,8 @@ public abstract class EnchantmentBuilder {
     /**
      * The maximum safe level.
      */
-    public @NotNull EnchantmentBuilder setMaxLevel(int maxLevel) {
+    public @NotNull
+    EnchantmentBuilder setMaxLevel(int maxLevel) {
         this.maxLevel = maxLevel;
         return this;
     }
@@ -137,7 +146,8 @@ public abstract class EnchantmentBuilder {
     /**
      * Experience and anvil multipliers.
      */
-    public @NotNull EnchantmentBuilder setMinCost(int minCost) {
+    public @NotNull
+    EnchantmentBuilder setMinCost(int minCost) {
         this.minCost = minCost;
         return this;
     }
@@ -145,7 +155,8 @@ public abstract class EnchantmentBuilder {
     /**
      * Experience and anvil multipliers.
      */
-    public @NotNull EnchantmentBuilder setMaxCost(int maxCost) {
+    public @NotNull
+    EnchantmentBuilder setMaxCost(int maxCost) {
         this.maxCost = maxCost;
         return this;
     }
@@ -153,7 +164,8 @@ public abstract class EnchantmentBuilder {
     /**
      * Whether this can be applied to the target item stack.
      */
-    public @NotNull EnchantmentBuilder setCanEnchant(@Nullable Function<ItemStack, Boolean> canEnchant) {
+    public @NotNull
+    EnchantmentBuilder setCanEnchant(@Nullable Function<ItemStack, Boolean> canEnchant) {
         this.canEnchant = canEnchant;
         this.target = null;
         return this;
@@ -163,7 +175,8 @@ public abstract class EnchantmentBuilder {
      * Whether this enchantment is active or inert in the given slot.
      * For example; frost walker is inert unless on the boots.
      */
-    public @NotNull EnchantmentBuilder setEffectiveSlots(@NotNull EquipmentSlot[] effectiveSlots) {
+    public @NotNull
+    EnchantmentBuilder setEffectiveSlots(@NotNull EquipmentSlot[] effectiveSlots) {
         this.effectiveSlots = effectiveSlots;
         return this;
     }
@@ -172,7 +185,8 @@ public abstract class EnchantmentBuilder {
      * This is used to influence taken damage. The exact purpose is unclear, but
      * it is used by protection enchantments.
      */
-    public @NotNull EnchantmentBuilder setDamageProtection(@NotNull Function<EntityDamageEvent.DamageCause, Integer> damageProtection) {
+    public @NotNull
+    EnchantmentBuilder setDamageProtection(@NotNull Function<EntityDamageEvent.DamageCause, Integer> damageProtection) {
         this.damageProtection = damageProtection;
         return this;
     }
@@ -181,7 +195,8 @@ public abstract class EnchantmentBuilder {
      * This is used to affect damage bonuses against entity types.
      * (e.g. smite, bane of arthropods.)
      */
-    public @NotNull EnchantmentBuilder setDamageBonus(@NotNull Function<EntityCategory, Float> damageBonus) {
+    public @NotNull
+    EnchantmentBuilder setDamageBonus(@NotNull Function<EntityCategory, Float> damageBonus) {
         this.damageBonus = damageBonus;
         return this;
     }
@@ -190,7 +205,8 @@ public abstract class EnchantmentBuilder {
      * Whether this enchantment can be applied in conjunction with the another.
      * (e.g. sharpness conflicts with smite.)
      */
-    public @NotNull EnchantmentBuilder setCompatible(@NotNull Function<Enchantment, Boolean> compatible) {
+    public @NotNull
+    EnchantmentBuilder setCompatible(@NotNull Function<Enchantment, Boolean> compatible) {
         this.compatible = compatible;
         return this;
     }
@@ -199,7 +215,8 @@ public abstract class EnchantmentBuilder {
      * The description language key.
      * Exact implementation is unknown.
      */
-    public @NotNull EnchantmentBuilder setDescription(@NotNull String description) {
+    public @NotNull
+    EnchantmentBuilder setDescription(@NotNull String description) {
         this.description = description;
         return this;
     }
@@ -207,10 +224,11 @@ public abstract class EnchantmentBuilder {
     /**
      * A function to create a name based on the enchantment level.
      * (e.g. Sharpness IV)
-     *
+     * <p>
      * By default, this will generate one akin to the generic.
      */
-    public @NotNull EnchantmentBuilder setNameByLevel(@NotNull Function<Integer, BaseComponent[]> nameByLevel) {
+    public @NotNull
+    EnchantmentBuilder setNameByLevel(@NotNull Function<Integer, BaseComponent[]> nameByLevel) {
         this.nameByLevel = nameByLevel;
         return this;
     }
@@ -218,7 +236,8 @@ public abstract class EnchantmentBuilder {
     /**
      * Schedule a function to be executed upon dealing damage to an entity.
      */
-    public @NotNull EnchantmentBuilder onDealDamage(@Nullable EnchantmentStrikeConsumer onDealDamage) {
+    public @NotNull
+    EnchantmentBuilder onDealDamage(@Nullable EnchantmentStrikeConsumer onDealDamage) {
         this.onDealDamage = onDealDamage;
         return this;
     }
@@ -226,15 +245,18 @@ public abstract class EnchantmentBuilder {
     /**
      * Schedule a function to be executed upon taking damage.
      */
-    public @NotNull EnchantmentBuilder onTakeDamage(@Nullable EnchantmentStrikeConsumer onTakeDamage) {
+    public @NotNull
+    EnchantmentBuilder onTakeDamage(@Nullable EnchantmentStrikeConsumer onTakeDamage) {
         this.onTakeDamage = onTakeDamage;
         return this;
     }
 
     /**
      * Registers and creates the enchantment.
+     *
      * @return the newly-registered enchantment.
      */
-    public abstract @NotNull Enchantment create();
+    public abstract @NotNull
+    Enchantment create();
 
 }
diff --git a/src/main/java/mx/kenzie/wellspring/enchantment/EnchantmentStrikeConsumer.java b/src/main/java/mx/kenzie/wellspring/enchantment/EnchantmentStrikeConsumer.java
index 5154b00d097e8423017d5422a83eb4a0fc0c7762..12c2920e9ed9192865fe7a72d6bc8a87ccbefdd2 100644
--- a/src/main/java/mx/kenzie/wellspring/enchantment/EnchantmentStrikeConsumer.java
+++ b/src/main/java/mx/kenzie/wellspring/enchantment/EnchantmentStrikeConsumer.java
@@ -1,6 +1,5 @@
 package mx.kenzie.wellspring.enchantment;
 
-import org.bukkit.UndefinedNullability;
 import org.bukkit.entity.Entity;
 import org.bukkit.entity.LivingEntity;
 import org.jetbrains.annotations.NotNull;
@@ -17,9 +16,10 @@ public interface EnchantmentStrikeConsumer {
 
     /**
      * This is used for dealing/taking damage
-     * @param holder The wielder of the enchanted item
+     *
+     * @param holder   The wielder of the enchanted item
      * @param opponent The opponent - may be null during damage-taking
-     * @param level The enchantment level
+     * @param level    The enchantment level
      */
     void onStrike(@NotNull LivingEntity holder, @Nullable Entity opponent, int level);
 
diff --git a/src/main/java/mx/kenzie/wellspring/entity/CustomEntityRegistry.java b/src/main/java/mx/kenzie/wellspring/entity/CustomEntityRegistry.java
index d34f221fb3e3d75f643dda9d84710287a18422dd..dcc6b750a927e0499395f29e01046e2d5687e279 100644
--- a/src/main/java/mx/kenzie/wellspring/entity/CustomEntityRegistry.java
+++ b/src/main/java/mx/kenzie/wellspring/entity/CustomEntityRegistry.java
@@ -15,7 +15,8 @@ public abstract class CustomEntityRegistry {
     /**
      * Internal route.
      */
-    protected @NotNull CustomEntityType createType(@NotNull String name, @NotNull NamespacedKey key, @NotNull Class<? extends CustomEntity> cls, short id, boolean spawnable, boolean alive) {
+    protected @NotNull
+    CustomEntityType createType(@NotNull String name, @NotNull NamespacedKey key, @NotNull Class<? extends CustomEntity> cls, short id, boolean spawnable, boolean alive) {
         return new CustomEntityType(name, key, cls, id, spawnable, alive);
     }
 
diff --git a/src/main/java/mx/kenzie/wellspring/entity/Human.java b/src/main/java/mx/kenzie/wellspring/entity/Human.java
index e829e6ef3c83f43402abb9b9e0cdacb75597708d..ab2988bdedf108f7a1a307fd0efb7eae5e75bbcd 100644
--- a/src/main/java/mx/kenzie/wellspring/entity/Human.java
+++ b/src/main/java/mx/kenzie/wellspring/entity/Human.java
@@ -1,6 +1,5 @@
 package mx.kenzie.wellspring.entity;
 
-import org.bukkit.entity.LivingEntity;
 import org.bukkit.entity.Player;
 
 public interface Human extends Player {
diff --git a/src/main/java/mx/kenzie/wellspring/event/EntityLandEvent.java b/src/main/java/mx/kenzie/wellspring/event/EntityLandEvent.java
index 1a5b48067ffce75e189c0da7a1b0797e5bb0a38d..f0ced91def33fd3d5ab62c8aa59a0b70f7b05444 100644
--- a/src/main/java/mx/kenzie/wellspring/event/EntityLandEvent.java
+++ b/src/main/java/mx/kenzie/wellspring/event/EntityLandEvent.java
@@ -15,6 +15,11 @@ public class EntityLandEvent extends EntityEvent {
         super(entity);
     }
 
+    @NotNull
+    public static HandlerList getHandlerList() {
+        return handlers;
+    }
+
     @NotNull
     @Override
     public Entity getEntity() {
@@ -26,9 +31,4 @@ public class EntityLandEvent extends EntityEvent {
     public HandlerList getHandlers() {
         return handlers;
     }
-
-    @NotNull
-    public static HandlerList getHandlerList() {
-        return handlers;
-    }
 }
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBT.java b/src/main/java/mx/kenzie/wellspring/nbt/NBT.java
index 1dabec9a18d9f8dab14748b8995fa36146fc25c9..71f736b1d7592790aef6f1baa57de1358bcd77a3 100644
--- a/src/main/java/mx/kenzie/wellspring/nbt/NBT.java
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBT.java
@@ -4,13 +4,12 @@ import net.md_5.bungee.api.chat.BaseComponent;
 import org.bukkit.Bukkit;
 import org.jetbrains.annotations.NotNull;
 
-import java.util.Collection;
 import java.util.Map;
 
 /**
  * This represents an NBT 'base' object, which could be either a map-compound,
  * a list of bases, or a simple wrapped value.
- *
+ * <p>
  * In order to determine which, {@link NBT#getType()} can be used.
  *
  * @author Moderocky
@@ -23,12 +22,13 @@ public interface NBT {
      * are already NBT types.
      *
      * @param object An object of a valid type.
-     * @param type The type of the object, for conversion.
+     * @param type   The type of the object, for conversion.
      * @return The converted NBT base.
      * @throws IllegalArgumentException If the type was invalid or the object could not be converted.
      */
     @SuppressWarnings("deprecation")
-    static @NotNull NBT convert(@NotNull Object object, @NotNull Type type) throws IllegalArgumentException {
+    static @NotNull
+    NBT convert(@NotNull Object object, @NotNull Type type) throws IllegalArgumentException {
         return Bukkit.getNBTFactory().newBase(object, type);
     }
 
@@ -36,15 +36,17 @@ public interface NBT {
      * This is a utility for converting objects without knowing their type.
      * This works with primitives, strings, some numerical arrays and objects that
      * are already NBT types.
-     *
+     * <p>
      * It can also recursively convert lists, arrays and maps.
-     *
+     * <p>
      * It will not convert objects of invalid types!
+     *
      * @param object An object of a valid type.
      * @return The converted NBT base.
      * @throws IllegalArgumentException If the type was invalid or the object could not be converted.
      */
-    static @NotNull NBT convert(@NotNull Object object) throws IllegalArgumentException {
+    static @NotNull
+    NBT convert(@NotNull Object object) throws IllegalArgumentException {
         if (object instanceof NBT) return (NBT) object;
         if (object instanceof NBT[]) return NBTList.create((NBT[]) object);
         if (object instanceof Boolean) return convert(object, Type.BOOLEAN);
@@ -71,7 +73,8 @@ public interface NBT {
      * @return The true value. This will be of the type specified in {@link Type#cls}
      * @throws RuntimeException If the value cannot be obtained or the base is abnormal.
      */
-    @NotNull <T> T getAsObject() throws RuntimeException;
+    @NotNull
+    <T> T getAsObject() throws RuntimeException;
 
     /**
      * This will attempt to unwrap the entire NBT structure to Java objects.
@@ -82,12 +85,14 @@ public interface NBT {
      * @return The unwrapped object.
      * @throws RuntimeException If anything inside the structure cannot be unwrapped.
      */
-    default @NotNull <T> Object unwrap() throws RuntimeException {
+    default @NotNull
+    <T> Object unwrap() throws RuntimeException {
         return getAsObject(); // Overridden by other types.
     }
 
     /**
      * Magic value.
+     *
      * @return The raw numerical type.
      */
     @Deprecated
@@ -97,13 +102,16 @@ public interface NBT {
         return getType() == type;
     }
 
-    default @NotNull Type getType() {
+    default @NotNull
+    Type getType() {
         return Type.fromId(getTypeId());
     }
 
-    public @NotNull NBT clone();
+    @NotNull
+    NBT clone();
 
-    default @NotNull BaseComponent[] display() {
+    default @NotNull
+    BaseComponent[] display() {
         return display(0, "");
     }
 
@@ -136,13 +144,22 @@ public interface NBT {
         PRIMITIVE_TYPE(99, Object.class);
 
         final int raw;
-        final @NotNull Class<?> cls;
+        final @NotNull
+        Class<?> cls;
 
         Type(int raw, @NotNull Class<?> cls) {
             this.raw = raw;
             this.cls = cls;
         }
 
+        public static @NotNull
+        Type fromId(int raw) {
+            for (Type type : values()) {
+                if (type.raw == raw) return type;
+            }
+            throw new IllegalArgumentException("Unknown type passed to converter.");
+        }
+
         public int getRawId() {
             return raw;
         }
@@ -151,14 +168,6 @@ public interface NBT {
         public Class<?> getEntryClass() {
             return cls;
         }
-
-        public static @NotNull
-        Type fromId(int raw) {
-            for (Type type : values()) {
-                if (type.raw == raw) return type;
-            }
-            throw new IllegalArgumentException("Unknown type passed to converter.");
-        }
     }
 
 }
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBTCompound.java b/src/main/java/mx/kenzie/wellspring/nbt/NBTCompound.java
index 029dc8e2528fb68433fc2a24cc00334a4ab416b4..b3a97156eafb35faa58d210396e4131e962e4050 100644
--- a/src/main/java/mx/kenzie/wellspring/nbt/NBTCompound.java
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBTCompound.java
@@ -4,7 +4,10 @@ import org.bukkit.Bukkit;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
-import java.util.*;
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Set;
+import java.util.UUID;
 
 /**
  * This represents an NBT 'compound,' which is a (String) key -> (NBT base) value map.
@@ -15,29 +18,35 @@ public interface NBTCompound extends NBT {
 
     /**
      * Creates a new NBT Compound, similar to a Map.
+     *
      * @return a new NBT compound.
      */
-    static @NotNull NBTCompound create() {
+    static @NotNull
+    NBTCompound create() {
         return Bukkit.getNBTFactory().newCompound();
     }
 
     /**
      * Attempts to parse a stringified NBT compound and deserialises it.
+     *
      * @param stringifiedNBT the string compound.
      * @return the deserialised compound.
      * @throws IllegalArgumentException if the string cannot be parsed.
      */
-    static @NotNull NBTCompound create(@NotNull String stringifiedNBT) throws IllegalArgumentException {
+    static @NotNull
+    NBTCompound create(@NotNull String stringifiedNBT) throws IllegalArgumentException {
         return Bukkit.getNBTFactory().parse(stringifiedNBT);
     }
 
     /**
      * Creates a new NBT Compound by wrapping the map and its values.
+     *
      * @param map The provided map to wrap.
      * @return the new compound with values.
      * @throws RuntimeException if the map's contents cannot be converted.
      */
-    static @NotNull NBTCompound create(@NotNull Map<?, ?> map) throws RuntimeException {
+    static @NotNull
+    NBTCompound create(@NotNull Map<?, ?> map) throws RuntimeException {
         final NBTCompound compound = NBTCompound.create();
         for (Map.Entry<?, ?> entry : map.entrySet()) {
             Object object = entry.getValue();
@@ -65,7 +74,8 @@ public interface NBTCompound extends NBT {
 
     /**
      * Potentially version-dependent - easier to use {@link NBTCompound#containsKey(String, Type)}
-     * @param key The string key.
+     *
+     * @param key     The string key.
      * @param rawType The NBT base type.
      * @return Whether key is present.
      */
@@ -118,41 +128,53 @@ public interface NBTCompound extends NBT {
 
     double getDouble(@NotNull String key);
 
-    @Nullable byte[] getByteArray(@NotNull String key);
+    @Nullable
+    byte[] getByteArray(@NotNull String key);
 
-    @Nullable int[] getIntArray(@NotNull String key);
+    @Nullable
+    int[] getIntArray(@NotNull String key);
 
-    @Nullable long[] getLongArray(@NotNull String key);
+    @Nullable
+    long[] getLongArray(@NotNull String key);
 
-    @Nullable String getString(@NotNull String key);
+    @Nullable
+    String getString(@NotNull String key);
 
-    @Nullable NBTCompound getCompound(@NotNull String key);
+    @Nullable
+    NBTCompound getCompound(@NotNull String key);
 
-    @Nullable NBTList getList(@NotNull String key);
+    @Nullable
+    NBTList getList(@NotNull String key);
 
-    @Nullable NBT get(@NotNull String key);
+    @Nullable
+    NBT get(@NotNull String key);
 
     void remove(@NotNull String key);
 
-    @NotNull NBTCompound clone();
+    @NotNull
+    NBTCompound clone();
 
     /**
      * Merges the second compound into this. Entries from the new compound will override and replace this.
+     *
      * @param compound The compound to merge.
      * @return This compound.
      */
-    @NotNull NBTCompound merge(@NotNull NBTCompound compound);
+    @NotNull
+    NBTCompound merge(@NotNull NBTCompound compound);
 
     /**
      * @return A clone of this NBT compound as a map of keys/NBT bases.
      */
-    @NotNull Map<String, NBT> getAsMap();
+    @NotNull
+    Map<String, NBT> getAsMap();
 
     @NotNull
     Set<String> getKeys();
 
     @SuppressWarnings({"unchecked", "deprecation"})
-    default @Nullable <T> T get(@NotNull String key, @NotNull Type type) {
+    default @Nullable
+    <T> T get(@NotNull String key, @NotNull Type type) {
         switch (type) {
             case NULL_TERMINATOR:
             case PRIMITIVE_TYPE:
@@ -201,7 +223,8 @@ public interface NBTCompound extends NBT {
      */
     @Override
     @SuppressWarnings("unchecked")
-    default @NotNull <T> Map<String, Object> unwrap() throws RuntimeException {
+    default @NotNull
+    <T> Map<String, Object> unwrap() throws RuntimeException {
         final Map<String, Object> map = new HashMap<>();
         for (String key : this.getKeys()) {
             NBT nbt = this.get(key);
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBTFactory.java b/src/main/java/mx/kenzie/wellspring/nbt/NBTFactory.java
index 5e68d32122c1da8aef7e6b482aea489e52d27c6a..7a36163e35d4533b244d755ff66e5fc4b2188ff3 100644
--- a/src/main/java/mx/kenzie/wellspring/nbt/NBTFactory.java
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBTFactory.java
@@ -6,7 +6,7 @@ import org.jetbrains.annotations.NotNull;
 
 /**
  * The NBT factory is provided by the server as a means of managing NBT implementations.
- *
+ * <p>
  * Generally speaking, it should not be used as most of the functions can be
  * employed via their respective classes.
  *
@@ -20,52 +20,64 @@ public abstract class NBTFactory {
     /**
      * Allows for the conversion of a stringified NBT compound to an NBT compound.
      * This should generally NOT be used, except for the purposes of NBT storage.
-     *
+     * <p>
      * This is NOT an excuse to write out NBT manually! Please use the map system instead.
      *
      * @param string The stringified NBT.
      * @return The compound.
      * @throws IllegalArgumentException If the string is invalid, malformed or otherwise
-     * un-parsable.
+     *                                  un-parsable.
      */
-    public abstract @NotNull NBTCompound parse(@NotNull String string) throws IllegalArgumentException;
+    public abstract @NotNull
+    NBTCompound parse(@NotNull String string) throws IllegalArgumentException;
 
     /**
      * Produces a new NBT compound.
+     *
      * @return A new empty compound.
      */
-    public abstract @NotNull NBTCompound newCompound();
+    public abstract @NotNull
+    NBTCompound newCompound();
 
     /**
      * Produces a new NBT list.
+     *
      * @return A new empty list.
      */
-    public abstract @NotNull NBTList newList();
+    public abstract @NotNull
+    NBTList newList();
 
     /**
      * For internal use only - potentially unsafe!
+     *
      * @param object The object to convert. MUST be a valid {@link NBT.Type}!
-     * @param type The base type.
+     * @param type   The base type.
      * @return The converted base.
      * @throws IllegalArgumentException If the type cannot be wrapped as an NBT base.
      */
     @Deprecated
-    public abstract @NotNull NBT newBase(@NotNull Object object, @NotNull NBT.Type type) throws IllegalArgumentException;
+    public abstract @NotNull
+    NBT newBase(@NotNull Object object, @NotNull NBT.Type type) throws IllegalArgumentException;
 
-    public @NotNull NBTCompound getNBT(@NotNull NBTHolder holder) {
+    public @NotNull
+    NBTCompound getNBT(@NotNull NBTHolder holder) {
         return holder.getNBT();
     }
 
-    public abstract @NotNull NBTCompound getNBT(@NotNull Entity entity);
+    public abstract @NotNull
+    NBTCompound getNBT(@NotNull Entity entity);
 
     public abstract void mergeNBT(@NotNull ItemStack itemStack, @NotNull NBTCompound compound);
 
     public abstract void setNBT(@NotNull ItemStack itemStack, @NotNull NBTCompound compound);
 
-    public abstract @NotNull NBTCompound getNBT(@NotNull ItemStack itemStack);
+    public abstract @NotNull
+    NBTCompound getNBT(@NotNull ItemStack itemStack);
 
-    public abstract @NotNull NBTCompound getAsCompound(@NotNull ItemStack itemStack);
+    public abstract @NotNull
+    NBTCompound getAsCompound(@NotNull ItemStack itemStack);
 
-    public abstract @NotNull ItemStack createItem(@NotNull NBTCompound compound);
+    public abstract @NotNull
+    ItemStack createItem(@NotNull NBTCompound compound);
 
 }
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBTHolder.java b/src/main/java/mx/kenzie/wellspring/nbt/NBTHolder.java
index bebd550bbd2613a7d5307787a58b451766308087..7be379c689d35bff0b838b25d99b5e0e56b06b28 100644
--- a/src/main/java/mx/kenzie/wellspring/nbt/NBTHolder.java
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBTHolder.java
@@ -5,13 +5,13 @@ import org.jetbrains.annotations.NotNull;
 /**
  * An object that holds (or is stored as) data in the NBT (Named Binary Tag) format.
  * This includes entities, items, world events and potentially structures.
- *
+ * <p>
  * Not all NBT-holders are currently implemented.
- *
+ * <p>
  * This is generally an unsafe class to mess with! Please refrain especially from
  * merging or loading new compounds unless you know what you are doing - it may
  * lead to data corruption or unexpected consequences.
- *
+ * <p>
  * NBT access is potentially SLOWER than using the direct methods! It should not be
  * treated as an alternative to the existing entity/item API.
  *
@@ -24,20 +24,21 @@ public interface NBTHolder {
      * Please note that this internally triggers the saving method, which serialises
      * all of the holder's persistent data - not something that ought to be done
      * frequently.
-     *
+     * <p>
      * It will also trigger any attachment accessors.
      *
      * @return A clone of the holder's stored data as an NBT compound.
      */
-    @NotNull NBTCompound getNBT();
+    @NotNull
+    NBTCompound getNBT();
 
     /**
      * This will merge the provided compound with the holder's existing data.
      * Values from the new compound will OVERWRITE existing values.
-     *
+     * <p>
      * This is preferable to {@link NBTHolder#loadNBT(NBTCompound)} as it has less chance
      * of breaking anything important due to missing values.
-     *
+     * <p>
      * Note that this internally reloads the holder's data, as if from file.
      * It will also trigger any attachment accessors. As such, it should not be
      * done too frequently as it can cause unnecessary delays.
@@ -53,10 +54,10 @@ public interface NBTHolder {
      * This will replace the holder's existing data with the provided compound.
      * This is potentially UNSAFE! Please refrain from using this unless you know
      * what you are doing.
-     *
+     * <p>
      * {@link NBTHolder#mergeNBT(NBTCompound)} is preferable as it has less chance
      * of breaking anything important.
-     *
+     * <p>
      * Note that this internally reloads the holder's data, as if from file.
      * It will also trigger any attachment accessors. As such, it should not be
      * done too frequently as it can cause unnecessary delays.
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBTList.java b/src/main/java/mx/kenzie/wellspring/nbt/NBTList.java
index 6d197d8d803f9cf294d3b5a010279e0b1cf47dfe..d9514d935029463cf92e5eb2938bdf9b94977f15 100644
--- a/src/main/java/mx/kenzie/wellspring/nbt/NBTList.java
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBTList.java
@@ -7,7 +7,7 @@ import java.util.*;
 
 /**
  * A list of NBT bases. This includes compounds or primitive types.
- *
+ * <p>
  * This is (internally) a {@link Collection} but cannot be typed as such.
  * You may safely use {@link NBTList#getAsArray()} or {@link NBTList#getAsList()} for iteration.
  *
@@ -18,17 +18,20 @@ public interface NBTList extends NBT {
     /**
      * @return A new NBT list.
      */
-    static @NotNull NBTList create() {
+    static @NotNull
+    NBTList create() {
         return Bukkit.getNBTFactory().newList();
     }
 
     /**
      * This is purely a utility method for faster list creation.
      * Similar to {@link Arrays#asList(Object[])} but for NBT.
+     *
      * @param bases An array of NBT bases
      * @return The list with the bases added.
      */
-    static @NotNull NBTList create(@NotNull NBT... bases) {
+    static @NotNull
+    NBTList create(@NotNull NBT... bases) {
         final NBTList list = NBTList.create();
         for (NBT nbt : bases) {
             list.add(nbt);
@@ -39,13 +42,14 @@ public interface NBTList extends NBT {
     /**
      * This is purely a utility method for faster list creation.
      * Similar to {@link Arrays#asList(Object[])} but for NBT.
-     *
+     * <p>
      * The objects will be converted to NBT bases.
      *
      * @param objects An array of objects
      * @return The list with the objects converted and added.
      */
-    static @NotNull NBTList create(@NotNull Object... objects) {
+    static @NotNull
+    NBTList create(@NotNull Object... objects) {
         final NBTList list = NBTList.create();
         for (Object object : objects) {
             list.add(NBT.convert(object));
@@ -56,14 +60,15 @@ public interface NBTList extends NBT {
     /**
      * This is purely a utility method for faster list creation.
      * Similar to {@link ArrayList}'s clone constructor, but for NBT.
-     *
+     * <p>
      * The objects will be converted to NBT bases.
      * If they are already NBT bases, they will be added.
      *
      * @param objects A collection of objects
      * @return The list with the objects converted and added.
      */
-    static @NotNull NBTList create(@NotNull Iterable<?> objects) {
+    static @NotNull
+    NBTList create(@NotNull Iterable<?> objects) {
         final NBTList list = NBTList.create();
         for (Object object : objects) {
             if (object instanceof NBT) list.add(((NBT) object));
@@ -86,12 +91,14 @@ public interface NBTList extends NBT {
 
     /**
      * Adds a new NBT entry.
+     *
      * @param entry The entry to add.
      */
     void add(@NotNull NBT entry);
 
     /**
      * Removes the specified entry.
+     *
      * @param entry The entry to remove.
      */
     void remove(@NotNull NBT entry);
@@ -100,23 +107,26 @@ public interface NBTList extends NBT {
      * Produces a collection of this list's entries.
      * The collection is NOT backed by the original list, but the
      * NBT bases in the list are the originals.
-     *
+     * <p>
      * It is safe to remove elements of this from the original list
      * during iteration, as it is a copy.
      *
      * @return A new fixed-length collection.
      */
-    @NotNull Collection<NBT> getAsList();
+    @NotNull
+    Collection<NBT> getAsList();
 
     /**
      * @return An array of this list's entries.
      */
-    @NotNull NBT[] getAsArray();
+    @NotNull
+    NBT[] getAsArray();
 
     /**
      * @return This list unwrapped to Java objects.
      */
-    default @NotNull List<Object> getAsObjects() {
+    default @NotNull
+    List<Object> getAsObjects() {
         final List<Object> list = new ArrayList<>();
         for (NBT nbt : this.getAsArray()) {
             list.add(nbt.getAsObject());
@@ -135,7 +145,8 @@ public interface NBTList extends NBT {
      */
     @Override
     @SuppressWarnings("unchecked")
-    default @NotNull <T> List<T> unwrap() throws RuntimeException {
+    default @NotNull
+    <T> List<T> unwrap() throws RuntimeException {
         final List<Object> list = new ArrayList<>();
         for (NBT nbt : this.getAsArray()) {
             list.add(nbt.unwrap());
@@ -143,12 +154,16 @@ public interface NBTList extends NBT {
         return (List<T>) list;
     }
 
-    @NotNull Iterator<NBT> getIterator();
+    @NotNull
+    Iterator<NBT> getIterator();
 
-    @NotNull NBT remove(int index) throws IndexOutOfBoundsException;
+    @NotNull
+    NBT remove(int index) throws IndexOutOfBoundsException;
 
-    @NotNull NBT get(int index) throws IndexOutOfBoundsException;
+    @NotNull
+    NBT get(int index) throws IndexOutOfBoundsException;
 
-    @NotNull NBTList clone();
+    @NotNull
+    NBTList clone();
 
 }
diff --git a/src/main/java/mx/kenzie/wellspring/packet/Packet.java b/src/main/java/mx/kenzie/wellspring/packet/Packet.java
index bf408dadad101091a0bdaee2d7f9715d71070e4c..68f321ef42e95369e3f025f30cc4127f7a1787f3 100644
--- a/src/main/java/mx/kenzie/wellspring/packet/Packet.java
+++ b/src/main/java/mx/kenzie/wellspring/packet/Packet.java
@@ -27,7 +27,7 @@ public interface Packet {
 
     enum Direction {
         INCOMING,
-        OUTGOING;
+        OUTGOING
     }
 
 }
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketBuilder.java b/src/main/java/mx/kenzie/wellspring/packet/PacketBuilder.java
index 52e43a4cc6170e3cf37e580ac824a6f96f3a0fb9..cbf752123f1feb620aae53d5d5aa8fcea7ef3bb0 100644
--- a/src/main/java/mx/kenzie/wellspring/packet/PacketBuilder.java
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketBuilder.java
@@ -14,20 +14,24 @@ import java.util.List;
  */
 public class PacketBuilder {
 
-    private final @NotNull PacketType type;
-    private final @NotNull List<Object> list;
+    private final @NotNull
+    PacketType type;
+    private final @NotNull
+    List<Object> list;
 
     public PacketBuilder(@NotNull PacketType type) {
         this.type = type;
         this.list = new ArrayList<>();
     }
 
-    public @NotNull PacketBuilder with(@Nullable Object object) {
+    public @NotNull
+    PacketBuilder with(@Nullable Object object) {
         list.add(object);
         return this;
     }
 
-    public @NotNull Packet create() {
+    public @NotNull
+    Packet create() {
         return Bukkit.getPacketFactory().createFrom(type, list.toArray(new Object[0]));
     }
 
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketConstructor.java b/src/main/java/mx/kenzie/wellspring/packet/PacketConstructor.java
index 4288f24793983426fb098d4cd49aa7bcd949af1e..2bb73aa04e3d58d79a0ee961e47b3941821e2004 100644
--- a/src/main/java/mx/kenzie/wellspring/packet/PacketConstructor.java
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketConstructor.java
@@ -5,6 +5,7 @@ import org.jetbrains.annotations.NotNull;
 @FunctionalInterface
 public interface PacketConstructor<T> {
 
-    @NotNull T create();
+    @NotNull
+    T create();
 
 }
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketFactory.java b/src/main/java/mx/kenzie/wellspring/packet/PacketFactory.java
index 9888aceab7f50cb5081a69e6a12dbb921f5dd9f9..44b7f01813597acfbc7b2b2381c7bdc3f6246ab3 100644
--- a/src/main/java/mx/kenzie/wellspring/packet/PacketFactory.java
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketFactory.java
@@ -17,7 +17,7 @@ import java.util.UUID;
 
 /**
  * For creating and sending outgoing packets to the client.
- *
+ * <p>
  * Not fully implemented!
  *
  * @author Moderocky
@@ -27,39 +27,52 @@ public abstract class PacketFactory {
     /**
      * Creates a packet from the given type using a builder system.
      * This allows you to input the field values of the packet directly.
-     *
+     * <p>
      * WARNING - this is potentially unsafe and requires knowledge of the NMS packet code.
      * If possible, please use the exposed builder methods instead.
      *
-     * @param type The packet type - this should almost always be {@link mx.kenzie.wellspring.packet.PacketType.Outgoing}
+     * @param type        The packet type - this should almost always be {@link mx.kenzie.wellspring.packet.PacketType.Outgoing}
      * @param fieldInputs The field values, in order. These will be set via reflection
      * @return The complete packet, if possible
      */
-    public abstract @NotNull Packet createFrom(@NotNull PacketType type, @NotNull Object... fieldInputs) throws IllegalArgumentException;
+    public abstract @NotNull
+    Packet createFrom(@NotNull PacketType type, @NotNull Object... fieldInputs) throws IllegalArgumentException;
 
-    public abstract @NotNull Packet loginOutCustomPayload();
+    public abstract @NotNull
+    Packet loginOutCustomPayload();
 
-    public abstract @NotNull Packet playOutAbilities(boolean invulnerable, boolean flying, boolean canFly, boolean canInstantlyBuild, float flySpeed, float walkSpeed);
+    public abstract @NotNull
+    Packet playOutAbilities(boolean invulnerable, boolean flying, boolean canFly, boolean canInstantlyBuild, float flySpeed, float walkSpeed);
 
-    public abstract @NotNull Packet playOutAdvancements(boolean reset, @NotNull Collection<Advancement> toAdd, @NotNull Set<NamespacedKey> toRemove, @NotNull Map<NamespacedKey, AdvancementProgress> progress);
+    public abstract @NotNull
+    Packet playOutAdvancements(boolean reset, @NotNull Collection<Advancement> toAdd, @NotNull Set<NamespacedKey> toRemove, @NotNull Map<NamespacedKey, AdvancementProgress> progress);
 
-    public abstract @NotNull Packet playOutAnimation(@NotNull Entity entity, int animationId);
+    public abstract @NotNull
+    Packet playOutAnimation(@NotNull Entity entity, int animationId);
 
-    public abstract @NotNull Packet playOutAttachEntity(@NotNull Entity target, @NotNull Entity holder);
+    public abstract @NotNull
+    Packet playOutAttachEntity(@NotNull Entity target, @NotNull Entity holder);
 
-    public abstract @NotNull Packet playOutAutoRecipe(int container, @NotNull NamespacedKey recipe);
+    public abstract @NotNull
+    Packet playOutAutoRecipe(int container, @NotNull NamespacedKey recipe);
 
-    public abstract @NotNull Packet playOutBlockAction(@NotNull Location location, @NotNull BlockData data, int action, int parameter);
+    public abstract @NotNull
+    Packet playOutBlockAction(@NotNull Location location, @NotNull BlockData data, int action, int parameter);
 
-    public abstract @NotNull Packet playOutSpawnEntity(@NotNull EntityType type, @NotNull Location location);
+    public abstract @NotNull
+    Packet playOutSpawnEntity(@NotNull EntityType type, @NotNull Location location);
 
-    public abstract @NotNull Packet playOutSpawnEntity(@NotNull EntityType type, @NotNull Location location, int id, @NotNull UUID uuid);
+    public abstract @NotNull
+    Packet playOutSpawnEntity(@NotNull EntityType type, @NotNull Location location, int id, @NotNull UUID uuid);
 
-    public abstract @NotNull Packet playOutSpawnLivingEntity(@NotNull EntityType type, @NotNull Location location);
+    public abstract @NotNull
+    Packet playOutSpawnLivingEntity(@NotNull EntityType type, @NotNull Location location);
 
-    public abstract @NotNull Packet playOutSpawnLivingEntity(@NotNull EntityType type, @NotNull Location location, int id, @NotNull UUID uuid);
+    public abstract @NotNull
+    Packet playOutSpawnLivingEntity(@NotNull EntityType type, @NotNull Location location, int id, @NotNull UUID uuid);
 
-    public abstract @NotNull Packet playOutSpawnLivingEntity(@NotNull EntityType type, @NotNull Location location, int id, @NotNull UUID uuid, float yaw, float pitch, float headRotation);
+    public abstract @NotNull
+    Packet playOutSpawnLivingEntity(@NotNull EntityType type, @NotNull Location location, int id, @NotNull UUID uuid, float yaw, float pitch, float headRotation);
 
     public abstract void send(@NotNull Packet packet, @NotNull Player... recipients) throws IllegalArgumentException;
 
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketType.java b/src/main/java/mx/kenzie/wellspring/packet/PacketType.java
index f987208f56a75a6e3bb8a15eb32323477fab297a..925c66adbc3098e331b235e806cf5cf5b4b87339 100644
--- a/src/main/java/mx/kenzie/wellspring/packet/PacketType.java
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketType.java
@@ -9,6 +9,85 @@ import java.util.Map;
 public class PacketType {
 
     private static final Map<Class<?>, PacketType> PACKET_TYPE_MAP = new HashMap<>();
+    final @NotNull
+    Class<?> packet;
+    final @NotNull
+    Packet.Direction direction;
+    final @NotNull
+    Class<?>[] fields;
+    final @NotNull
+    PacketConstructor<?> constructor;
+
+    PacketType(@NotNull Class<?> packet, @NotNull Packet.Direction direction, @NotNull PacketConstructor<?> constructor, @NotNull Class<?>... fields) {
+        this.packet = packet;
+        this.direction = direction;
+        this.fields = fields;
+        this.constructor = constructor;
+        PACKET_TYPE_MAP.put(packet, this);
+    }
+
+    public static @NotNull
+    PacketType of(@NotNull Object object) {
+        final Class<?> cls;
+        if (object instanceof PacketType) return (PacketType) object;
+        else if (object instanceof Class) cls = ((Class<?>) object);
+        else cls = object.getClass();
+        for (Map.Entry<Class<?>, PacketType> entry : PACKET_TYPE_MAP.entrySet()) {
+            if (entry.getKey().isAssignableFrom(cls)) return entry.getValue();
+        }
+        throw new IllegalArgumentException("The provided object is neither a packet nor a packet class!");
+    }
+
+    public @NotNull
+    Packet create(@NotNull Object... fields) {
+        if (fields.length < 1) return (Packet) constructor.create();
+        PacketBuilder builder = new PacketBuilder(this);
+        for (Object field : fields) {
+            builder.with(field);
+        }
+        return builder.create();
+    }
+
+    @NotNull
+    public Class<?> getPacketClass() {
+        return packet;
+    }
+
+    /**
+     * Internal use only - creates a packet using the nullary constructor.
+     * Packets made by this are essentially useless without tweaking via
+     * reflection.
+     * <p>
+     * If you are creating a new implementation for some reason,
+     * PacketClassHere::new is sufficient for the functional-interface.
+     *
+     * @return The packet constructor function.
+     */
+    @NotNull
+    @Deprecated
+    public PacketConstructor<?> getConstructor() {
+        return constructor;
+    }
+
+    public @NotNull
+    Class<?>[] getFields() {
+        return fields;
+    }
+
+    public @NotNull
+    Packet.Direction getDirection() {
+        return direction;
+    }
+
+    @Override
+    @NotNull
+    public String toString() {
+        return "PacketType{" +
+            "direction=" + direction +
+            ", fields=" + Arrays.toString(fields) +
+            ", constructor=" + constructor +
+            '}';
+    }
 
     public static class Incoming extends PacketType {
         public static PacketType LOGIN_CUSTOM_PAYLOAD;
@@ -167,75 +246,4 @@ public class PacketType {
             super(cls, direction, constructor, fields);
         }
     }
-
-    final @NotNull Class<?> packet;
-    final @NotNull Packet.Direction direction;
-    final @NotNull Class<?>[] fields;
-    final @NotNull PacketConstructor<?> constructor;
-
-    PacketType(@NotNull Class<?> packet, @NotNull Packet.Direction direction, @NotNull PacketConstructor<?> constructor, @NotNull Class<?>... fields) {
-        this.packet = packet;
-        this.direction = direction;
-        this.fields = fields;
-        this.constructor = constructor;
-        PACKET_TYPE_MAP.put(packet, this);
-    }
-
-    public @NotNull Packet create(@NotNull Object... fields) {
-        if (fields.length < 1) return (Packet) constructor.create();
-        PacketBuilder builder = new PacketBuilder(this);
-        for (Object field : fields) {
-            builder.with(field);
-        }
-        return builder.create();
-    }
-
-    @NotNull
-    public Class<?> getPacketClass() {
-        return packet;
-    }
-
-    /**
-     * Internal use only - creates a packet using the nullary constructor.
-     * Packets made by this are essentially useless without tweaking via
-     * reflection.
-     *
-     * If you are creating a new implementation for some reason,
-     * PacketClassHere::new is sufficient for the functional-interface.
-     * @return The packet constructor function.
-     */
-    @NotNull
-    @Deprecated
-    public PacketConstructor<?> getConstructor() {
-        return constructor;
-    }
-
-    public @NotNull Class<?>[] getFields() {
-        return fields;
-    }
-
-    public @NotNull Packet.Direction getDirection() {
-        return direction;
-    }
-
-    public static @NotNull PacketType of(@NotNull Object object) {
-        final Class<?> cls;
-        if (object instanceof PacketType) return (PacketType) object;
-        else if (object instanceof Class) cls = ((Class<?>) object);
-        else cls = object.getClass();
-        for (Map.Entry<Class<?>, PacketType> entry : PACKET_TYPE_MAP.entrySet()) {
-            if (entry.getKey().isAssignableFrom(cls)) return entry.getValue();
-        }
-        throw new IllegalArgumentException("The provided object is neither a packet nor a packet class!");
-    }
-
-    @Override
-    @NotNull
-    public String toString() {
-        return "PacketType{" +
-            "direction=" + direction +
-            ", fields=" + Arrays.toString(fields) +
-            ", constructor=" + constructor +
-            '}';
-    }
 }
diff --git a/src/main/java/mx/kenzie/wellspring/potion/PotionBuilder.java b/src/main/java/mx/kenzie/wellspring/potion/PotionBuilder.java
index 957f79e5a3c883288a1c600e407588d70ba25f36..5e8e63970f12d9fe51ef5db8f382427ed7a2ef32 100644
--- a/src/main/java/mx/kenzie/wellspring/potion/PotionBuilder.java
+++ b/src/main/java/mx/kenzie/wellspring/potion/PotionBuilder.java
@@ -6,7 +6,6 @@ import org.bukkit.attribute.Attribute;
 import org.bukkit.attribute.AttributeModifier;
 import org.bukkit.entity.LivingEntity;
 import org.bukkit.plugin.Plugin;
-import org.bukkit.potion.PotionEffectType;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
@@ -18,91 +17,107 @@ import java.util.function.BiConsumer;
 /**
  * Allows for the creation of custom potion effect types.
  * These can have their own colours, linked attributes and scheduled behaviour.
- *
+ * <p>
  * They will persist over restarts and log-outs as long as the plugin registers
  * the effect in the STARTUP phase, before the world is loaded.
  * This also requires a consistent effect index to be used.
- *
+ * <p>
  * To create a builder, use {@link Bukkit#createPotionEffect(NamespacedKey, String)}
  *
  * @author Moderocky
  */
 public abstract class PotionBuilder {
 
-    protected final @NotNull NamespacedKey key;
-    protected final @NotNull String name;
-    protected final @NotNull Map<Attribute, AttributeModifier> attributes = new HashMap<>();
+    protected final @NotNull
+    NamespacedKey key;
+    protected final @NotNull
+    String name;
+    protected final @NotNull
+    Map<Attribute, AttributeModifier> attributes = new HashMap<>();
 
     protected boolean instant;
 
+    protected PotionBuilder(@NotNull NamespacedKey key, @NotNull String name) {
+        this.key = key;
+        this.name = name;
+    }
+
     /**
      * Creates a new builder.
-     * @param key The key of the effect (used to prevent re-registration)
+     *
+     * @param key  The key of the effect (used to prevent re-registration)
      * @param name The name of the effect
      * @return The new builder
      */
-    public static @NotNull PotionBuilder create(@NotNull NamespacedKey key, @NotNull String name) {
+    public static @NotNull
+    PotionBuilder create(@NotNull NamespacedKey key, @NotNull String name) {
         return Bukkit.createPotionEffect(key, name);
     }
 
-    protected PotionBuilder(@NotNull NamespacedKey key, @NotNull String name) {
-        this.key = key;
-        this.name = name;
-    }
-
     /**
      * Marks the potion as "instant" (e.g. healing, harming)
+     *
      * @param instant Instant
      * @return Chain
      */
-    public @NotNull PotionBuilder setInstant(boolean instant) {
+    public @NotNull
+    PotionBuilder setInstant(boolean instant) {
         this.instant = instant;
         return this;
     }
 
     /**
      * Sets the colour of the potion bubble particles
+     *
      * @param color The colour of the particles
      * @return Chain
      */
-    public abstract @NotNull PotionBuilder setColor(@NotNull Color color);
+    public abstract @NotNull
+    PotionBuilder setColor(@NotNull Color color);
 
     /**
      * Sets the type of the potion, for filtering
+     *
      * @param type The type
      * @return Chain
      */
-    public abstract @NotNull PotionBuilder setType(@NotNull PotionType type);
+    public abstract @NotNull
+    PotionBuilder setType(@NotNull PotionType type);
 
     /**
      * Sets an action to be run when the potion ticks.
      * Note - this will be run VERY frequently, so can cause lag.
+     *
      * @param consumer The action to run
      * @return Chain
      */
-    public abstract @NotNull PotionBuilder setTickConsumer(@Nullable BiConsumer<LivingEntity, Integer> consumer);
+    public abstract @NotNull
+    PotionBuilder setTickConsumer(@Nullable BiConsumer<LivingEntity, Integer> consumer);
 
     /**
      * Adds an attribute to the potion. The attribute will be applied to the target so long
      * as they have the effect.
      * The attribute modifier's value will be affected by the potion level.
+     *
      * @param attribute The attribute
-     * @param modifier The modifier
+     * @param modifier  The modifier
      * @return Chain
      */
-    public @NotNull PotionBuilder addAttribute(@NotNull Attribute attribute, @NotNull AttributeModifier modifier) {
+    public @NotNull
+    PotionBuilder addAttribute(@NotNull Attribute attribute, @NotNull AttributeModifier modifier) {
         attributes.put(attribute, modifier);
         return this;
     }
 
-    public @NotNull PotionBuilder removeAttribute(@NotNull Attribute attribute) {
+    public @NotNull
+    PotionBuilder removeAttribute(@NotNull Attribute attribute) {
         attributes.remove(attribute);
         return this;
     }
 
     /**
      * Registers the potion and attaches it to this plugin.
-     *
+     * <p>
      * NOTE - the hashed namespaced key will be used as the index.
      *
      * @param plugin The plugin to register it with.
@@ -111,18 +126,18 @@ public abstract class PotionBuilder {
 
     /**
      * Registers the potion and attaches it to this plugin.
-     *
+     * <p>
      * NOTE - indices are used to store the potion effect.
      * Duplicates will override, please be careful.
-     *
+     * <p>
      * Numerical storage blocks are generated using the hashed
      * plugin name. This means that changing your plugin's name
      * will cause existing effects not to load.
      *
      * @param plugin The plugin to register it with.
-     * @param index The index (used for saving/loading) - this should be from 1 to N
-     *              and is based on the plugin's name to avoid conflicts.
-     *              Large numbers are not advised.
+     * @param index  The index (used for saving/loading) - this should be from 1 to N
+     *               and is based on the plugin's name to avoid conflicts.
+     *               Large numbers are not advised.
      */
     public abstract void register(@NotNull Plugin plugin, int index);
 
