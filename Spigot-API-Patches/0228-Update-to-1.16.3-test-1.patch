From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Moderocky <admin@moderocky.com>
Date: Mon, 21 Sep 2020 10:23:10 +0100
Subject: [PATCH] Update to 1.16.3 test 1


diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBT.java b/src/main/java/mx/kenzie/wellspring/nbt/NBT.java
new file mode 100644
index 0000000000000000000000000000000000000000..7d90134bade5e5734f62311afcefbf4fddbf35c1
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBT.java
@@ -0,0 +1,131 @@
+package mx.kenzie.wellspring.nbt;
+
+import net.md_5.bungee.api.chat.BaseComponent;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * This represents an NBT 'base' object, which could be either a map-compound,
+ * a list of bases, or a simple wrapped value.
+ *
+ * In order to determine which, {@link NBT#getType()} can be used.
+ */
+public interface NBT {
+
+    /**
+     * Convert an object to an NBT base.
+     * This works with primitives, strings, some numerical arrays and objects that
+     * are already NBT types.
+     *
+     * @param object An object of a valid type.
+     * @param type The type of the object, for conversion.
+     * @return The converted NBT base.
+     * @throws IllegalArgumentException If the type was invalid or the object could not be converted.
+     */
+    @SuppressWarnings("deprecation")
+    static @NotNull NBT convert(@NotNull Object object, @NotNull Type type) throws IllegalArgumentException {
+        return Bukkit.getNBTFactory().newBase(object, type);
+    }
+
+    /**
+     * This is a utility for converting objects without knowing their type.
+     * This works with primitives, strings, some numerical arrays and objects that
+     * are already NBT types.
+     *
+     * It will not convert objects of invalid types!
+     * @param object An object of a valid type.
+     * @return The converted NBT base.
+     * @throws IllegalArgumentException If the type was invalid or the object could not be converted.
+     */
+    static @NotNull NBT convert(@NotNull Object object) throws IllegalArgumentException {
+        if (object instanceof NBT) return (NBT) object;
+        if (object instanceof Boolean) return convert(object, Type.BOOLEAN);
+        if (object instanceof Byte) return convert(object, Type.BYTE);
+        if (object instanceof Short) return convert(object, Type.SHORT);
+        if (object instanceof Integer) return convert(object, Type.INT);
+        if (object instanceof Long) return convert(object, Type.LONG);
+        if (object instanceof Float) return convert(object, Type.FLOAT);
+        if (object instanceof Double) return convert(object, Type.DOUBLE);
+        if (object instanceof byte[]) return convert(object, Type.BYTE_ARRAY);
+        if (object instanceof int[]) return convert(object, Type.INT_ARRAY);
+        if (object instanceof long[]) return convert(object, Type.LONG_ARRAY);
+        if (object instanceof String) return convert(object, Type.STRING);
+        throw new IllegalArgumentException("Unsupported type for conversion: " + object.getClass());
+    }
+
+    /**
+     * Magic value.
+     * @return The raw numerical type.
+     */
+    @Deprecated
+    byte getTypeId();
+
+    default boolean isOfType(@NotNull Type type) {
+        return getType() == type;
+    }
+
+    default @NotNull Type getType() {
+        return Type.fromId(getTypeId());
+    }
+
+    public @NotNull NBT clone();
+
+    default @NotNull BaseComponent[] display() {
+        return display(0, "");
+    }
+
+    @NotNull
+    BaseComponent[] display(int indentation, @NotNull String unit);
+
+    enum Type {
+        /**
+         * Marked for internal type-comparison use.
+         * Very unsafe - used to mark termination of the data.
+         */
+        @Deprecated
+        NULL_TERMINATOR(0, void.class),
+        BYTE(1, byte.class),
+        SHORT(2, short.class),
+        INT(3, int.class),
+        LONG(4, long.class),
+        FLOAT(5, float.class),
+        DOUBLE(6, double.class),
+        BYTE_ARRAY(7, byte[].class),
+        STRING(8, String.class),
+        LIST(9, NBTList.class),
+        COMPOUND(10, NBTCompound.class),
+        INT_ARRAY(11, int[].class),
+        LONG_ARRAY(12, long[].class),
+        BOOLEAN(1, boolean.class),
+        /**
+         * Used internally to signify any primitive type.
+         */
+        PRIMITIVE_TYPE(99, Object.class);
+
+        final int raw;
+        final @NotNull Class<?> cls;
+
+        Type(int raw, @NotNull Class<?> cls) {
+            this.raw = raw;
+            this.cls = cls;
+        }
+
+        public int getRawId() {
+            return raw;
+        }
+
+        @NotNull
+        public Class<?> getEntryClass() {
+            return cls;
+        }
+
+        public static @NotNull
+        Type fromId(int raw) {
+            for (Type type : values()) {
+                if (type.raw == raw) return type;
+            }
+            throw new IllegalArgumentException("Unknown type passed to converter.");
+        }
+    }
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBTCompound.java b/src/main/java/mx/kenzie/wellspring/nbt/NBTCompound.java
new file mode 100644
index 0000000000000000000000000000000000000000..4c127e2332afdd01d6b56113246e0ad04227cb30
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBTCompound.java
@@ -0,0 +1,153 @@
+package mx.kenzie.wellspring.nbt;
+
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.Map;
+import java.util.UUID;
+
+/**
+ * This represents an NBT 'compound,' which is a (String) key -> (NBT base) value map.
+ */
+public interface NBTCompound extends NBT {
+
+    static @NotNull NBTCompound create() {
+        return Bukkit.getNBTFactory().newCompound();
+    }
+
+    int size();
+
+    boolean isEmpty();
+
+    boolean containsKey(@NotNull String key);
+
+    default boolean containsKey(@NotNull String key, @NotNull Type type) {
+        return containsKey(key, type.raw);
+    }
+
+    @NotNull
+    @Override
+    default Type getType() {
+        return Type.COMPOUND;
+    }
+
+    /**
+     * Potentially version-dependent - easier to use {@link NBTCompound#containsKey(String, Type)}
+     * @param key The string key.
+     * @param rawType The NBT base type.
+     * @return Whether key is present.
+     */
+    @Deprecated
+    boolean containsKey(@NotNull String key, int rawType);
+
+    void setBoolean(@NotNull String key, boolean value);
+
+    void setByte(@NotNull String key, byte value);
+
+    void setShort(@NotNull String key, short value);
+
+    void setInt(@NotNull String key, int value);
+
+    void setLong(@NotNull String key, long value);
+
+    void setFloat(@NotNull String key, float value);
+
+    void setDouble(@NotNull String key, double value);
+
+    void setString(@NotNull String key, @Nullable String value);
+
+    void setUUID(@NotNull String keyPrefix, @Nullable UUID uuid);
+
+    void setByteArray(@NotNull String key, @Nullable byte[] bytes);
+
+    void setIntArray(@NotNull String key, @Nullable int[] ints);
+
+    void setLongArray(@NotNull String key, @Nullable long[] longs);
+
+    void setList(@NotNull String key, @Nullable NBTList list);
+
+    boolean getBoolean(@NotNull String key);
+
+    byte getByte(@NotNull String key);
+
+    short getShort(@NotNull String key);
+
+    int getInt(@NotNull String key);
+
+    long getLong(@NotNull String key);
+
+    float getFloat(@NotNull String key);
+
+    double getDouble(@NotNull String key);
+
+    @Nullable byte[] getByteArray(@NotNull String key);
+
+    @Nullable int[] getIntArray(@NotNull String key);
+
+    @Nullable long[] getLongArray(@NotNull String key);
+
+    @Nullable String getString(@NotNull String key);
+
+    @Nullable NBTCompound getCompound(@NotNull String key);
+
+    @Nullable NBTList getList(@NotNull String key);
+
+    @Nullable NBT get(@NotNull String key);
+
+    void remove(@NotNull String key);
+
+    @NotNull NBTCompound clone();
+
+    /**
+     * Merges the second compound into this. Entries from the new compound will override and replace this.
+     * @param compound The compound to merge.
+     * @return This compound.
+     */
+    @NotNull NBTCompound merge(@NotNull NBTCompound compound);
+
+    /**
+     * @return A clone of this NBT compound as a map of keys/NBT bases.
+     */
+    @NotNull Map<String, NBT> getAsMap();
+
+    @SuppressWarnings({"unchecked", "deprecation"})
+    default @Nullable <T> T get(@NotNull String key, @NotNull Type type) {
+        switch (type) {
+            case NULL_TERMINATOR:
+            case PRIMITIVE_TYPE:
+                throw new IllegalArgumentException("The type " + type + " cannot be used here.");
+            case BYTE:
+                return (T) type.cls.cast(getByte(key));
+            case INT:
+                return (T) type.cls.cast(getInt(key));
+            case SHORT:
+                return (T) type.cls.cast(getShort(key));
+            case LONG:
+                return (T) type.cls.cast(getLong(key));
+            case FLOAT:
+                return (T) type.cls.cast(getFloat(key));
+            case DOUBLE:
+                return (T) type.cls.cast(getDouble(key));
+            case BYTE_ARRAY:
+                return (T) type.cls.cast(getByteArray(key));
+            case INT_ARRAY:
+                return (T) type.cls.cast(getIntArray(key));
+            case LONG_ARRAY:
+                return (T) type.cls.cast(getLongArray(key));
+            case STRING:
+                return (T) type.cls.cast(getString(key));
+            case LIST:
+                return (T) type.cls.cast(getList(key));
+            case COMPOUND:
+                return (T) type.cls.cast(getCompound(key));
+        }
+        return null;
+    }
+
+    @Nullable
+    UUID getUUID(@NotNull String keyPrefix);
+
+    boolean hasUUID(@NotNull String keyPrefix);
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBTFactory.java b/src/main/java/mx/kenzie/wellspring/nbt/NBTFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..d4b2ad5c5a98db95819b08e1d73b045d0e2566c1
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBTFactory.java
@@ -0,0 +1,63 @@
+package mx.kenzie.wellspring.nbt;
+
+import org.bukkit.entity.Entity;
+import org.bukkit.inventory.ItemStack;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * The NBT factory is provided by the server as a means of managing NBT implementations.
+ *
+ * Generally speaking, it should not be used as most of the functions can be
+ * employed via their respective classes.
+ */
+public abstract class NBTFactory {
+
+    public NBTFactory() {
+    }
+
+    /**
+     * Allows for the conversion of a stringified NBT compound to an NBT compound.
+     * This should generally NOT be used, except for the purposes of NBT storage.
+     *
+     * This is NOT an excuse to write out NBT manually! Please use the map system instead.
+     *
+     * @param string The stringified NBT.
+     * @return The compound.
+     * @throws IllegalArgumentException If the string is invalid, malformed or otherwise
+     * un-parsable.
+     */
+    public abstract @NotNull NBTCompound parse(@NotNull String string) throws IllegalArgumentException;
+
+    /**
+     * Produces a new NBT compound.
+     * @return A new empty compound.
+     */
+    public abstract @NotNull NBTCompound newCompound();
+
+    /**
+     * Produces a new NBT list.
+     * @return A new empty list.
+     */
+    public abstract @NotNull NBTList newList();
+
+    /**
+     * For internal use only - potentially unsafe!
+     * @param object The object to convert. MUST be a valid {@link NBT.Type}!
+     * @param type The base type.
+     * @return The converted base.
+     * @throws IllegalArgumentException If the type cannot be wrapped as an NBT base.
+     */
+    @Deprecated
+    public abstract @NotNull NBT newBase(@NotNull Object object, @NotNull NBT.Type type) throws IllegalArgumentException;
+
+    public @NotNull NBTCompound getNBT(@NotNull NBTHolder holder) {
+        return holder.getNBT();
+    }
+
+    public abstract @NotNull NBTCompound getNBT(@NotNull Entity entity);
+
+    public abstract @NotNull NBTCompound getNBT(@NotNull ItemStack itemStack);
+
+    public abstract @NotNull NBTCompound getTagCompound(@NotNull ItemStack itemStack);
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBTHolder.java b/src/main/java/mx/kenzie/wellspring/nbt/NBTHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..6879c4edf4547a2bce61eaf7d228fe717b7b427c
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBTHolder.java
@@ -0,0 +1,66 @@
+package mx.kenzie.wellspring.nbt;
+
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An object that holds (or is stored as) data in the NBT (Named Binary Tag) format.
+ * This includes entities, items, world events and potentially structures.
+ *
+ * Not all NBT-holders are currently implemented.
+ *
+ * This is generally an unsafe class to mess with! Please refrain especially from
+ * merging or loading new compounds unless you know what you are doing - it may
+ * lead to data corruption or unexpected consequences.
+ *
+ * NBT access is potentially SLOWER than using the direct methods! It should not be
+ * treated as an alternative to the existing entity/item API.
+ */
+public interface NBTHolder {
+
+    /**
+     * Retrieves the current NBT tag compound of the object.
+     * Please note that this internally triggers the saving method, which serialises
+     * all of the holder's persistent data - not something that ought to be done
+     * frequently.
+     *
+     * It will also trigger any attachment accessors.
+     *
+     * @return A clone of the holder's stored data as an NBT compound.
+     */
+    @NotNull NBTCompound getNBT();
+
+    /**
+     * This will merge the provided compound with the holder's existing data.
+     * Values from the new compound will OVERWRITE existing values.
+     *
+     * This is preferable to {@link NBTHolder#loadNBT(NBTCompound)} as it has less chance
+     * of breaking anything important due to missing values.
+     *
+     * Note that this internally reloads the holder's data, as if from file.
+     * It will also trigger any attachment accessors. As such, it should not be
+     * done too frequently as it can cause unnecessary delays.
+     *
+     * @param compound The new NBT compound to merge.
+     */
+    default void mergeNBT(@NotNull NBTCompound compound) {
+        NBTCompound original = getNBT();
+        loadNBT(original.merge(compound));
+    }
+
+    /**
+     * This will replace the holder's existing data with the provided compound.
+     * This is potentially UNSAFE! Please refrain from using this unless you know
+     * what you are doing.
+     *
+     * {@link NBTHolder#mergeNBT(NBTCompound)} is preferable as it has less chance
+     * of breaking anything important.
+     *
+     * Note that this internally reloads the holder's data, as if from file.
+     * It will also trigger any attachment accessors. As such, it should not be
+     * done too frequently as it can cause unnecessary delays.
+     *
+     * @param compound The new NBT compound to replace the original with.
+     */
+    void loadNBT(@NotNull NBTCompound compound);
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/nbt/NBTList.java b/src/main/java/mx/kenzie/wellspring/nbt/NBTList.java
new file mode 100644
index 0000000000000000000000000000000000000000..cf0ff09019c802a36b67fc83827d6f52a5ce2127
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/nbt/NBTList.java
@@ -0,0 +1,72 @@
+package mx.kenzie.wellspring.nbt;
+
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.*;
+
+/**
+ * A list of NBT bases. This includes compounds or primitive types.
+ *
+ * This is (internally) a {@link Collection} but cannot be typed as such.
+ * You may safely use {@link NBTList#getAsArray()} or {@link NBTList#getAsList()} for iteration.
+ */
+public interface NBTList extends NBT {
+
+    /**
+     * @return A new NBT list.
+     */
+    static @NotNull NBTList create() {
+        return Bukkit.getNBTFactory().newList();
+    }
+
+    int size();
+
+    boolean isEmpty();
+
+    void clear();
+
+    @NotNull
+    @Override
+    default Type getType() {
+        return Type.LIST;
+    }
+
+    /**
+     * Adds a new NBT entry.
+     * @param entry The entry to add.
+     */
+    void add(@NotNull NBT entry);
+
+    /**
+     * Removes the specified entry.
+     * @param entry The entry to remove.
+     */
+    void remove(@NotNull NBT entry);
+
+    /**
+     * Produces a collection of this list's entries.
+     * The collection is NOT backed by the original list, but the
+     * NBT bases in the list are the originals.
+     *
+     * It is safe to remove elements of this from the original list
+     * during iteration, as it is a copy.
+     *
+     * @return A new fixed-length collection.
+     */
+    @NotNull Collection<NBT> getAsList();
+
+    /**
+     * @return An array of this list's entries.
+     */
+    @NotNull NBT[] getAsArray();
+
+    @NotNull Iterator<NBT> getIterator();
+
+    @NotNull NBT remove(int index) throws IndexOutOfBoundsException;
+
+    @NotNull NBT get(int index) throws IndexOutOfBoundsException;
+
+    @NotNull NBTList clone();
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/packet/Packet.java b/src/main/java/mx/kenzie/wellspring/packet/Packet.java
new file mode 100644
index 0000000000000000000000000000000000000000..e07599951e53daa83ca036647fb62623ed161132
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/packet/Packet.java
@@ -0,0 +1,28 @@
+package mx.kenzie.wellspring.packet;
+
+import org.bukkit.Bukkit;
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+public interface Packet {
+
+    @NotNull
+    default Direction getDirection() {
+        return getType().direction;
+    }
+
+    @NotNull
+    default PacketType getType() {
+        return PacketType.of(this);
+    }
+
+    default void send(@NotNull Player... recipients) {
+        Bukkit.getPacketFactory().send(this, recipients);
+    }
+
+    enum Direction {
+        INCOMING,
+        OUTGOING;
+    }
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketBuilder.java b/src/main/java/mx/kenzie/wellspring/packet/PacketBuilder.java
new file mode 100644
index 0000000000000000000000000000000000000000..522f6e56484eb01513c28947b3ecb9a3fe538276
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketBuilder.java
@@ -0,0 +1,29 @@
+package mx.kenzie.wellspring.packet;
+
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.ArrayList;
+import java.util.List;
+
+public class PacketBuilder {
+
+    private final @NotNull PacketType type;
+    private final @NotNull List<Object> list;
+
+    public PacketBuilder(@NotNull PacketType type) {
+        this.type = type;
+        this.list = new ArrayList<>();
+    }
+
+    public @NotNull PacketBuilder with(@Nullable Object object) {
+        list.add(object);
+        return this;
+    }
+
+    public @NotNull Packet create() {
+        return Bukkit.getPacketFactory().createFrom(type, list.toArray(new Object[0]));
+    }
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketConstructor.java b/src/main/java/mx/kenzie/wellspring/packet/PacketConstructor.java
new file mode 100644
index 0000000000000000000000000000000000000000..4288f24793983426fb098d4cd49aa7bcd949af1e
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketConstructor.java
@@ -0,0 +1,10 @@
+package mx.kenzie.wellspring.packet;
+
+import org.jetbrains.annotations.NotNull;
+
+@FunctionalInterface
+public interface PacketConstructor<T> {
+
+    @NotNull T create();
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketFactory.java b/src/main/java/mx/kenzie/wellspring/packet/PacketFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..375d82b6c73905c73aa88ea349ed8262b5895f4a
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketFactory.java
@@ -0,0 +1,12 @@
+package mx.kenzie.wellspring.packet;
+
+import org.bukkit.entity.Player;
+import org.jetbrains.annotations.NotNull;
+
+public abstract class PacketFactory {
+
+    public abstract @NotNull Packet createFrom(@NotNull PacketType type, @NotNull Object... fieldInputs);
+
+    public abstract void send(@NotNull Packet packet, @NotNull Player... recipients) throws IllegalArgumentException;
+
+}
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketListener.java b/src/main/java/mx/kenzie/wellspring/packet/PacketListener.java
new file mode 100644
index 0000000000000000000000000000000000000000..cd00523be6423fc67225a2ca031e9c6c843ec576
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketListener.java
@@ -0,0 +1,4 @@
+package mx.kenzie.wellspring.packet;
+
+public interface PacketListener {
+}
diff --git a/src/main/java/mx/kenzie/wellspring/packet/PacketType.java b/src/main/java/mx/kenzie/wellspring/packet/PacketType.java
new file mode 100644
index 0000000000000000000000000000000000000000..f987208f56a75a6e3bb8a15eb32323477fab297a
--- /dev/null
+++ b/src/main/java/mx/kenzie/wellspring/packet/PacketType.java
@@ -0,0 +1,241 @@
+package mx.kenzie.wellspring.packet;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.Map;
+
+public class PacketType {
+
+    private static final Map<Class<?>, PacketType> PACKET_TYPE_MAP = new HashMap<>();
+
+    public static class Incoming extends PacketType {
+        public static PacketType LOGIN_CUSTOM_PAYLOAD;
+        public static PacketType ABILITIES;
+        public static PacketType ADVANCEMENTS;
+        public static PacketType ARM_ANIMATION;
+        public static PacketType AUTO_RECIPE;
+        public static PacketType BEACON;
+        public static PacketType BOOK_EDIT;
+        public static PacketType BLOCK_DIG;
+        public static PacketType BLOCK_PLACE;
+        public static PacketType BOAT_MOVE;
+        public static PacketType CHAT;
+        public static PacketType CLIENT_COMMAND;
+        public static PacketType CLOSE_WINDOW;
+        public static PacketType CUSTOM_PAYLOAD;
+        public static PacketType DIFFICULTY_CHANGE;
+        public static PacketType DIFFICULTY_LOCK;
+        public static PacketType ENCHANT_ITEM;
+        public static PacketType ENTITY_ACTION;
+        public static PacketType ENTITY_NBT_QUERY;
+        public static PacketType FLYING;
+        public static PacketType HELD_ITEM_SLOT;
+        public static PacketType ITEM_NAME;
+        public static PacketType JIGSAW_GENERATE;
+        public static PacketType KEEP_ALIVE;
+        public static PacketType PICK_ITEM;
+        public static PacketType RECIPE_DISPLAYED;
+        public static PacketType RESOURCE_PACK_STATUS;
+        public static PacketType SET_COMMAND_BLOCK;
+        public static PacketType SET_COMMAND_MINECART;
+        public static PacketType SET_CREATIVE_SLOT;
+        public static PacketType SET_JIGSAW;
+        public static PacketType SETTINGS;
+        public static PacketType SPECTATE;
+        public static PacketType STEER_VEHICLE;
+        public static PacketType STRUCTURE;
+        public static PacketType TAB_COMPLETE;
+        public static PacketType TELEPORT_ACCEPT;
+        public static PacketType TILE_NBT_QUERY;
+        public static PacketType TRANSACTION;
+        public static PacketType TRADE_SELECT;
+        public static PacketType UPDATE_SIGN;
+        public static PacketType USE_ENTITY;
+        public static PacketType USE_ITEM;
+        public static PacketType VEHICLE_MOVE;
+        public static PacketType WINDOW_CLICK;
+
+        public Incoming(@NotNull Class<?> cls, @NotNull PacketConstructor<?> constructor, @NotNull Class<?>... fields) {
+            this(cls, Packet.Direction.INCOMING, constructor, fields);
+        }
+
+        Incoming(@NotNull Class<?> cls, @NotNull Packet.Direction direction, @NotNull PacketConstructor<?> constructor, @NotNull Class<?>... fields) {
+            super(cls, direction, constructor, fields);
+        }
+    }
+
+    public static class Outgoing extends PacketType {
+        public static PacketType LOGIN_CUSTOM_PAYLOAD;
+        public static PacketType ABILITIES;
+        public static PacketType ADVANCEMENTS;
+        public static PacketType ANIMATION;
+        public static PacketType ATTACH_ENTITY;
+        public static PacketType AUTO_RECIPE;
+        public static PacketType BLOCK_ACTION;
+        public static PacketType BLOCK_BREAK;
+        public static PacketType BLOCK_BREAK_ANIMATION;
+        public static PacketType BLOCK_CHANGE;
+        public static PacketType BOSS;
+        public static PacketType CAMERA;
+        public static PacketType CHAT;
+        public static PacketType CLOSE_WINDOW;
+        public static PacketType COLLECT;
+        public static PacketType COMBAT_EVENT;
+        public static PacketType COMMANDS;
+        public static PacketType CUSTOM_PAYLOAD;
+        public static PacketType CUSTOM_SOUND_EFFECT;
+        public static PacketType ENTITY;
+        public static PacketType ENTITY_DESTROY;
+        public static PacketType ENTITY_EFFECT;
+        public static PacketType ENTITY_EQUIPMENT;
+        public static PacketType ENTITY_HEAD_ROTATION;
+        public static PacketType ENTITY_METADATA;
+        public static PacketType ENTITY_SOUND;
+        public static PacketType ENTITY_STATUS;
+        public static PacketType ENTITY_TELEPORT;
+        public static PacketType ENTITY_VELOCITY;
+        public static PacketType ENTITY_LOOK;
+        public static PacketType EXPERIENCE;
+        public static PacketType EXPLOSION;
+        public static PacketType GAME_STATE_CHANGE;
+        public static PacketType HELD_ITEM_SLOT;
+        public static PacketType KEEP_ALIVE;
+        public static PacketType KICK_DISCONNECT;
+        public static PacketType LIGHT_UPDATE;
+        public static PacketType LOGIN;
+        public static PacketType LOOK_AT;
+        public static PacketType MAP;
+        public static PacketType MAP_CHUNK;
+        public static PacketType MOUNT;
+        public static PacketType MULTI_BLOCK_CHANGE;
+        public static PacketType NAMED_ENTITY_SPAWN;
+        public static PacketType NAMED_SOUND_EFFECT;
+        public static PacketType NBT_QUERY;
+        public static PacketType OPEN_BOOK;
+        public static PacketType OPEN_SIGN_EDITOR;
+        public static PacketType OPEN_WINDOW;
+        public static PacketType OPEN_WINDOW_HORSE;
+        public static PacketType OPEN_WINDOW_MERCHANT;
+        public static PacketType PLAYER_INFO;
+        public static PacketType PLAYER_LIST_HEADER_FOOTER;
+        public static PacketType POSITION;
+        public static PacketType RECIPES;
+        public static PacketType RECIPE_UPDATE;
+        public static PacketType REMOVE_ENTITY_EFFECT;
+        public static PacketType RESOURCE_PACK;
+        public static PacketType RESPAWN;
+        public static PacketType SCOREBOARD_DISPLAY_OBJECTIVE;
+        public static PacketType SCOREBOARD_OBJECTIVE;
+        public static PacketType SCOREBOARD_SCORE;
+        public static PacketType SCOREBOARD_TEAM;
+        public static PacketType SELECT_ADVANCEMENT_TAV;
+        public static PacketType SERVER_DIFFICULTY;
+        public static PacketType SET_COOLDOWN;
+        public static PacketType SET_SLOT;
+        public static PacketType SPAWN_ENTITY;
+        public static PacketType SPAWN_EXPERIENCE;
+        public static PacketType SPAWN_LIVING_ENTITY;
+        public static PacketType SPAWN_PAINTING;
+        public static PacketType SPAWN_POSITION;
+        public static PacketType STATISTIC;
+        public static PacketType STOP_SOUND;
+        public static PacketType TAB_COMPLETE;
+        public static PacketType TAGS;
+        public static PacketType TILE_ENTITY_DATA;
+        public static PacketType TITLE;
+        public static PacketType TRANSACTION;
+        public static PacketType UNLOAD_CHUNK;
+        public static PacketType UPDATE_ATTRIBUTES;
+        public static PacketType UPDATE_HEALTH;
+        public static PacketType UPDATE_TIME;
+        public static PacketType VEHICLE_MOVE;
+        public static PacketType VIEW_CENTRE;
+        public static PacketType VIEW_DISTANCE;
+        public static PacketType WINDOW_DATA;
+        public static PacketType WINDOW_ITEMS;
+        public static PacketType WORLD_BORDER;
+        public static PacketType WORLD_EVENT;
+        public static PacketType WORLD_PARTICLES;
+
+        public Outgoing(@NotNull Class<?> cls, @NotNull PacketConstructor<?> constructor, @NotNull Class<?>... fields) {
+            this(cls, Packet.Direction.OUTGOING, constructor, fields);
+        }
+
+        Outgoing(@NotNull Class<?> cls, @NotNull Packet.Direction direction, @NotNull PacketConstructor<?> constructor, @NotNull Class<?>... fields) {
+            super(cls, direction, constructor, fields);
+        }
+    }
+
+    final @NotNull Class<?> packet;
+    final @NotNull Packet.Direction direction;
+    final @NotNull Class<?>[] fields;
+    final @NotNull PacketConstructor<?> constructor;
+
+    PacketType(@NotNull Class<?> packet, @NotNull Packet.Direction direction, @NotNull PacketConstructor<?> constructor, @NotNull Class<?>... fields) {
+        this.packet = packet;
+        this.direction = direction;
+        this.fields = fields;
+        this.constructor = constructor;
+        PACKET_TYPE_MAP.put(packet, this);
+    }
+
+    public @NotNull Packet create(@NotNull Object... fields) {
+        if (fields.length < 1) return (Packet) constructor.create();
+        PacketBuilder builder = new PacketBuilder(this);
+        for (Object field : fields) {
+            builder.with(field);
+        }
+        return builder.create();
+    }
+
+    @NotNull
+    public Class<?> getPacketClass() {
+        return packet;
+    }
+
+    /**
+     * Internal use only - creates a packet using the nullary constructor.
+     * Packets made by this are essentially useless without tweaking via
+     * reflection.
+     *
+     * If you are creating a new implementation for some reason,
+     * PacketClassHere::new is sufficient for the functional-interface.
+     * @return The packet constructor function.
+     */
+    @NotNull
+    @Deprecated
+    public PacketConstructor<?> getConstructor() {
+        return constructor;
+    }
+
+    public @NotNull Class<?>[] getFields() {
+        return fields;
+    }
+
+    public @NotNull Packet.Direction getDirection() {
+        return direction;
+    }
+
+    public static @NotNull PacketType of(@NotNull Object object) {
+        final Class<?> cls;
+        if (object instanceof PacketType) return (PacketType) object;
+        else if (object instanceof Class) cls = ((Class<?>) object);
+        else cls = object.getClass();
+        for (Map.Entry<Class<?>, PacketType> entry : PACKET_TYPE_MAP.entrySet()) {
+            if (entry.getKey().isAssignableFrom(cls)) return entry.getValue();
+        }
+        throw new IllegalArgumentException("The provided object is neither a packet nor a packet class!");
+    }
+
+    @Override
+    @NotNull
+    public String toString() {
+        return "PacketType{" +
+            "direction=" + direction +
+            ", fields=" + Arrays.toString(fields) +
+            ", constructor=" + constructor +
+            '}';
+    }
+}
diff --git a/src/main/java/org/bukkit/Bukkit.java b/src/main/java/org/bukkit/Bukkit.java
index bfe842364ee0a4bf39dacdbb6972477d57a4ef8a..533f24fdf57d7eea0142988f6576be1746ee1228 100644
--- a/src/main/java/org/bukkit/Bukkit.java
+++ b/src/main/java/org/bukkit/Bukkit.java
@@ -12,9 +12,15 @@ import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
 import java.util.function.Consumer;
+import java.util.function.Function;
 import java.util.logging.Logger;
+
+import mx.kenzie.wellspring.nbt.NBTFactory;
+import mx.kenzie.wellspring.packet.PacketFactory;
 import org.bukkit.Warning.WarningState;
 import org.bukkit.advancement.Advancement;
+import org.bukkit.attachment.Attachable;
+import org.bukkit.attachment.Attachment;
 import org.bukkit.block.data.BlockData;
 import org.bukkit.boss.BarColor;
 import org.bukkit.boss.BarFlag;
@@ -26,6 +32,7 @@ import org.bukkit.command.CommandSender;
 import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.command.PluginCommand;
 import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.server.ServerListPingEvent;
@@ -41,6 +48,7 @@ import org.bukkit.inventory.meta.ItemMeta;
 import org.bukkit.loot.LootTable;
 import org.bukkit.map.MapView;
 import org.bukkit.permissions.Permissible;
+import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.PluginManager;
 import org.bukkit.plugin.ServicesManager;
 import org.bukkit.plugin.messaging.Messenger;
@@ -1725,6 +1733,65 @@ public final class Bukkit {
         return server.getPermissionMessage();
     }
 
+    // Kenzie start - attachments
+
+    /**
+     * Allows the registration of an attachment for specific entity types.
+     * The corresponding entity types will receive a new instance of the attachment
+     * (as per the creator function) upon their creation.
+     *
+     * Attachments ought to be final, due to the need to match their class when
+     * retrieving the attachment instance from the object.
+     * @param plugin The providing plugin.
+     * @param creatorFunction A function to create a new attachment instance.
+     * @param types The entity types this attachment should be registered for.
+     */
+    public static void registerAttachment(@NotNull Plugin plugin, @NotNull Function<Entity, Attachment<?>> creatorFunction, @NotNull EntityType... types) {
+        server.registerAttachment(plugin, creatorFunction, types);
+    }
+
+    /**
+     * Allows the registration of an attachment for specific entity types.
+     * The corresponding entity types will receive a new instance of the attachment
+     * (as per the creator function) upon their creation.
+     *
+     * Attachments ought to be final, due to the need to match their class when
+     * retrieving the attachment instance from the object.
+     * @param plugin The providing plugin.
+     * @param creatorFunction A function to create a new attachment instance.
+     * @param target The target class.
+     */
+    public static <T extends Attachable> void registerAttachment(@NotNull Plugin plugin, @NotNull Function<? extends T, Attachment<?>> creatorFunction, @NotNull Class<T> target) {
+        server.registerAttachment(plugin, creatorFunction, target);
+    }
+
+    /**
+     * Unregisters the attachments provided by a plugin.
+     * @param plugin The providing plugin.
+     */
+    public static void unregisterAttachments(@NotNull Plugin plugin) {
+        server.unregisterAttachments(plugin);
+    }
+
+    // Kenzie end - attachments
+
+    // Kenzie start - Factories
+    /**
+     * Retrieves the server's NBT factory, used for instantiating compound tags,
+     * NBT lists and other version-dependent types.
+     * @return The factory instance.
+     */
+    public static @NotNull
+    NBTFactory getNBTFactory() {
+        return server.getNBTFactory();
+    }
+
+    public static @NotNull
+    PacketFactory getPacketFactory() {
+        return server.getPacketFactory();
+    }
+    // Kenzie end
+
     /**
      * Creates a PlayerProfile for the specified uuid, with name as null
      * @param uuid UUID to create profile for
diff --git a/src/main/java/org/bukkit/Server.java b/src/main/java/org/bukkit/Server.java
index 7c0a788900c93c29d14d8c45ac5ae3317cf4a94e..0ccb35fe4e6e9050768ce5a27d63653b20621772 100644
--- a/src/main/java/org/bukkit/Server.java
+++ b/src/main/java/org/bukkit/Server.java
@@ -12,9 +12,15 @@ import java.util.Map;
 import java.util.Set;
 import java.util.UUID;
 import java.util.function.Consumer;
+import java.util.function.Function;
 import java.util.logging.Logger;
+
+import mx.kenzie.wellspring.nbt.NBTFactory;
+import mx.kenzie.wellspring.packet.PacketFactory;
 import org.bukkit.Warning.WarningState;
 import org.bukkit.advancement.Advancement;
+import org.bukkit.attachment.Attachable;
+import org.bukkit.attachment.Attachment;
 import org.bukkit.block.data.BlockData;
 import org.bukkit.boss.BarColor;
 import org.bukkit.boss.BarFlag;
@@ -26,6 +32,7 @@ import org.bukkit.command.CommandSender;
 import org.bukkit.command.ConsoleCommandSender;
 import org.bukkit.command.PluginCommand;
 import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.event.inventory.InventoryType;
 import org.bukkit.event.server.ServerListPingEvent;
@@ -41,6 +48,7 @@ import org.bukkit.inventory.meta.ItemMeta;
 import org.bukkit.loot.LootTable;
 import org.bukkit.map.MapView;
 import org.bukkit.permissions.Permissible;
+import org.bukkit.plugin.Plugin;
 import org.bukkit.plugin.PluginManager;
 import org.bukkit.plugin.ServicesManager;
 import org.bukkit.plugin.messaging.Messenger;
@@ -1420,6 +1428,54 @@ public interface Server extends PluginMessageRecipient {
     @NotNull
     List<Entity> selectEntities(@NotNull CommandSender sender, @NotNull String selector) throws IllegalArgumentException;
 
+    // Kenzie start - attachments
+    /**
+     * Allows the registration of an attachment for specific entity types.
+     * The corresponding entity types will receive a new instance of the attachment
+     * (as per the creator function) upon their creation.
+     *
+     * Attachments ought to be final, due to the need to match their class when
+     * retrieving the attachment instance from the object.
+     * @param plugin The providing plugin.
+     * @param creatorFunction A function to create a new attachment instance.
+     * @param types The entity types this attachment should be registered for.
+     */
+    void registerAttachment(@NotNull Plugin plugin, @NotNull Function<Entity, Attachment<?>> creatorFunction, @NotNull EntityType... types);
+
+    /**
+     * Allows the registration of an attachment for specific entity types.
+     * The corresponding entity types will receive a new instance of the attachment
+     * (as per the creator function) upon their creation.
+     *
+     * Attachments ought to be final, due to the need to match their class when
+     * retrieving the attachment instance from the object.
+     * @param <T> The attachment target type.
+     * @param plugin The providing plugin.
+     * @param creatorFunction A function to create a new attachment instance.
+     * @param target The target class.
+     */
+    <T extends Attachable> void registerAttachment(@NotNull Plugin plugin, @NotNull Function<? extends T, Attachment<?>> creatorFunction, @NotNull Class<T> target);
+
+    /**
+     * Unregisters the attachments provided by a plugin.
+     * @param plugin The providing plugin.
+     */
+    void unregisterAttachments(@NotNull Plugin plugin);
+    // Kenzie end
+
+    // Kenzie start - Factories
+    /**
+     * Retrieves the server's NBT factory, used for instantiating compound tags,
+     * NBT lists and other version-dependent types.
+     * @return The factory instance.
+     */
+    @NotNull
+    NBTFactory getNBTFactory();
+
+    @NotNull
+    PacketFactory getPacketFactory();
+    // Kenzie end
+
     /**
      * @see UnsafeValues
      * @return the unsafe values instance
diff --git a/src/main/java/org/bukkit/attachment/Attachable.java b/src/main/java/org/bukkit/attachment/Attachable.java
new file mode 100644
index 0000000000000000000000000000000000000000..7c43789552792db96fbaaea148e042ccf696cfaa
--- /dev/null
+++ b/src/main/java/org/bukkit/attachment/Attachable.java
@@ -0,0 +1,44 @@
+package org.bukkit.attachment;
+
+import org.jetbrains.annotations.NotNull;
+
+import java.util.function.Consumer;
+
+/**
+ * This allows objects to have unique attachments added to them.
+ */
+public interface Attachable {
+
+    /**
+     * Retrieve an attachment instance.
+     * @param attachmentClass The class that the attachment belongs to.
+     * @param <T> The specific attachment type.
+     * @return The attachment instance unique to this object.
+     * @throws NullPointerException - if the attachment is not present. Use {@link this#hasAttachment(Class)} first.
+     */
+    @NotNull
+    <T extends Attachment<?>> T getAttachment(@NotNull Class<T> attachmentClass) throws NullPointerException;
+
+    /**
+     * Check whether this object has an attachment of a specific type.
+     * @param attachmentClass The class that the attachment belongs to.
+     * @param <T> The specific attachment type.
+     * @return True if present, otherwise false.
+     */
+    <T extends Attachment<?>> boolean hasAttachment(@NotNull Class<T> attachmentClass);
+
+    /**
+     * Run a consumer on the attachment if and only if it is present.
+     * @param attachmentClass The class that the attachment belongs to.
+     * @param consumer The action to be run on the attachment.
+     * @param <T> The specific attachment type.
+     * @return True if the attachment was present, otherwise false.
+     */
+    default <T extends Attachment<?>> boolean ifAttachmentPresent(@NotNull Class<T> attachmentClass, @NotNull Consumer<T> consumer) {
+        boolean present;
+        if (present = hasAttachment(attachmentClass))
+            consumer.accept(getAttachment(attachmentClass));
+        return present;
+    }
+
+}
diff --git a/src/main/java/org/bukkit/attachment/Attachment.java b/src/main/java/org/bukkit/attachment/Attachment.java
new file mode 100644
index 0000000000000000000000000000000000000000..fdc77f05fb36870312521d5c9b046b63aba00e89
--- /dev/null
+++ b/src/main/java/org/bukkit/attachment/Attachment.java
@@ -0,0 +1,80 @@
+package org.bukkit.attachment;
+
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.JavaPlugin;
+import org.jetbrains.annotations.NotNull;
+
+public abstract class Attachment<T extends Attachable> {
+
+    private final @NotNull T subject;
+
+    public Attachment(@NotNull T subject) {
+        this.subject = subject;
+    }
+
+    /**
+     * This can be overridden if a particular implementation
+     * requires that the attachment belong to a different plugin
+     * from the one that provided the class.
+     * For example, if a plugin happened to use an attachment from
+     * an external library, but the attachment referenced data from
+     * the plugin instance, then this should return the provider.
+     * @return The providing plugin.
+     */
+    public @NotNull Plugin getOwningPlugin() {
+        return JavaPlugin.getProvidingPlugin(getClass());
+    }
+
+    /**
+     * @return The subject of this attachment.
+     */
+    public @NotNull T getSubject() {
+        return subject;
+    }
+
+    /**
+     * Called before the attachment is disposed of, allowing the provider
+     * to potentially save or otherwise deal with the data.
+     * This will occur before the owning plugin is disabled, or
+     * pre-destruction of the attachment's subject.
+     * It may not be called in all cases (for example if the subject is
+     * removed from memory silently!)
+     */
+    public synchronized void onDisposal() {
+
+    }
+
+    /**
+     * This will to be called if and when the holder's data is requested, for example
+     * during the saving process. It should not be thought of as a catch-all,
+     * but it allows for basic storage.
+     *
+     * It is also called whenever the holder's NBT compound is requested, such
+     * as by commands or plugins.
+     *
+     * This can be used to store your own data within the entity's NBT over
+     * restarts - so long as your plugin is loaded before the entity is.
+     * @param compound The mutable NBT compound to be saved.
+     */
+    public synchronized void onDataRequest(@NotNull NBTCompound compound) {
+
+    }
+
+    /**
+     * This will to be called if and when the holder's NBT data is requested, for example
+     * during the loading process. It should not be thought of as a catch-all,
+     * but it might help to be able to store simple primitive data.
+     *
+     * It is also called whenever the holder's NBT compound is edited, such
+     * as by commands or plugins.
+     *
+     * This can be used to store your own data within the entity's NBT over
+     * restarts - so long as your plugin is loaded before the entity is.
+     * @param compound The mutable NBT compound to be loaded.
+     */
+    public synchronized void onDataLoad(@NotNull NBTCompound compound) {
+
+    }
+
+}
diff --git a/src/main/java/org/bukkit/attribute/Attribute.java b/src/main/java/org/bukkit/attribute/Attribute.java
index 13eac9ad2c1672051635d1c35cc49239252e7a61..4dde6fe1d3cba668f01b18c1cc5a0e5fdf42d0ed 100644
--- a/src/main/java/org/bukkit/attribute/Attribute.java
+++ b/src/main/java/org/bukkit/attribute/Attribute.java
@@ -3,74 +3,155 @@ package org.bukkit.attribute;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
 import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Objects;
 
 /**
  * Types of attributes which may be present on an {@link Attributable}.
  */
-public enum Attribute implements Keyed {
+public final class Attribute implements Keyed {
 
     /**
      * Maximum health of an Entity.
      */
-    GENERIC_MAX_HEALTH("generic.max_health"),
+    public static final Attribute GENERIC_MAX_HEALTH = new Attribute("generic.max_health");
     /**
      * Range at which an Entity will follow others.
      */
-    GENERIC_FOLLOW_RANGE("generic.follow_range"),
+    public static final Attribute GENERIC_FOLLOW_RANGE = new Attribute("generic.follow_range");
     /**
      * Resistance of an Entity to knockback.
      */
-    GENERIC_KNOCKBACK_RESISTANCE("generic.knockback_resistance"),
+    public static final Attribute GENERIC_KNOCKBACK_RESISTANCE = new Attribute("generic.knockback_resistance");
     /**
      * Movement speed of an Entity.
      */
-    GENERIC_MOVEMENT_SPEED("generic.movement_speed"),
+    public static final Attribute GENERIC_MOVEMENT_SPEED = new Attribute("generic.movement_speed");
     /**
      * Flying speed of an Entity.
      */
-    GENERIC_FLYING_SPEED("generic.flying_speed"),
+    public static final Attribute GENERIC_FLYING_SPEED = new Attribute("generic.flying_speed");
     /**
      * Attack damage of an Entity.
      */
-    GENERIC_ATTACK_DAMAGE("generic.attack_damage"),
+    public static final Attribute GENERIC_ATTACK_DAMAGE = new Attribute("generic.attack_damage");
     /**
      * Attack knockback of an Entity.
      */
-    GENERIC_ATTACK_KNOCKBACK("generic.attack_knockback"),
+    public static final Attribute GENERIC_ATTACK_KNOCKBACK = new Attribute("generic.attack_knockback");
     /**
      * Attack speed of an Entity.
      */
-    GENERIC_ATTACK_SPEED("generic.attack_speed"),
+    public static final Attribute GENERIC_ATTACK_SPEED = new Attribute("generic.attack_speed");
     /**
      * Armor bonus of an Entity.
      */
-    GENERIC_ARMOR("generic.armor"),
+    public static final Attribute GENERIC_ARMOR = new Attribute("generic.armor");
     /**
      * Armor durability bonus of an Entity.
      */
-    GENERIC_ARMOR_TOUGHNESS("generic.armor_toughness"),
+    public static final Attribute GENERIC_ARMOR_TOUGHNESS = new Attribute("generic.armor_toughness");
     /**
      * Luck bonus of an Entity.
      */
-    GENERIC_LUCK("generic.luck"),
+    public static final Attribute GENERIC_LUCK = new Attribute("generic.luck");
     /**
      * Strength with which a horse will jump.
      */
-    HORSE_JUMP_STRENGTH("horse.jump_strength"),
+    public static final Attribute HORSE_JUMP_STRENGTH = new Attribute("horse.jump_strength");
     /**
      * Chance of a zombie to spawn reinforcements.
      */
-    ZOMBIE_SPAWN_REINFORCEMENTS("zombie.spawn_reinforcements");
+    public static final Attribute ZOMBIE_SPAWN_REINFORCEMENTS = new Attribute("zombie.spawn_reinforcements");
+
+    private static HashMap<String, Attribute> minecraftValues = new HashMap<>();
+
+    static {
+        minecraftValues.put("GENERIC_MAX_HEALTH", GENERIC_MAX_HEALTH);
+        minecraftValues.put("GENERIC_FOLLOW_RANGE", GENERIC_FOLLOW_RANGE);
+        minecraftValues.put("GENERIC_KNOCKBACK_RESISTANCE", GENERIC_KNOCKBACK_RESISTANCE);
+        minecraftValues.put("GENERIC_MOVEMENT_SPEED", GENERIC_MOVEMENT_SPEED);
+        minecraftValues.put("GENERIC_FLYING_SPEED", GENERIC_FLYING_SPEED);
+        minecraftValues.put("GENERIC_ATTACK_DAMAGE", GENERIC_ATTACK_DAMAGE);
+        minecraftValues.put("GENERIC_ATTACK_KNOCKBACK", GENERIC_ATTACK_KNOCKBACK);
+        minecraftValues.put("GENERIC_ATTACK_SPEED", GENERIC_ATTACK_SPEED);
+        minecraftValues.put("GENERIC_ARMOR", GENERIC_ARMOR);
+        minecraftValues.put("GENERIC_ARMOR_TOUGHNESS", GENERIC_ARMOR_TOUGHNESS);
+        minecraftValues.put("GENERIC_LUCK", GENERIC_LUCK);
+    }
 
     private final NamespacedKey key;
 
-    private Attribute(String key) {
+    public Attribute(@NotNull NamespacedKey key) {
+        this.key = key;
+    }
+
+    private Attribute(@NotNull String key) {
         this.key = NamespacedKey.minecraft(key);
     }
 
+    /**
+     * Whether this attribute is built-in, and found in "vanilla" Minecraft.
+     * @return True if this is a built-in attribute, false if it was added in a custom implementation.
+     */
+    public boolean isVanilla() {
+        return minecraftValues.containsValue(this);
+    }
+
     @NotNull
     @Override
     public NamespacedKey getKey() {
         return key;
     }
+
+    /**
+     * @return The string key of this attribute, without the namespace.
+     */
+    @NotNull
+    public String name() {
+        return getKey().getKey();
+    }
+
+    @NotNull
+    public static Iterator<Attribute> attributeIterator() {
+        return minecraftValues.values().iterator();
+    }
+
+    /**
+     * Provides backwards compatibility for the old enum system.
+     *
+     * @return An array of the built-in Minecraft attributes.
+     */
+    @NotNull
+    public static Attribute[] values() {
+        return minecraftValues.values().toArray(new Attribute[0]);
+    }
+
+    /**
+     * Provides backwards compatibility for the old enum system.
+     *
+     * @param name The field-name of the attribute.
+     * @return The attribute.
+     */
+    @Nullable
+    public static Attribute valueOf(@NotNull String name) {
+        return minecraftValues.get(name);
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (this == o) return true;
+        if (!(o instanceof Attribute)) return false;
+        Attribute attribute = (Attribute) o;
+        return Objects.equals(key, attribute.key);
+    }
+
+    @Override
+    public int hashCode() {
+        return Objects.hash(key);
+    }
+
 }
diff --git a/src/main/java/org/bukkit/attribute/AttributeInstance.java b/src/main/java/org/bukkit/attribute/AttributeInstance.java
index f08ee26cc4d479e1bfc5264b8cbe721315de91f2..18bafb04e6e946c05be27a6f71ed75a4bb80db7c 100644
--- a/src/main/java/org/bukkit/attribute/AttributeInstance.java
+++ b/src/main/java/org/bukkit/attribute/AttributeInstance.java
@@ -1,8 +1,9 @@
 package org.bukkit.attribute;
 
-import java.util.Collection;
 import org.jetbrains.annotations.NotNull;
 
+import java.util.Collection;
+
 /**
  * Represents a mutable instance of an attribute and its associated modifiers
  * and values.
diff --git a/src/main/java/org/bukkit/attribute/AttributeModifier.java b/src/main/java/org/bukkit/attribute/AttributeModifier.java
index ff8f1231f3e2e71740fd24fa8d4dac5d0e550ae7..94d4d5e46324b823ace3bf06671d206b9055cb9f 100644
--- a/src/main/java/org/bukkit/attribute/AttributeModifier.java
+++ b/src/main/java/org/bukkit/attribute/AttributeModifier.java
@@ -1,9 +1,5 @@
 package org.bukkit.attribute;
 
-import java.util.HashMap;
-import java.util.Map;
-import java.util.Objects;
-import java.util.UUID;
 import org.apache.commons.lang.Validate;
 import org.bukkit.configuration.serialization.ConfigurationSerializable;
 import org.bukkit.inventory.EquipmentSlot;
@@ -11,6 +7,11 @@ import org.bukkit.util.NumberConversions;
 import org.jetbrains.annotations.NotNull;
 import org.jetbrains.annotations.Nullable;
 
+import java.util.HashMap;
+import java.util.Map;
+import java.util.Objects;
+import java.util.UUID;
+
 /**
  * Concrete implementation of an attribute modifier.
  */
diff --git a/src/main/java/org/bukkit/entity/Entity.java b/src/main/java/org/bukkit/entity/Entity.java
index cb9ef706eeb994f1948708ad5e8689550ea56df7..1e02242b47f38c90d925b3084a7d284696234475 100644
--- a/src/main/java/org/bukkit/entity/Entity.java
+++ b/src/main/java/org/bukkit/entity/Entity.java
@@ -3,12 +3,15 @@ package org.bukkit.entity;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+
+import mx.kenzie.wellspring.nbt.NBTHolder;
 import org.bukkit.Chunk; // Paper
 import org.bukkit.EntityEffect;
 import org.bukkit.Location;
 import org.bukkit.Nameable;
 import org.bukkit.Server;
 import org.bukkit.World;
+import org.bukkit.attachment.Attachable;
 import org.bukkit.block.BlockFace;
 import org.bukkit.block.PistonMoveReaction;
 import org.bukkit.command.CommandSender;
@@ -26,7 +29,7 @@ import org.jetbrains.annotations.Nullable;
 /**
  * Represents a base entity in the world
  */
-public interface Entity extends Metadatable, CommandSender, Nameable, PersistentDataHolder {
+public interface Entity extends Metadatable, CommandSender, Nameable, PersistentDataHolder, Attachable, NBTHolder {
 
     /*
      * Gets the entity's current position
