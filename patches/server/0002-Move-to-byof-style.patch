From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Moderocky <admin@moderocky.com>
Date: Fri, 16 Oct 2020 15:35:07 +0100
Subject: [PATCH] Move to byof style.

Repair git merging error in server.

Fix io package conflict.

Fix missed block NBT.

Handle

diff --git a/src/main/java/com/destroystokyo/paper/network/PaperNetworkClient.java b/src/main/java/com/destroystokyo/paper/network/PaperNetworkClient.java
index 5caca6439d2135e34880d501397fe2ea197d7249..1fbe2cfeb8c5a6eda85ea38e71963eb590cfd94c 100644
--- a/src/main/java/com/destroystokyo/paper/network/PaperNetworkClient.java
+++ b/src/main/java/com/destroystokyo/paper/network/PaperNetworkClient.java
@@ -47,4 +47,5 @@ public class PaperNetworkClient implements NetworkClient {
         return InetSocketAddress.createUnresolved(host.substring(0, len), port);
     }
 
+    public NetworkManager getNetworkManager() { return networkManager; } // Kenzie - packets! :)
 }
diff --git a/src/main/java/mx/kenzie/server/CraftBridge.java b/src/main/java/mx/kenzie/server/CraftBridge.java
new file mode 100644
index 0000000000000000000000000000000000000000..caa4d73bc7914bd4b5ed1a731771077462eb0d12
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/CraftBridge.java
@@ -0,0 +1,183 @@
+package mx.kenzie.server;
+
+import mx.kenzie.wellspring.Wellspring;
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import mx.kenzie.wellspring.structure.*;
+import net.minecraft.server.*;
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftLivingEntity;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.entity.EntityType;
+
+import java.io.InputStream;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.Map;
+
+public class CraftBridge extends Wellspring.Bridge {
+
+    @Override
+    public boolean isStructurePresent(WorldStructureType structure, Location location) {
+        WorldStructure str = getStructure(structure, location);
+        return str != null && str != StructureStart.a;
+    }
+
+    @Override
+    public WorldStructure getStructure(WorldStructureType structure, Location location) {
+        final WorldServer world = ((CraftWorld) location.getWorld()).getHandle();
+        final BlockPosition position = new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+        return world.getStructureManager().a(position, false, IRegistry.STRUCTURE_FEATURE.get(MinecraftKey.a(structure.getKey().toString())));
+    }
+
+    @Override
+    public WorldStructurePart getStructurePart(WorldStructureType structure, Location location) {
+        final WorldServer world = ((CraftWorld) location.getWorld()).getHandle();
+        final BlockPosition position = new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+        final StructureGenerator<?> generator = IRegistry.STRUCTURE_FEATURE.get(MinecraftKey.a(structure.getKey().toString()));
+        for (StructureStart<?> structurestart : world.getStructureManager().getFeatureStarts(SectionPosition.a(position), generator)) {
+            if (structurestart.c().b(position)) {
+                for (StructurePiece structurepiece : structurestart.d()) {
+                    if (structurepiece.g().b(position)) {
+                        return structurepiece;
+                    }
+                }
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public StructureInfo createStructureInfo() {
+        return new DefinedStructureInfo();
+    }
+
+    @Override
+    public Structure createStructure() {
+        return new DefinedStructure();
+    }
+
+    @Override
+    public Structure loadStructure(NBTCompound compound) {
+        DefinedStructure structure = new DefinedStructure();
+        structure.load(compound);
+        return structure;
+    }
+
+    @Override
+    public Structure loadStructure(InputStream stream) {
+        try {
+            DefinedStructure structure = new DefinedStructure();
+            structure.load(NBTCompressedStreamTools.a(stream));
+            return structure;
+        } catch (Throwable ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    @Override
+    public Structure loadStructure(NamespacedKey key) {
+        return MinecraftServer.getServer().getDefinedStructureManager().b(MinecraftKey.a(key.toString()));
+    }
+
+    @Override
+    public float getWidth(EntityType type) {
+        return IRegistry.ENTITY_TYPE.get(new MinecraftKey(type.getKey().toString())).j();
+    }
+
+    @Override
+    public float getHeight(EntityType type) {
+        return IRegistry.ENTITY_TYPE.get(new MinecraftKey(type.getKey().toString())).k();
+    }
+
+    @Override
+    public int getEntityIndex(String entityKey) {
+        return IRegistry.ENTITY_TYPE.a(IRegistry.ENTITY_TYPE.get(new MinecraftKey(entityKey)));
+    }
+
+    @Override
+    public Map<Attribute, Double> getBaseValues(EntityType type) {
+        if (!type.isAlive()) return new HashMap<>();
+        AttributeProvider provider = getProvider(type);
+        return provider.getAndConvertMap();
+    }
+
+    @Override
+    public void setBaseValues(EntityType type, Map<Attribute, Double> attributes) {
+        if (!type.isAlive()) return;
+        for (Map.Entry<Attribute, Double> entry : attributes.entrySet()) {
+            setBaseValue(type, entry.getKey(), entry.getValue());
+        }
+    }
+
+    @Override
+    public double getBaseValue(EntityType type, Attribute attribute) {
+        if (!type.isAlive()) return 0.0;
+        return getBaseValues(type).get(attribute);
+    }
+
+    @Override
+    public void setBaseValue(EntityType type, Attribute attribute, double value) {
+        if (!type.isAlive()) return;
+        AttributeProvider provider = getProvider(type);
+        NamespacedKey key = attribute.getKey();
+        AttributeBase base = IRegistry.ATTRIBUTE.get(new MinecraftKey(key.toString()));
+        if (base == null) return;
+        AttributeModifiable modifiable = new AttributeModifiable(base, (var1x) -> {
+        });
+        modifiable.setValue(value);
+        provider.getMap().put(base, modifiable);
+    }
+
+    @Override
+    public void removeBase(EntityType type, Attribute attribute) {
+        if (!type.isAlive()) return;
+        AttributeProvider provider = getProvider(type);
+        NamespacedKey key = attribute.getKey();
+        AttributeBase base = IRegistry.ATTRIBUTE.get(new MinecraftKey(key.toString()));
+        if (base == null) return;
+        provider.getMap().remove(base);
+    }
+
+    @SuppressWarnings("unchecked")
+    public AttributeProvider getProvider(EntityType type) {
+        if (!type.isAlive()) return null;
+        EntityTypes<? extends EntityLiving> types = ((EntityTypes<? extends EntityLiving>) convertType(type));
+        AttributeProvider provider = AttributeDefaults.getDefault(types);
+        if (provider == null) {
+            provider = new AttributeProvider.Builder().a();
+            AttributeDefaults.getAttributeDefaults().put(types, provider);
+        }
+        return provider;
+    }
+
+    public EntityTypes<?> convertType(EntityType type) {
+        return IRegistry.ENTITY_TYPE.get(new MinecraftKey(type.getKey().toString()));
+    }
+
+    public int getMaxPresentLevel(Enchantment enchantment, CraftEntity entity) {
+        if (enchantment == null) return 0;
+        if (!(entity instanceof CraftLivingEntity)) return 0;
+        net.minecraft.server.Enchantment ench = IRegistry.ENCHANTMENT.get(new MinecraftKey(enchantment.getKey().toString()));
+        if (ench == null) return 0;
+        return net.minecraft.server.EnchantmentManager.a(ench, ((CraftLivingEntity) entity).getHandle());
+    }
+
+    public int getCumulativeLevel(Enchantment enchantment, CraftEntity entity) {
+        if (enchantment == null) return 0;
+        if (!(entity instanceof CraftLivingEntity)) return 0;
+        net.minecraft.server.Enchantment ench = IRegistry.ENCHANTMENT.get(new MinecraftKey(enchantment.getKey().toString()));
+        if (ench == null) return 0;
+        int i = 0;
+        for (ItemStack stack : ench.a(((CraftLivingEntity) entity).getHandle()).values()) {
+            i += EnchantmentManager.getEnchantmentLevel(ench, stack);
+        }
+        return i;
+    }
+
+
+
+}
diff --git a/src/main/java/mx/kenzie/server/attachment/AttachmentFactory.java b/src/main/java/mx/kenzie/server/attachment/AttachmentFactory.java
new file mode 100644
index 0000000000000000000000000000000000000000..74f0cb133ad9adcd7e8135e99c87f04a9e19302f
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/attachment/AttachmentFactory.java
@@ -0,0 +1,123 @@
+package mx.kenzie.server.attachment;
+
+import mx.kenzie.wellspring.Provider;
+import org.apache.commons.lang3.Validate;
+import org.bukkit.attachment.Attachable;
+import org.bukkit.attachment.Attachment;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.plugin.Plugin;
+
+import java.lang.ref.WeakReference;
+import java.util.*;
+import java.util.function.Function;
+
+public class AttachmentFactory {
+
+    private final CraftServer server;
+    private final Map<Plugin, Map<Class<? extends Attachable>, Set<Function<Attachable, Attachment<?>>>>> pluginFactoryMethods;
+    private final Set<WeakReference<AttachmentHolder>> holders;
+
+    public AttachmentFactory(CraftServer server) {
+        this.server = server;
+        this.holders = new HashSet<>();
+        this.pluginFactoryMethods = new HashMap<>();
+    }
+
+    public void registerAttachmentHolder(AttachmentHolder holder) {
+        holders.add(new WeakReference<>(holder));
+    }
+
+    public void registerAttachment(Plugin plugin, Class<? extends Attachable> target, Function<Attachable, Attachment<?>> provider) {
+        Validate.notNull(plugin, "Plugin cannot be null!");
+        Validate.notNull(target, "Target type cannot be null!");
+        Validate.notNull(provider, "Provider function cannot be null!");
+        final Map<Class<? extends Attachable>, Set<Function<Attachable, Attachment<?>>>> factories;
+        pluginFactoryMethods.putIfAbsent(plugin, new HashMap<>());
+        factories = pluginFactoryMethods.get(plugin);
+        factories.putIfAbsent(target, new HashSet<>());
+        factories.get(target).add(provider);
+        for (WeakReference<AttachmentHolder> reference : holders) {
+            AttachmentHolder holder = reference.get();
+            if (holder == null) continue;
+            if (holder.target.getClass() == target || target.isAssignableFrom(holder.target.getClass())) {
+                Attachment<?> attachment = provider.apply(holder.target);
+                holder.add(attachment);
+            }
+        }
+    }
+
+    public <T extends Attachable> AttachmentHolder createAttachments(T target) {
+        final AttachmentHolder holder = new AttachmentHolder(target);
+        registerAttachmentHolder(holder);
+        addAttachments(target, holder);
+        return holder;
+    }
+
+    public <T extends Attachable> void addAttachments(T target, AttachmentHolder holder) {
+        Set<Function<Attachable, Attachment<?>>> providers = getAttachmentProviders(target.getClass());
+        for (Function<Attachable, Attachment<?>> provider : providers) {
+            try {
+                Attachment<? super T> attachment = (Attachment<? super T>) provider.apply(target);
+                holder.add(attachment);
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+    }
+
+    public <T extends Attachable> void addAttachments(Class<T> cls, Provider<T> providerFunc, AttachmentHolder holder) {
+        T target = providerFunc.get();
+        Set<Function<Attachable, Attachment<?>>> providers = getAttachmentProviders(cls);
+        for (Function<Attachable, Attachment<?>> provider : providers) {
+            try {
+                Attachment<? super T> attachment = (Attachment<? super T>) provider.apply(target);
+                holder.add(attachment);
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+    }
+
+    public <T extends Attachable> void removeAttachments(Class<T> cls, AttachmentHolder holder) {
+        holder.removeByClass(cls);
+    }
+
+    public Set<Function<Attachable, Attachment<?>>> getAttachmentProviders(Class<? extends Attachable> target) {
+        Validate.notNull(target, "Target class cannot be null!");
+        Set<Function<Attachable, Attachment<?>>> providers = new HashSet<>();
+        for (Map<Class<? extends Attachable>, Set<Function<Attachable, Attachment<?>>>> map : pluginFactoryMethods.values()) {
+            for (Class<? extends Attachable> cls : map.keySet()) {
+                if (!cls.equals(target) && !cls.isAssignableFrom(target)) continue;
+                if (map.get(cls) == null) continue;
+                providers.addAll(map.get(cls));
+            }
+        }
+        return providers;
+    }
+
+    public void removeAll(Plugin plugin) {
+        Iterator<WeakReference<AttachmentHolder>> iterator = holders.iterator();
+        while (iterator.hasNext()) {
+            WeakReference<AttachmentHolder> reference = iterator.next();
+            AttachmentHolder holder = reference.get();
+            if (holder == null) {
+                iterator.remove();
+            } else {
+                holder.removeAll(plugin);
+            }
+        }
+        pluginFactoryMethods.remove(plugin);
+    }
+
+    public void disposeOfAll() {
+        for (WeakReference<AttachmentHolder> reference : holders) {
+            AttachmentHolder holder = reference.get();
+            if (holder != null) {
+                holder.dispose();
+            }
+        }
+        holders.clear();
+        pluginFactoryMethods.clear();
+    }
+
+}
diff --git a/src/main/java/mx/kenzie/server/attachment/AttachmentHolder.java b/src/main/java/mx/kenzie/server/attachment/AttachmentHolder.java
new file mode 100644
index 0000000000000000000000000000000000000000..dbea2f768297ab0c85f9ea4f1b2de8c4c671fa9d
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/attachment/AttachmentHolder.java
@@ -0,0 +1,98 @@
+package mx.kenzie.server.attachment;
+
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import org.bukkit.attachment.Attachable;
+import org.bukkit.attachment.Attachment;
+import org.bukkit.plugin.Plugin;
+
+import javax.annotation.Nullable;
+import java.util.ArrayList;
+import java.util.HashSet;
+import java.util.Set;
+
+public class AttachmentHolder extends ArrayList<Attachment<?>> {
+
+    public final Attachable target;
+
+    public AttachmentHolder(Attachable target) {
+        this.target = target;
+    }
+
+    public Attachment<?> getByClass(Class<? extends Attachment<?>> cls) {
+        for (Attachment<?> attachment : this) {
+            if (attachment.getClass() == cls) return attachment;
+        }
+        return null;
+    }
+
+    public void removeByClass(Class<? extends Attachable> cls) {
+        this.removeIf(attachment -> {
+            if (attachment.getSubject() == null || cls.isAssignableFrom(attachment.getSubject().getClass())) {
+                attachment.onDisposal();
+                return true;
+            }
+            return false;
+        });
+    }
+
+    public boolean containsByClass(Class<? extends Attachment<?>> cls) {
+        for (Attachment<?> attachment : this) {
+            if (attachment.getClass() == cls) return true;
+        }
+        return false;
+    }
+
+    public Set<Attachment<?>> getByProvider(Plugin plugin) {
+        Set<Attachment<?>> set = new HashSet<>();
+        for (Attachment<?> attachment : this) {
+            if (attachment.getOwningPlugin() == plugin) set.add(attachment);
+        }
+        return set;
+    }
+
+    public void removeAll(Plugin plugin) {
+        this.removeIf(attachment -> {
+            if (attachment.getOwningPlugin() == plugin) {
+                try {
+                    attachment.onDisposal();
+                } catch (Throwable throwable) {
+                    throwable.printStackTrace();
+                }
+                return true;
+            }
+            return false;
+        });
+    }
+
+    public void load(NBTCompound compound) {
+        for (Attachment<?> attachment : this) {
+            try {
+                attachment.onDataLoad(compound);
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+    }
+
+    public void request(NBTCompound compound) {
+        for (Attachment<?> attachment : this) {
+            try {
+                attachment.onDataRequest(compound);
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+    }
+
+    public void dispose() {
+        for (Attachment<?> attachment : this) {
+            try {
+                attachment.onDisposal();
+            } catch (Throwable throwable) {
+                throwable.printStackTrace();
+            }
+        }
+        this.clear();
+    }
+
+}
diff --git a/src/main/java/mx/kenzie/server/enchantment/EnchantmentBuilderImplementation.java b/src/main/java/mx/kenzie/server/enchantment/EnchantmentBuilderImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..1d1b52966b6ca3b1a078a1e823688410428e356d
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/enchantment/EnchantmentBuilderImplementation.java
@@ -0,0 +1,255 @@
+package mx.kenzie.server.enchantment;
+
+import com.google.common.collect.HashMultimap;
+import com.google.common.collect.Multimap;
+import mx.kenzie.wellspring.enchantment.EnchantmentBuilder;
+import mx.kenzie.wellspring.enchantment.Rarity;
+import mx.kenzie.wellspring.enchantment.Target;
+import net.md_5.bungee.chat.ComponentSerializer;
+import net.minecraft.server.*;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.craftbukkit.enchantments.CraftEnchantment;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.enchantments.Enchantment;
+import org.bukkit.entity.EntityCategory;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.event.entity.EntityDamageEvent;
+
+import java.nio.charset.StandardCharsets;
+import java.util.Map;
+import java.util.UUID;
+
+public class EnchantmentBuilderImplementation extends EnchantmentBuilder {
+
+    protected Multimap<Attribute, AttributeModifier> attributes = HashMultimap.create();
+
+    public EnchantmentBuilderImplementation(NamespacedKey key, String name) {
+        super(key, name);
+    }
+
+    @Override
+    public EnchantmentBuilder addAttribute(Attribute attribute, double value, AttributeModifier.Operation operation) {
+        AttributeModifier modifier = new AttributeModifier(UUID.nameUUIDFromBytes(key.toString().getBytes(StandardCharsets.UTF_8)), key.toString(), value, operation);
+        attributes.put(attribute, modifier);
+        return this;
+    }
+
+    @Override
+    public org.bukkit.enchantments.Enchantment create() {
+
+        class CustomEnchantment extends net.minecraft.server.Enchantment {
+
+            protected CustomEnchantment(Rarity var0, EnchantmentSlotType var1, EnumItemSlot[] var2) {
+                super(var0, var1, var2);
+            }
+
+            @Override
+            public boolean isTreasure() {
+                return treasure;
+            }
+
+            @Override
+            public boolean c() {
+                return curse;
+            }
+
+            @Override
+            public boolean h() {
+                return tradable;
+            }
+
+            @Override
+            public boolean i() {
+                return discoverable;
+            }
+
+            @Override
+            public boolean canEnchant(ItemStack var0) {
+                if (canEnchant != null)
+                    return canEnchant.apply(CraftItemStack.asBukkitCopy(var0));
+                return super.canEnchant(var0);
+            }
+
+            @Override
+            public int getStartLevel() {
+                return minLevel;
+            }
+
+            @Override
+            public int getMaxLevel() {
+                return maxLevel;
+            }
+
+            @Override
+            public int a(int var0) {
+                return minCost;
+            }
+
+            @Override
+            public int b(int var0) {
+                return maxCost;
+            }
+
+            @Override
+            public int a(int var0, DamageSource var1) {
+                if (damageProtection == null) return super.a(var0, var1);
+                EntityDamageEvent.DamageCause cause;
+                if (var1 == DamageSource.ANVIL) cause = EntityDamageEvent.DamageCause.FALLING_BLOCK;
+                else if (var1 == DamageSource.BURN) cause = EntityDamageEvent.DamageCause.FIRE_TICK;
+                else if (var1 == DamageSource.CACTUS) cause = EntityDamageEvent.DamageCause.CONTACT;
+                else if (var1 == DamageSource.CRAMMING) cause = EntityDamageEvent.DamageCause.CRAMMING;
+                else if (var1 == DamageSource.DRAGON_BREATH) cause = EntityDamageEvent.DamageCause.DRAGON_BREATH;
+                else if (var1 == DamageSource.DROWN) cause = EntityDamageEvent.DamageCause.DROWNING;
+                else if (var1 == DamageSource.DRYOUT) cause = EntityDamageEvent.DamageCause.DRYOUT;
+                else if (var1 == DamageSource.FIRE) cause = EntityDamageEvent.DamageCause.FIRE;
+                else if (var1 == DamageSource.FLY_INTO_WALL) cause = EntityDamageEvent.DamageCause.FLY_INTO_WALL;
+                else if (var1 == DamageSource.FALLING_BLOCK) cause = EntityDamageEvent.DamageCause.FALLING_BLOCK;
+                else if (var1 == DamageSource.FALL) cause = EntityDamageEvent.DamageCause.FALL;
+                else if (var1 == DamageSource.GENERIC) cause = EntityDamageEvent.DamageCause.ENTITY_ATTACK;
+                else if (var1 == DamageSource.SWEET_BERRY_BUSH) cause = EntityDamageEvent.DamageCause.CONTACT;
+                else if (var1 == DamageSource.HOT_FLOOR) cause = EntityDamageEvent.DamageCause.HOT_FLOOR;
+                else if (var1 == DamageSource.WITHER) cause = EntityDamageEvent.DamageCause.WITHER;
+                else if (var1 == DamageSource.LAVA) cause = EntityDamageEvent.DamageCause.LAVA;
+                else if (var1 == DamageSource.LIGHTNING) cause = EntityDamageEvent.DamageCause.LIGHTNING;
+                else if (var1 == DamageSource.MAGIC) cause = EntityDamageEvent.DamageCause.MAGIC;
+                else if (var1 == DamageSource.STARVE) cause = EntityDamageEvent.DamageCause.STARVATION;
+                else if (var1 == DamageSource.OUT_OF_WORLD) cause = EntityDamageEvent.DamageCause.VOID;
+                else cause = EntityDamageEvent.DamageCause.CUSTOM;
+                return damageProtection.apply(cause);
+            }
+
+            @Override
+            public float a(int var0, EnumMonsterType var1) {
+                if (damageBonus == null) return super.a(var0, var1);
+                EntityCategory category;
+                if (var1 == EnumMonsterType.ARTHROPOD) category = EntityCategory.ARTHROPOD;
+                else if (var1 == EnumMonsterType.ILLAGER) category = EntityCategory.ILLAGER;
+                else if (var1 == EnumMonsterType.UNDEAD) category = EntityCategory.UNDEAD;
+                else if (var1 == EnumMonsterType.WATER_MOB) category = EntityCategory.WATER;
+                else category = EntityCategory.NONE;
+                return damageBonus.apply(category);
+            }
+
+            @Override // is compatible
+            protected boolean a(net.minecraft.server.Enchantment var0) {
+                if (compatible == null) return super.a(var0);
+                String string = IRegistry.ENCHANTMENT.getKey(var0).toString();
+                String[] parts = string.split(":");
+                Enchantment enchantment = Enchantment.getByKey(new NamespacedKey(parts[0], parts[1]));
+                return compatible.apply(enchantment);
+            }
+
+            @Override
+            protected String f() {
+                if (description == null) return super.f();
+                return description;
+            }
+
+            @Override
+            public String g() {
+                return f();
+            }
+
+            @Override
+            public IChatBaseComponent d(int var0) {
+                if (nameByLevel == null) return super.d(var0);
+                return IChatBaseComponent.ChatSerializer.jsonToComponent(ComponentSerializer.toString(nameByLevel.apply(var0)));
+            }
+
+            @Override
+            public void a(EntityLiving var0, Entity var1, int var2) {
+                if (onDealDamage == null) return;
+                LivingEntity holder = var0.getBukkitLivingEntity();
+                org.bukkit.entity.Entity target = var1 != null ? var1.getBukkitEntity() : null;
+                onDealDamage.onStrike(holder, target, var2);
+            }
+
+            @Override
+            public void b(EntityLiving var0, Entity var1, int var2) {
+                if (onTakeDamage == null) return;
+                LivingEntity holder = var0.getBukkitLivingEntity();
+                org.bukkit.entity.Entity target = var1 != null ? var1.getBukkitEntity() : null;
+                onTakeDamage.onStrike(holder, target, var2);
+            }
+        }
+
+        CustomEnchantment enchantment = new CustomEnchantment(convert(rarity),
+            convert(target),
+            EnumItemSlot.convert(effectiveSlots));
+
+        net.minecraft.server.Enchantment ench = IRegistry.a(IRegistry.ENCHANTMENT, key.toString(), enchantment);
+        if (!attributes.isEmpty()) for (Map.Entry<Attribute, AttributeModifier> entry : attributes.entries()) {
+            AttributeBase base = IRegistry.ATTRIBUTE.get(MinecraftKey.a(entry.getKey().getKey().toString()));
+            if (base == null) continue;
+            AttributeModifier modifier = entry.getValue();
+            ench.addAttribute(base, new net.minecraft.server.AttributeModifier(modifier.getUniqueId(), modifier.getName(), modifier.getAmount(), convert(modifier.getOperation())));
+        }
+        Enchantment wrapper = new CraftEnchantment(ench);
+        Enchantment.registerCustomEnchantment(wrapper);
+        return wrapper;
+    }
+
+    private net.minecraft.server.AttributeModifier.Operation convert(AttributeModifier.Operation operation) {
+        switch (operation) {
+            case ADD_NUMBER:
+                return net.minecraft.server.AttributeModifier.Operation.ADDITION;
+            case MULTIPLY_SCALAR_1:
+                return net.minecraft.server.AttributeModifier.Operation.MULTIPLY_TOTAL;
+            case ADD_SCALAR:
+                return net.minecraft.server.AttributeModifier.Operation.MULTIPLY_BASE;
+        }
+        return net.minecraft.server.AttributeModifier.Operation.ADDITION;
+    }
+
+    private EnchantmentSlotType convert(Target target) {
+        if (target == null) return EnchantmentSlotType.WEAPON;
+        switch (target) {
+            case WEARABLE:
+                return EnchantmentSlotType.WEARABLE;
+            case WEAPON:
+                return EnchantmentSlotType.WEAPON;
+            case BOW:
+                return EnchantmentSlotType.BOW;
+            case ARMOR:
+                return EnchantmentSlotType.ARMOR;
+            case DIGGER:
+                return EnchantmentSlotType.DIGGER;
+            case TRIDENT:
+                return EnchantmentSlotType.TRIDENT;
+            case CROSSBOW:
+                return EnchantmentSlotType.CROSSBOW;
+            case BREAKABLE:
+                return EnchantmentSlotType.BREAKABLE;
+            case ARMOR_HEAD:
+                return EnchantmentSlotType.ARMOR_HEAD;
+            case ARMOR_CHEST:
+                return EnchantmentSlotType.ARMOR_CHEST;
+            case ARMOR_LEGS:
+                return EnchantmentSlotType.ARMOR_LEGS;
+            case ARMOR_FEET:
+                return EnchantmentSlotType.ARMOR_FEET;
+            case VANISHABLE:
+                return EnchantmentSlotType.VANISHABLE;
+            case FISHING_ROD:
+                return EnchantmentSlotType.FISHING_ROD;
+        }
+        return EnchantmentSlotType.WEAPON;
+    }
+
+    private net.minecraft.server.Enchantment.Rarity convert(Rarity rarity) {
+        if (rarity == null) return net.minecraft.server.Enchantment.Rarity.COMMON;
+        switch (rarity) {
+            case RARE:
+                return net.minecraft.server.Enchantment.Rarity.RARE;
+            case COMMON:
+                return net.minecraft.server.Enchantment.Rarity.COMMON;
+            case UNCOMMON:
+                return net.minecraft.server.Enchantment.Rarity.UNCOMMON;
+            case VERY_RARE:
+                return net.minecraft.server.Enchantment.Rarity.VERY_RARE;
+        }
+        return net.minecraft.server.Enchantment.Rarity.COMMON;
+    }
+}
diff --git a/src/main/java/mx/kenzie/server/nbt/NBTFactoryImplementation.java b/src/main/java/mx/kenzie/server/nbt/NBTFactoryImplementation.java
new file mode 100644
index 0000000000000000000000000000000000000000..8ae8b3c8665b51d577c31100312d8ea365f11b9a
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/nbt/NBTFactoryImplementation.java
@@ -0,0 +1,143 @@
+package mx.kenzie.server.nbt;
+
+import mx.kenzie.wellspring.nbt.NBT;
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import mx.kenzie.wellspring.nbt.NBTFactory;
+import mx.kenzie.wellspring.nbt.NBTList;
+import net.minecraft.server.*;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.inventory.CraftItemStack;
+import org.bukkit.entity.Entity;
+import org.bukkit.inventory.ItemStack;
+
+import java.util.List;
+
+public class NBTFactoryImplementation extends NBTFactory {
+
+    public NBTFactoryImplementation() {
+
+    }
+
+    @Override
+    public NBTCompound parse(String string) throws IllegalArgumentException {
+        try {
+            return MojangsonParser.parse(string);
+        } catch (Throwable ex) {
+            throw new IllegalArgumentException("NBT compound could not be parsed!", ex);
+        }
+    }
+
+    @Override
+    public NBTCompound newCompound() {
+        return new NBTTagCompound();
+    }
+
+    @Override
+    public mx.kenzie.wellspring.nbt.NBTList newList() {
+        return new NBTTagList();
+    }
+
+    @Override
+    public NBT newBase(Object object, NBT.Type type) {
+        try {
+            switch (type) {
+                case BOOLEAN:
+                    return NBTTagByte.a((Boolean) object);
+                case BYTE:
+                    return NBTTagByte.a((Byte) object);
+                case INT:
+                    return NBTTagInt.a((Integer) object);
+                case SHORT:
+                    return NBTTagShort.a((Short) object);
+                case LONG:
+                    return NBTTagLong.a((Long) object);
+                case FLOAT:
+                    return NBTTagFloat.a((Float) object);
+                case DOUBLE:
+                    return NBTTagDouble.a((Double) object);
+                case BYTE_ARRAY:
+                    if (object instanceof byte[])
+                        return new NBTTagByteArray((byte[]) object);
+                    else if (object instanceof List)
+                        return new NBTTagByteArray((List<Byte>) object);
+                    break;
+                case INT_ARRAY:
+                    if (object instanceof int[])
+                        return new NBTTagIntArray((int[]) object);
+                    else if (object instanceof List)
+                        return new NBTTagIntArray((List<Integer>) object);
+                    break;
+                case LONG_ARRAY:
+                    if (object instanceof long[])
+                        return new NBTTagLongArray((long[]) object);
+                    else if (object instanceof List)
+                        return new NBTTagLongArray((List<Long>) object);
+                    break;
+                case STRING:
+                    return NBTTagString.a((String) object);
+                case LIST:
+                    return (NBTList) object;
+                case COMPOUND:
+                    return (NBTCompound) object;
+                default:
+                    return (NBT) object;
+            }
+            throw new IllegalArgumentException("Unable to convert argument: " + object + " to NBT base of type: " + type + "!");
+        } catch (Throwable ex) {
+            throw new IllegalArgumentException("Unable to convert argument: " + object + " to NBT base of type: " + type + "!", ex);
+        }
+    }
+
+    @Override
+    public NBTCompound getNBT(Entity entity) {
+        NBTTagCompound compound = new NBTTagCompound();
+        return ((CraftEntity) entity).getHandle().save(compound);
+    }
+
+    @Override
+    public void mergeNBT(ItemStack itemStack, NBTCompound compound) {
+        NBTTagCompound original;
+        net.minecraft.server.ItemStack stack;
+        stack = CraftItemStack.asNMSCopy(itemStack);
+        if (compound.containsKey("id", NBT.Type.STRING) && compound.containsKey("Count", NBT.Type.BYTE)) {
+            original = stack.save(new NBTTagCompound());
+            original.merge(compound);
+            stack.load(original);
+        } else {
+            original = stack.getOrCreateTag();
+            original.merge(compound);
+            stack.setTag(original);
+        }
+        itemStack.setItemMeta(CraftItemStack.asBukkitCopy(stack).getItemMeta());
+    }
+
+    @Override
+    public void setNBT(ItemStack itemStack, NBTCompound compound) {
+        net.minecraft.server.ItemStack stack =
+            CraftItemStack.asNMSCopy(itemStack);
+        if (compound.containsKey("id", NBT.Type.STRING) && compound.containsKey("Count", NBT.Type.BYTE)) {
+            stack.load(((NBTTagCompound) compound));
+        } else {
+            stack.setTag(((NBTTagCompound) compound));
+        }
+        itemStack.setItemMeta(CraftItemStack.asBukkitCopy(stack).getItemMeta());
+    }
+
+    @Override
+    public NBTCompound getNBT(org.bukkit.inventory.ItemStack itemStack) {
+        return CraftItemStack.asNMSCopy(itemStack).getOrCreateTag();
+    }
+
+    @Override
+    public NBTCompound getAsCompound(ItemStack itemStack) {
+        NBTTagCompound compound = new NBTTagCompound();
+        return CraftItemStack.asNMSCopy(itemStack).save(compound);
+    }
+
+    @Override
+    public ItemStack createItem(NBTCompound compound) {
+        return CraftItemStack.asBukkitCopy(net.minecraft.server.ItemStack
+            .a(((NBTTagCompound) compound))
+        );
+    }
+}
diff --git a/src/main/java/mx/kenzie/server/packet/PacketFactoryImpl.java b/src/main/java/mx/kenzie/server/packet/PacketFactoryImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..141c2ad5b634a282b7092dae50661f17d95ff401
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/packet/PacketFactoryImpl.java
@@ -0,0 +1,341 @@
+package mx.kenzie.server.packet;
+
+import com.destroystokyo.paper.network.NetworkClient;
+import com.destroystokyo.paper.network.PaperNetworkClient;
+import mx.kenzie.wellspring.conversion.Converter;
+import mx.kenzie.wellspring.packet.PacketFactory;
+import mx.kenzie.wellspring.packet.PacketType;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+import net.minecraft.server.*;
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.advancement.Advancement;
+import org.bukkit.advancement.AdvancementProgress;
+import org.bukkit.block.data.BlockData;
+import org.bukkit.craftbukkit.advancement.CraftAdvancement;
+import org.bukkit.craftbukkit.advancement.CraftAdvancementProgress;
+import org.bukkit.craftbukkit.entity.CraftEntity;
+import org.bukkit.craftbukkit.entity.CraftPlayer;
+import org.bukkit.craftbukkit.util.CraftMagicNumbers;
+import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
+import org.bukkit.entity.Player;
+
+import java.lang.reflect.Field;
+import java.lang.reflect.Modifier;
+import java.util.*;
+import java.util.concurrent.ThreadLocalRandom;
+
+import static mx.kenzie.wellspring.packet.PacketType.Incoming;
+import static mx.kenzie.wellspring.packet.PacketType.Outgoing;
+
+public class PacketFactoryImpl extends PacketFactory {
+
+    static {
+        incoming:
+        {
+            Incoming.STATUS_PING = new Incoming(PacketStatusInPing.class, PacketStatusInPing::new);
+            Incoming.STATUS_START = new Incoming(PacketStatusInStart.class, PacketStatusInStart::new);
+            Incoming.LOGIN_CUSTOM_PAYLOAD = new Incoming(PacketLoginInCustomPayload.class, PacketLoginInCustomPayload::new);
+            Incoming.ABILITIES = new Incoming(PacketPlayInAbilities.class, PacketPlayInAbilities::new);
+            Incoming.ADVANCEMENTS = new Incoming(PacketPlayInAdvancements.class, PacketPlayInAdvancements::new);
+            Incoming.ARM_ANIMATION = new Incoming(PacketPlayInArmAnimation.class, PacketPlayInArmAnimation::new);
+            Incoming.AUTO_RECIPE = new Incoming(PacketPlayInAutoRecipe.class, PacketPlayInAutoRecipe::new);
+            Incoming.BEACON = new Incoming(PacketPlayInBeacon.class, PacketPlayInBeacon::new);
+            Incoming.BOOK_EDIT = new Incoming(PacketPlayInBEdit.class, PacketPlayInBEdit::new);
+            Incoming.BLOCK_DIG = new Incoming(PacketPlayInBlockDig.class, PacketPlayInBlockDig::new);
+            Incoming.BLOCK_PLACE = new Incoming(PacketPlayInBlockPlace.class, PacketPlayInBlockPlace::new);
+            Incoming.BOAT_MOVE = new Incoming(PacketPlayInBoatMove.class, PacketPlayInBoatMove::new);
+            Incoming.CHAT = new Incoming(PacketPlayInChat.class, PacketPlayInChat::new);
+            Incoming.CLIENT_COMMAND = new Incoming(PacketPlayInClientCommand.class, PacketPlayInClientCommand::new);
+            Incoming.CLOSE_WINDOW = new Incoming(PacketPlayInCloseWindow.class, PacketPlayInCloseWindow::new);
+            Incoming.CUSTOM_PAYLOAD = new Incoming(PacketPlayInCustomPayload.class, PacketPlayInCustomPayload::new);
+            Incoming.DIFFICULTY_CHANGE = new Incoming(PacketPlayInDifficultyChange.class, PacketPlayInDifficultyChange::new);
+            Incoming.DIFFICULTY_LOCK = new Incoming(PacketPlayInDifficultyLock.class, PacketPlayInDifficultyLock::new);
+            Incoming.ENCHANT_ITEM = new Incoming(PacketPlayInEnchantItem.class, PacketPlayInEnchantItem::new);
+            Incoming.ENTITY_ACTION = new Incoming(PacketPlayInEntityAction.class, PacketPlayInEntityAction::new);
+            Incoming.ENTITY_NBT_QUERY = new Incoming(PacketPlayInEntityNBTQuery.class, PacketPlayInEntityNBTQuery::new);
+            Incoming.FLYING = new Incoming(PacketPlayInFlying.class, PacketPlayInFlying::new);
+            Incoming.HELD_ITEM_SLOT = new Incoming(PacketPlayInHeldItemSlot.class, PacketPlayInHeldItemSlot::new);
+            Incoming.ITEM_NAME = new Incoming(PacketPlayInItemName.class, PacketPlayInItemName::new);
+            Incoming.JIGSAW_GENERATE = new Incoming(PacketPlayInJigsawGenerate.class, PacketPlayInJigsawGenerate::new);
+            Incoming.KEEP_ALIVE = new Incoming(PacketPlayInKeepAlive.class, PacketPlayInKeepAlive::new);
+            Incoming.PICK_ITEM = new Incoming(PacketPlayInPickItem.class, PacketPlayInPickItem::new);
+            Incoming.RECIPE_DISPLAYED = new Incoming(PacketPlayInRecipeDisplayed.class, PacketPlayInRecipeDisplayed::new);
+            Incoming.RESOURCE_PACK_STATUS = new Incoming(PacketPlayInResourcePackStatus.class, PacketPlayInResourcePackStatus::new);
+            Incoming.SET_COMMAND_BLOCK = new Incoming(PacketPlayInSetCommandBlock.class, PacketPlayInSetCommandBlock::new);
+            Incoming.SET_COMMAND_MINECART = new Incoming(PacketPlayInSetCommandMinecart.class, PacketPlayInSetCommandMinecart::new);
+            Incoming.SET_CREATIVE_SLOT = new Incoming(PacketPlayInSetCreativeSlot.class, PacketPlayInSetCreativeSlot::new);
+            Incoming.SET_JIGSAW = new Incoming(PacketPlayInSetJigsaw.class, PacketPlayInSetJigsaw::new);
+            Incoming.SETTINGS = new Incoming(PacketPlayInSettings.class, PacketPlayInSettings::new);
+            Incoming.SPECTATE = new Incoming(PacketPlayInSpectate.class, PacketPlayInSpectate::new);
+            Incoming.STEER_VEHICLE = new Incoming(PacketPlayInSteerVehicle.class, PacketPlayInSteerVehicle::new);
+            Incoming.STRUCTURE = new Incoming(PacketPlayInStruct.class, PacketPlayInStruct::new);
+            Incoming.TAB_COMPLETE = new Incoming(PacketPlayInTabComplete.class, PacketPlayInTabComplete::new);
+            Incoming.TELEPORT_ACCEPT = new Incoming(PacketPlayInTeleportAccept.class, PacketPlayInTeleportAccept::new);
+            Incoming.TILE_NBT_QUERY = new Incoming(PacketPlayInTileNBTQuery.class, PacketPlayInTileNBTQuery::new);
+            Incoming.TRANSACTION = new Incoming(PacketPlayInTransaction.class, PacketPlayInTransaction::new);
+            Incoming.TRADE_SELECT = new Incoming(PacketPlayInTrSel.class, PacketPlayInTrSel::new);
+            Incoming.UPDATE_SIGN = new Incoming(PacketPlayInUpdateSign.class, PacketPlayInUpdateSign::new);
+            Incoming.USE_ENTITY = new Incoming(PacketPlayInUseEntity.class, PacketPlayInUseEntity::new);
+            Incoming.USE_ITEM = new Incoming(PacketPlayInUseItem.class, PacketPlayInUseItem::new);
+            Incoming.VEHICLE_MOVE = new Incoming(PacketPlayInVehicleMove.class, PacketPlayInVehicleMove::new);
+            Incoming.WINDOW_CLICK = new Incoming(PacketPlayInWindowClick.class, PacketPlayInWindowClick::new);
+        }
+        outgoing:
+        {
+            Outgoing.STATUS_PONG = new Outgoing(PacketStatusOutPong.class, PacketStatusOutPong::new);
+            Outgoing.STATUS_SERVER_INFO = new Outgoing(PacketStatusOutServerInfo.class, PacketStatusOutServerInfo::new);
+            Outgoing.LOGIN_CUSTOM_PAYLOAD = new Outgoing(PacketLoginOutCustomPayload.class, PacketLoginOutCustomPayload::new);
+            Outgoing.ABILITIES = new Outgoing(PacketPlayOutAbilities.class, PacketPlayOutAbilities::new);
+            Outgoing.ADVANCEMENTS = new Outgoing(PacketPlayOutAdvancements.class, PacketPlayOutAdvancements::new);
+            Outgoing.ANIMATION = new Outgoing(PacketPlayOutAnimation.class, PacketPlayOutAnimation::new);
+            Outgoing.ATTACH_ENTITY = new Outgoing(PacketPlayOutAttachEntity.class, PacketPlayOutAttachEntity::new);
+            Outgoing.AUTO_RECIPE = new Outgoing(PacketPlayOutAutoRecipe.class, PacketPlayOutAutoRecipe::new);
+            Outgoing.BLOCK_ACTION = new Outgoing(PacketPlayOutBlockAction.class, PacketPlayOutBlockAction::new);
+            Outgoing.BLOCK_BREAK = new Outgoing(PacketPlayOutBlockBreak.class, PacketPlayOutBlockBreak::new);
+            Outgoing.BLOCK_BREAK_ANIMATION = new Outgoing(PacketPlayOutBlockBreakAnimation.class, PacketPlayOutBlockBreakAnimation::new);
+            Outgoing.BLOCK_CHANGE = new Outgoing(PacketPlayOutBlockChange.class, PacketPlayOutBlockChange::new);
+            Outgoing.BOSS = new Outgoing(PacketPlayOutBoss.class, PacketPlayOutBoss::new);
+            Outgoing.CAMERA = new Outgoing(PacketPlayOutCamera.class, PacketPlayOutCamera::new);
+            Outgoing.CHAT = new Outgoing(PacketPlayOutChat.class, PacketPlayOutChat::new);
+            Outgoing.CLOSE_WINDOW = new Outgoing(PacketPlayOutCloseWindow.class, PacketPlayOutCloseWindow::new);
+            Outgoing.COLLECT = new Outgoing(PacketPlayOutCollect.class, PacketPlayOutCollect::new);
+            Outgoing.COMBAT_EVENT = new Outgoing(PacketPlayOutCombatEvent.class, PacketPlayOutCombatEvent::new);
+            Outgoing.COMMANDS = new Outgoing(PacketPlayOutCommands.class, PacketPlayOutCommands::new);
+            Outgoing.CUSTOM_PAYLOAD = new Outgoing(PacketPlayOutCustomPayload.class, PacketPlayOutCustomPayload::new);
+            Outgoing.CUSTOM_SOUND_EFFECT = new Outgoing(PacketPlayOutCustomSoundEffect.class, PacketPlayOutCustomSoundEffect::new);
+            Outgoing.ENTITY = new Outgoing(PacketPlayOutEntity.class, PacketPlayOutEntity::new);
+            Outgoing.ENTITY_DESTROY = new Outgoing(PacketPlayOutEntityDestroy.class, PacketPlayOutEntityDestroy::new);
+            Outgoing.ENTITY_EFFECT = new Outgoing(PacketPlayOutEntityEffect.class, PacketPlayOutEntityEffect::new);
+            Outgoing.ENTITY_EQUIPMENT = new Outgoing(PacketPlayOutEntityEquipment.class, PacketPlayOutEntityEquipment::new);
+            Outgoing.ENTITY_HEAD_ROTATION = new Outgoing(PacketPlayOutEntityHeadRotation.class, PacketPlayOutEntityHeadRotation::new);
+            Outgoing.ENTITY_METADATA = new Outgoing(PacketPlayOutEntityMetadata.class, PacketPlayOutEntityMetadata::new);
+            Outgoing.ENTITY_SOUND = new Outgoing(PacketPlayOutEntitySound.class, PacketPlayOutEntitySound::new);
+            Outgoing.ENTITY_STATUS = new Outgoing(PacketPlayOutEntityStatus.class, PacketPlayOutEntityStatus::new);
+            Outgoing.ENTITY_TELEPORT = new Outgoing(PacketPlayOutEntityTeleport.class, PacketPlayOutEntityTeleport::new);
+            Outgoing.ENTITY_VELOCITY = new Outgoing(PacketPlayOutEntityVelocity.class, PacketPlayOutEntityVelocity::new);
+            Outgoing.ENTITY_LOOK = new Outgoing(PacketPlayOutEntity.PacketPlayOutEntityLook.class, PacketPlayOutEntity.PacketPlayOutEntityLook::new);
+            Outgoing.EXPERIENCE = new Outgoing(PacketPlayOutExperience.class, PacketPlayOutExperience::new);
+            Outgoing.EXPLOSION = new Outgoing(PacketPlayOutExplosion.class, PacketPlayOutExplosion::new);
+            Outgoing.GAME_STATE_CHANGE = new Outgoing(PacketPlayOutGameStateChange.class, PacketPlayOutGameStateChange::new);
+            Outgoing.HELD_ITEM_SLOT = new Outgoing(PacketPlayOutHeldItemSlot.class, PacketPlayOutHeldItemSlot::new);
+            Outgoing.KEEP_ALIVE = new Outgoing(PacketPlayOutKeepAlive.class, PacketPlayOutKeepAlive::new);
+            Outgoing.KICK_DISCONNECT = new Outgoing(PacketPlayOutKickDisconnect.class, PacketPlayOutKickDisconnect::new);
+            Outgoing.LIGHT_UPDATE = new Outgoing(PacketPlayOutLightUpdate.class, PacketPlayOutLightUpdate::new);
+            Outgoing.LOGIN = new Outgoing(PacketPlayOutLogin.class, PacketPlayOutLogin::new);
+            Outgoing.LOOK_AT = new Outgoing(PacketPlayOutLookAt.class, PacketPlayOutLookAt::new);
+            Outgoing.MAP = new Outgoing(PacketPlayOutMap.class, PacketPlayOutMap::new);
+            Outgoing.MAP_CHUNK = new Outgoing(PacketPlayOutMapChunk.class, PacketPlayOutMapChunk::new);
+            Outgoing.MOUNT = new Outgoing(PacketPlayOutMount.class, PacketPlayOutMount::new);
+            Outgoing.MULTI_BLOCK_CHANGE = new Outgoing(PacketPlayOutMultiBlockChange.class, PacketPlayOutMultiBlockChange::new);
+            Outgoing.NAMED_ENTITY_SPAWN = new Outgoing(PacketPlayOutNamedEntitySpawn.class, PacketPlayOutNamedEntitySpawn::new);
+            Outgoing.NAMED_SOUND_EFFECT = new Outgoing(PacketPlayOutNamedSoundEffect.class, PacketPlayOutNamedSoundEffect::new);
+            Outgoing.NBT_QUERY = new Outgoing(PacketPlayOutNBTQuery.class, PacketPlayOutNBTQuery::new);
+            Outgoing.OPEN_BOOK = new Outgoing(PacketPlayOutOpenBook.class, PacketPlayOutOpenBook::new);
+            Outgoing.OPEN_SIGN_EDITOR = new Outgoing(PacketPlayOutOpenSignEditor.class, PacketPlayOutOpenSignEditor::new);
+            Outgoing.OPEN_WINDOW = new Outgoing(PacketPlayOutOpenWindow.class, PacketPlayOutOpenWindow::new);
+            Outgoing.OPEN_WINDOW_HORSE = new Outgoing(PacketPlayOutOpenWindowHorse.class, PacketPlayOutOpenWindowHorse::new);
+            Outgoing.OPEN_WINDOW_MERCHANT = new Outgoing(PacketPlayOutOpenWindowMerchant.class, PacketPlayOutOpenWindowMerchant::new);
+            Outgoing.PLAYER_INFO = new Outgoing(PacketPlayOutPlayerInfo.class, PacketPlayOutPlayerInfo::new);
+            Outgoing.PLAYER_LIST_HEADER_FOOTER = new Outgoing(PacketPlayOutPlayerListHeaderFooter.class, PacketPlayOutPlayerListHeaderFooter::new);
+            Outgoing.POSITION = new Outgoing(PacketPlayOutPosition.class, PacketPlayOutPosition::new);
+            Outgoing.RECIPES = new Outgoing(PacketPlayOutRecipes.class, PacketPlayOutRecipes::new);
+            Outgoing.RECIPE_UPDATE = new Outgoing(PacketPlayOutRecipeUpdate.class, PacketPlayOutRecipeUpdate::new);
+            Outgoing.REMOVE_ENTITY_EFFECT = new Outgoing(PacketPlayOutRemoveEntityEffect.class, PacketPlayOutRemoveEntityEffect::new);
+            Outgoing.RESOURCE_PACK = new Outgoing(PacketPlayOutResourcePackSend.class, PacketPlayOutResourcePackSend::new);
+            Outgoing.RESPAWN = new Outgoing(PacketPlayOutRespawn.class, PacketPlayOutRespawn::new);
+            Outgoing.SCOREBOARD_DISPLAY_OBJECTIVE = new Outgoing(PacketPlayOutScoreboardDisplayObjective.class, PacketPlayOutScoreboardDisplayObjective::new);
+            Outgoing.SCOREBOARD_OBJECTIVE = new Outgoing(PacketPlayOutScoreboardObjective.class, PacketPlayOutScoreboardObjective::new);
+            Outgoing.SCOREBOARD_SCORE = new Outgoing(PacketPlayOutScoreboardScore.class, PacketPlayOutScoreboardScore::new);
+            Outgoing.SCOREBOARD_TEAM = new Outgoing(PacketPlayOutScoreboardTeam.class, PacketPlayOutScoreboardTeam::new);
+            Outgoing.SELECT_ADVANCEMENT_TAV = new Outgoing(PacketPlayOutSelectAdvancementTab.class, PacketPlayOutSelectAdvancementTab::new);
+            Outgoing.SERVER_DIFFICULTY = new Outgoing(PacketPlayOutServerDifficulty.class, PacketPlayOutServerDifficulty::new);
+            Outgoing.SET_COOLDOWN = new Outgoing(PacketPlayOutSetCooldown.class, PacketPlayOutSetCooldown::new);
+            Outgoing.SET_SLOT = new Outgoing(PacketPlayOutSetSlot.class, PacketPlayOutSetSlot::new);
+            Outgoing.SPAWN_ENTITY = new Outgoing(PacketPlayOutSpawnEntity.class, PacketPlayOutSpawnEntity::new);
+            Outgoing.SPAWN_EXPERIENCE = new Outgoing(PacketPlayOutSpawnEntityExperienceOrb.class, PacketPlayOutSpawnEntityExperienceOrb::new);
+            Outgoing.SPAWN_LIVING_ENTITY = new Outgoing(PacketPlayOutSpawnEntityLiving.class, PacketPlayOutSpawnEntityLiving::new);
+            Outgoing.SPAWN_PAINTING = new Outgoing(PacketPlayOutSpawnEntityPainting.class, PacketPlayOutSpawnEntityPainting::new);
+            Outgoing.SPAWN_POSITION = new Outgoing(PacketPlayOutSpawnPosition.class, PacketPlayOutSpawnPosition::new);
+            Outgoing.STATISTIC = new Outgoing(PacketPlayOutStatistic.class, PacketPlayOutStatistic::new);
+            Outgoing.STOP_SOUND = new Outgoing(PacketPlayOutStopSound.class, PacketPlayOutStopSound::new);
+            Outgoing.TAB_COMPLETE = new Outgoing(PacketPlayOutTabComplete.class, PacketPlayOutTabComplete::new);
+            Outgoing.TAGS = new Outgoing(PacketPlayOutTags.class, PacketPlayOutTags::new);
+            Outgoing.TILE_ENTITY_DATA = new Outgoing(PacketPlayOutTileEntityData.class, PacketPlayOutTileEntityData::new);
+            Outgoing.TITLE = new Outgoing(PacketPlayOutTitle.class, PacketPlayOutTitle::new);
+            Outgoing.TRANSACTION = new Outgoing(PacketPlayOutTransaction.class, PacketPlayOutTransaction::new);
+            Outgoing.UNLOAD_CHUNK = new Outgoing(PacketPlayOutUnloadChunk.class, PacketPlayOutUnloadChunk::new);
+            Outgoing.UPDATE_ATTRIBUTES = new Outgoing(PacketPlayOutUpdateAttributes.class, PacketPlayOutUpdateAttributes::new);
+            Outgoing.UPDATE_HEALTH = new Outgoing(PacketPlayOutUpdateHealth.class, PacketPlayOutUpdateHealth::new);
+            Outgoing.UPDATE_TIME = new Outgoing(PacketPlayOutUpdateTime.class, PacketPlayOutUpdateTime::new);
+            Outgoing.VEHICLE_MOVE = new Outgoing(PacketPlayOutVehicleMove.class, PacketPlayOutVehicleMove::new);
+            Outgoing.VIEW_CENTRE = new Outgoing(PacketPlayOutViewCentre.class, PacketPlayOutViewCentre::new);
+            Outgoing.VIEW_DISTANCE = new Outgoing(PacketPlayOutViewDistance.class, PacketPlayOutViewDistance::new);
+            Outgoing.WINDOW_DATA = new Outgoing(PacketPlayOutWindowData.class, PacketPlayOutWindowData::new);
+            Outgoing.WINDOW_ITEMS = new Outgoing(PacketPlayOutWindowItems.class, PacketPlayOutWindowItems::new);
+            Outgoing.WORLD_BORDER = new Outgoing(PacketPlayOutWorldBorder.class, PacketPlayOutWorldBorder::new);
+            Outgoing.WORLD_EVENT = new Outgoing(PacketPlayOutWorldEvent.class, PacketPlayOutWorldEvent::new);
+            Outgoing.WORLD_PARTICLES = new Outgoing(PacketPlayOutWorldParticles.class, PacketPlayOutWorldParticles::new);
+        }
+    }
+
+    @SuppressWarnings("all")
+    public PacketFactoryImpl() {
+        converters: {
+            registerConverter(type -> IRegistry.ENTITY_TYPE.get(MinecraftKey.a(type.getKey().toString())), EntityType.class, EntityTypes.class);
+            registerConverter(type -> EntityType.fromName(IRegistry.ENTITY_TYPE.getKey(type).getKey()), EntityTypes.class, EntityType.class);
+        }
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet statusOutPong(long ms) {
+        return new PacketStatusOutPong(ms);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet statusOutOutServerInfo(BaseComponent[] motd, int online, int maxPlayers, String version, int protocol, String icon) {
+        ServerPing ping = new ServerPing();
+        IChatMutableComponent component = IChatBaseComponent.ChatSerializer.a(ComponentSerializer.toString(motd));
+        ping.setMOTD(component);
+        ping.setPlayerSample(new ServerPing.ServerPingPlayerSample(maxPlayers, online));
+        ping.setServerInfo(new ServerPing.ServerData(version, protocol));
+        if (icon != null) ping.setFavicon(icon);
+        return new PacketStatusOutServerInfo(ping);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet loginOutCustomPayload() {
+        return new PacketLoginInCustomPayload();
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutAbilities(boolean invulnerable, boolean flying, boolean canFly, boolean canInstantlyBuild, float flySpeed, float walkSpeed) {
+        PlayerAbilities abilities = new PlayerAbilities();
+        abilities.isInvulnerable = invulnerable;
+        abilities.isFlying = flying;
+        abilities.canFly = canFly;
+        abilities.canInstantlyBuild = canInstantlyBuild;
+        abilities.flySpeed = flySpeed;
+        abilities.walkSpeed = walkSpeed;
+        return new PacketPlayOutAbilities(abilities);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutAdvancements(boolean reset, Collection<Advancement> toAdd, Set<NamespacedKey> toRemove, Map<NamespacedKey, AdvancementProgress> progress) {
+        List<net.minecraft.server.Advancement> adding = new ArrayList<>();
+        for (Advancement advancement : toAdd) {
+            adding.add(((CraftAdvancement) advancement).getHandle());
+        }
+        Set<MinecraftKey> removing = new HashSet<>();
+        for (NamespacedKey key : toRemove) {
+            removing.add(new MinecraftKey(key.toString()));
+        }
+        Map<MinecraftKey, net.minecraft.server.AdvancementProgress> progressing = new HashMap<>();
+        for (Map.Entry<NamespacedKey, AdvancementProgress> entry : progress.entrySet()) {
+            progressing.put(new MinecraftKey(entry.getKey().toString()), ((CraftAdvancementProgress) entry.getValue()).getHandle());
+        }
+        return new PacketPlayOutAdvancements(reset, adding, removing, progressing);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutAnimation(Entity entity, int animationId) {
+        return new PacketPlayOutAnimation(((CraftEntity) entity).getHandle(), animationId);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutAttachEntity(Entity target, Entity holder) {
+        return new PacketPlayOutAttachEntity(((CraftEntity) target).getHandle(), holder != null ? ((CraftEntity) holder).getHandle() : null);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutAutoRecipe(int container, NamespacedKey recipe) {
+        PacketPlayOutAutoRecipe packet = new PacketPlayOutAutoRecipe();
+        try {
+            Field id = PacketPlayOutAutoRecipe.class.getDeclaredField("a");
+            Field key = PacketPlayOutAutoRecipe.class.getDeclaredField("b");
+            id.setAccessible(true);
+            key.setAccessible(true);
+            id.set(packet, container);
+            key.set(packet, new MinecraftKey(recipe.toString()));
+        } catch (Throwable e) {
+            e.printStackTrace();
+        }
+        return packet;
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutBlockAction(Location location, BlockData data, int action, int parameter) {
+        BlockPosition position = new BlockPosition(location.getX(), location.getY(), location.getZ());
+        Block block = CraftMagicNumbers.getBlock(data.getMaterial());
+        return new PacketPlayOutBlockAction(position, block, action, parameter);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutSpawnEntity(EntityType type, Location location) {
+        int id = 10000 + ThreadLocalRandom.current().nextInt(1000000);
+        UUID uuid = UUID.randomUUID();
+        return playOutSpawnEntity(type, location, id, uuid);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutSpawnEntity(EntityType type, Location location, int id, UUID uuid) {
+        EntityTypes<?> types = IRegistry.ENTITY_TYPE.get(new MinecraftKey(type.getKey().toString()));
+        return new PacketPlayOutSpawnEntity(id, uuid, location.getX(), location.getY(), location.getZ(), location.getPitch(), location.getYaw(), types, 0, new Vec3D(0, 0, 0));
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutSpawnLivingEntity(EntityType type, Location location) {
+        int id = 10000 + ThreadLocalRandom.current().nextInt(1000000);
+        UUID uuid = UUID.randomUUID();
+        return playOutSpawnLivingEntity(type, location, id, uuid, 0, 0, 0);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutSpawnLivingEntity(EntityType type, Location location, int id, UUID uuid) {
+        return playOutSpawnLivingEntity(type, location, id, uuid, 0, 0, 0);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet playOutSpawnLivingEntity(EntityType type, Location location, int id, UUID uuid, float yaw, float pitch, float headRotation) {
+        EntityTypes<?> types = IRegistry.ENTITY_TYPE.get(new MinecraftKey(type.getKey().toString()));
+        int typeId = IRegistry.ENTITY_TYPE.a(types);
+        return new PacketPlayOutSpawnEntityLiving(id, uuid, typeId, location.getX(), location.getY(), location.getZ(), new Vec3D(0, 0, 0), yaw, pitch, headRotation);
+    }
+
+    @Override
+    public mx.kenzie.wellspring.packet.Packet createFrom(PacketType type, Object... fieldInputs) {
+        try {
+            mx.kenzie.wellspring.packet.Packet packet = (mx.kenzie.wellspring.packet.Packet) type.getConstructor().create();
+            List<Field> sample = Arrays.asList(packet.getClass().getDeclaredFields());
+            sample.removeIf(field -> (Modifier.isStatic(field.getModifiers())));
+            final Field[] fields = packet.getClass().getDeclaredFields();
+            for (int i = 0; i < fieldInputs.length; i++) {
+                if ((fields.length) <= i) break;
+                if (Modifier.isStatic(fields[i].getModifiers())) {
+                    i--;
+                    continue;
+                }
+                fields[i].setAccessible(true);
+                fields[i].set(packet, fieldInputs[i]);
+            }
+            return packet;
+        } catch (IllegalAccessException e) {
+            throw new IllegalArgumentException("Unable to create packet: ", e);
+        }
+    }
+
+    @Override
+    public void send(mx.kenzie.wellspring.packet.Packet packet, NetworkClient... recipients) throws IllegalArgumentException {
+        for (NetworkClient recipient : recipients) {
+            if (recipient instanceof CraftPlayer) {
+                CraftPlayer player = ((CraftPlayer) recipient);
+                player.getHandle().playerConnection.networkManager.sendPacket((net.minecraft.server.Packet<?>) packet);
+            } else if (recipient instanceof PaperNetworkClient) {
+                PaperNetworkClient client = (PaperNetworkClient) recipient;
+                client.getNetworkManager().sendPacket((net.minecraft.server.Packet<?>) packet);
+            }
+        }
+    }
+}
diff --git a/src/main/java/mx/kenzie/server/potion/PotionBuilderImpl.java b/src/main/java/mx/kenzie/server/potion/PotionBuilderImpl.java
new file mode 100644
index 0000000000000000000000000000000000000000..9187dd9c31f8a978d2d3a8c8c40726e20424ab4c
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/potion/PotionBuilderImpl.java
@@ -0,0 +1,107 @@
+package mx.kenzie.server.potion;
+
+import mx.kenzie.wellspring.potion.PotionBuilder;
+import mx.kenzie.wellspring.potion.PotionType;
+import net.minecraft.server.AttributeBase;
+import net.minecraft.server.IRegistry;
+import net.minecraft.server.MinecraftKey;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.attribute.AttributeModifier;
+import org.bukkit.entity.LivingEntity;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.potion.PotionEffectType;
+
+import java.awt.*;
+import java.util.Map;
+import java.util.function.BiConsumer;
+
+public class PotionBuilderImpl extends PotionBuilder {
+
+    protected int color = 0;
+    protected PotionType type = PotionType.NEUTRAL;
+    protected BiConsumer<LivingEntity, Integer> consumer;
+
+    public PotionBuilderImpl(NamespacedKey key, String name) {
+        super(key, name);
+    }
+
+    private static AttributeBase convert(Attribute attribute) {
+        return IRegistry.ATTRIBUTE.get(new MinecraftKey(attribute.getKey().toString()));
+    }
+
+    @Override
+    public PotionBuilder setColor(Color color) {
+        this.color = color.getRGB();
+        return this;
+    }
+
+    @Override
+    public PotionBuilder setType(PotionType type) {
+        this.type = type;
+        return this;
+    }
+
+    @Override
+    public PotionBuilder setTickConsumer(BiConsumer<LivingEntity, Integer> consumer) {
+        this.consumer = consumer;
+        return this;
+    }
+
+    @Override
+    public void register(Plugin plugin) {
+        final int index = key.toString().hashCode();
+        register(plugin, index);
+    }
+
+    @Override
+    public void register(Plugin plugin, int id) {
+        final TickingMobEffect effect = new TickingMobEffect(type, color, consumer);
+        if (attributes.size() > 0) {
+            for (Map.Entry<Attribute, AttributeModifier> entry : attributes.entrySet()) {
+                effect.a(convert(entry.getKey()), entry.getValue().getUniqueId().toString(), entry.getValue().getAmount(), convertOperation(entry.getValue()));
+            }
+        }
+        final int index = plugin.getName().hashCode() + id;
+        final PotionEffectType type;
+        final Color col = new Color(color);
+        final org.bukkit.Color color = org.bukkit.Color.fromRGB(col.getRed(), col.getGreen(), col.getBlue());
+        IRegistry.a(IRegistry.MOB_EFFECT, index, key.toString(), effect);
+        type = new PotionEffectType(index) {
+            @Override
+            public double getDurationModifier() {
+                return 1.0D;
+            }
+
+            @Override
+            public String getName() {
+                return name;
+            }
+
+            @Override
+            public boolean isInstant() {
+                return instant;
+            }
+
+            @Override
+            public int getId() {
+                return index;
+            }
+
+            @Override
+            public org.bukkit.Color getColor() {
+                return color;
+            }
+        };
+        PotionEffectType.registerPotion(key, type, plugin);
+    }
+
+    private net.minecraft.server.AttributeModifier.Operation convertOperation(AttributeModifier modifier) {
+        if (modifier.getOperation() == org.bukkit.attribute.AttributeModifier.Operation.ADD_SCALAR)
+            return net.minecraft.server.AttributeModifier.Operation.MULTIPLY_BASE;
+        if (modifier.getOperation() == org.bukkit.attribute.AttributeModifier.Operation.MULTIPLY_SCALAR_1)
+            return net.minecraft.server.AttributeModifier.Operation.MULTIPLY_TOTAL;
+        return net.minecraft.server.AttributeModifier.Operation.ADDITION;
+    }
+
+}
diff --git a/src/main/java/mx/kenzie/server/potion/TickingMobEffect.java b/src/main/java/mx/kenzie/server/potion/TickingMobEffect.java
new file mode 100644
index 0000000000000000000000000000000000000000..47e0be28afcf382ba9167f3db0c1a45e8e0e532d
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/potion/TickingMobEffect.java
@@ -0,0 +1,53 @@
+package mx.kenzie.server.potion;
+
+import mx.kenzie.wellspring.potion.PotionType;
+import net.minecraft.server.EntityLiving;
+import net.minecraft.server.MobEffectInfo;
+import net.minecraft.server.MobEffectList;
+import org.bukkit.entity.LivingEntity;
+
+import java.awt.*;
+import java.util.function.BiConsumer;
+
+public class TickingMobEffect extends MobEffectList {
+
+    public BiConsumer<LivingEntity, Integer> consumer;
+
+    public TickingMobEffect(MobEffectInfo info, Color color) {
+        this(info, color.getRGB());
+    }
+
+    public TickingMobEffect(PotionType type, int color, BiConsumer<LivingEntity, Integer> consumer) {
+        this(convert(type), color);
+        this.consumer = consumer;
+    }
+
+    public TickingMobEffect(PotionType type, int color) {
+        this(convert(type), color);
+    }
+
+    protected TickingMobEffect(MobEffectInfo mobeffectinfo, int i) {
+        super(mobeffectinfo, i);
+        consumer = null;
+    }
+
+    private static MobEffectInfo convert(PotionType type) {
+        if (type == PotionType.BENEFICIAL) return MobEffectInfo.BENEFICIAL;
+        if (type == PotionType.HARMFUL) return MobEffectInfo.HARMFUL;
+        return MobEffectInfo.NEUTRAL;
+    }
+
+    @Override
+    public boolean a(int i, int j) {
+        return true;
+    }
+
+    @Override
+    public void tick(EntityLiving entityliving, int i) {
+        super.tick(entityliving, i);
+        if (consumer != null) {
+            consumer.accept(entityliving.getBukkitLivingEntity(), i);
+        }
+    }
+
+}
diff --git a/src/main/java/mx/kenzie/server/structure/Structure.java b/src/main/java/mx/kenzie/server/structure/Structure.java
new file mode 100644
index 0000000000000000000000000000000000000000..18450b649f46babfb1f44e34b8504cc93b74cc7f
--- /dev/null
+++ b/src/main/java/mx/kenzie/server/structure/Structure.java
@@ -0,0 +1,45 @@
+package mx.kenzie.server.structure;
+
+import net.minecraft.server.EnumBlockMirror;
+import net.minecraft.server.EnumBlockRotation;
+import net.minecraft.server.StructureBoundingBox;
+import org.bukkit.block.structure.Mirror;
+import org.bukkit.block.structure.StructureRotation;
+
+public abstract class Structure implements mx.kenzie.wellspring.structure.Structure {
+
+    public Structure() {
+
+    }
+
+    void blob() {
+    }
+
+    public static EnumBlockRotation convert(StructureRotation rotation) {
+        switch (rotation) {
+            case NONE:
+                return EnumBlockRotation.NONE;
+            case CLOCKWISE_90:
+                return EnumBlockRotation.CLOCKWISE_90;
+            case CLOCKWISE_180:
+                return EnumBlockRotation.CLOCKWISE_180;
+            case COUNTERCLOCKWISE_90:
+                return EnumBlockRotation.COUNTERCLOCKWISE_90;
+        }
+        return EnumBlockRotation.NONE;
+    }
+
+    public static EnumBlockMirror convert(Mirror mirror) {
+        switch (mirror) {
+            case NONE:
+                return EnumBlockMirror.NONE;
+            case FRONT_BACK:
+                return EnumBlockMirror.FRONT_BACK;
+            case LEFT_RIGHT:
+                return EnumBlockMirror.LEFT_RIGHT;
+        }
+        return EnumBlockMirror.NONE;
+    }
+
+
+}
diff --git a/src/main/java/net/minecraft/server/AttributeDefaults.java b/src/main/java/net/minecraft/server/AttributeDefaults.java
index da66cf0a459f06124f5f4615a5e47241865b10a9..1e2a3c32ceffb97b89306bf5562ec4a997152d1e 100644
--- a/src/main/java/net/minecraft/server/AttributeDefaults.java
+++ b/src/main/java/net/minecraft/server/AttributeDefaults.java
@@ -1,6 +1,8 @@
 package net.minecraft.server;
 
 import com.google.common.collect.ImmutableMap;
+
+import java.util.HashMap;
 import java.util.Map;
 import java.util.stream.Stream;
 import org.apache.logging.log4j.LogManager;
@@ -9,10 +11,20 @@ import org.apache.logging.log4j.Logger;
 public class AttributeDefaults {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private static final Map<EntityTypes<? extends EntityLiving>, AttributeProvider> b = ImmutableMap.builder().put(EntityTypes.ARMOR_STAND, EntityLiving.cK().a()).put(EntityTypes.BAT, EntityBat.m().a()).put(EntityTypes.BEE, EntityBee.eZ().a()).put(EntityTypes.BLAZE, EntityBlaze.m().a()).put(EntityTypes.CAT, EntityCat.fa().a()).put(EntityTypes.CAVE_SPIDER, EntityCaveSpider.m().a()).put(EntityTypes.CHICKEN, EntityChicken.eK().a()).put(EntityTypes.COD, EntityFish.m().a()).put(EntityTypes.COW, EntityCow.eK().a()).put(EntityTypes.CREEPER, EntityCreeper.m().a()).put(EntityTypes.DOLPHIN, EntityDolphin.eM().a()).put(EntityTypes.DONKEY, EntityHorseChestedAbstract.eL().a()).put(EntityTypes.DROWNED, EntityZombie.eS().a()).put(EntityTypes.ELDER_GUARDIAN, EntityGuardianElder.m().a()).put(EntityTypes.ENDERMAN, EntityEnderman.m().a()).put(EntityTypes.ENDERMITE, EntityEndermite.m().a()).put(EntityTypes.ENDER_DRAGON, EntityEnderDragon.m().a()).put(EntityTypes.EVOKER, EntityEvoker.eK().a()).put(EntityTypes.FOX, EntityFox.eK().a()).put(EntityTypes.GHAST, EntityGhast.eJ().a()).put(EntityTypes.GIANT, EntityGiantZombie.m().a()).put(EntityTypes.GUARDIAN, EntityGuardian.eM().a()).put(EntityTypes.HOGLIN, EntityHoglin.eK().a()).put(EntityTypes.HORSE, EntityHorseAbstract.fi().a()).put(EntityTypes.HUSK, EntityZombie.eS().a()).put(EntityTypes.ILLUSIONER, EntityIllagerIllusioner.eK().a()).put(EntityTypes.IRON_GOLEM, EntityIronGolem.m().a()).put(EntityTypes.LLAMA, EntityLlama.fw().a()).put(EntityTypes.MAGMA_CUBE, EntityMagmaCube.m().a()).put(EntityTypes.MOOSHROOM, EntityCow.eK().a()).put(EntityTypes.MULE, EntityHorseChestedAbstract.eL().a()).put(EntityTypes.OCELOT, EntityOcelot.eK().a()).put(EntityTypes.PANDA, EntityPanda.eY().a()).put(EntityTypes.PARROT, EntityParrot.eU().a()).put(EntityTypes.PHANTOM, EntityMonster.eR().a()).put(EntityTypes.PIG, EntityPig.eK().a()).put(EntityTypes.PIGLIN, EntityPiglin.eT().a()).put(EntityTypes.PIGLIN_BRUTE, EntityPiglinBrute.eS().a()).put(EntityTypes.PILLAGER, EntityPillager.eK().a()).put(EntityTypes.PLAYER, EntityHuman.eo().a()).put(EntityTypes.POLAR_BEAR, EntityPolarBear.eK().a()).put(EntityTypes.PUFFERFISH, EntityFish.m().a()).put(EntityTypes.RABBIT, EntityRabbit.eL().a()).put(EntityTypes.RAVAGER, EntityRavager.m().a()).put(EntityTypes.SALMON, EntityFish.m().a()).put(EntityTypes.SHEEP, EntitySheep.eK().a()).put(EntityTypes.SHULKER, EntityShulker.m().a()).put(EntityTypes.SILVERFISH, EntitySilverfish.m().a()).put(EntityTypes.SKELETON, EntitySkeletonAbstract.m().a()).put(EntityTypes.SKELETON_HORSE, EntityHorseSkeleton.eL().a()).put(EntityTypes.SLIME, EntityMonster.eR().a()).put(EntityTypes.SNOW_GOLEM, EntitySnowman.m().a()).put(EntityTypes.SPIDER, EntitySpider.eK().a()).put(EntityTypes.SQUID, EntitySquid.m().a()).put(EntityTypes.STRAY, EntitySkeletonAbstract.m().a()).put(EntityTypes.STRIDER, EntityStrider.eM().a()).put(EntityTypes.TRADER_LLAMA, EntityLlama.fw().a()).put(EntityTypes.TROPICAL_FISH, EntityFish.m().a()).put(EntityTypes.TURTLE, EntityTurtle.eM().a()).put(EntityTypes.VEX, EntityVex.m().a()).put(EntityTypes.VILLAGER, EntityVillager.eY().a()).put(EntityTypes.VINDICATOR, EntityVindicator.eK().a()).put(EntityTypes.WANDERING_TRADER, EntityInsentient.p().a()).put(EntityTypes.WITCH, EntityWitch.eK().a()).put(EntityTypes.WITHER, EntityWither.eK().a()).put(EntityTypes.WITHER_SKELETON, EntitySkeletonAbstract.m().a()).put(EntityTypes.WOLF, EntityWolf.eU().a()).put(EntityTypes.ZOGLIN, EntityZoglin.m().a()).put(EntityTypes.ZOMBIE, EntityZombie.eS().a()).put(EntityTypes.ZOMBIE_HORSE, EntityHorseZombie.eL().a()).put(EntityTypes.ZOMBIE_VILLAGER, EntityZombie.eS().a()).put(EntityTypes.ZOMBIFIED_PIGLIN, EntityPigZombie.eW().a()).build();
+    // Kenzie - make mutable for subsequent access
+    private static final Map<EntityTypes<? extends EntityLiving>, AttributeProvider> b = new HashMap<>(ImmutableMap.<EntityTypes<? extends EntityLiving>, AttributeProvider>builder().put(EntityTypes.ARMOR_STAND, EntityLiving.cK().a()).put(EntityTypes.BAT, EntityBat.m().a()).put(EntityTypes.BEE, EntityBee.eZ().a()).put(EntityTypes.BLAZE, EntityBlaze.m().a()).put(EntityTypes.CAT, EntityCat.fa().a()).put(EntityTypes.CAVE_SPIDER, EntityCaveSpider.m().a()).put(EntityTypes.CHICKEN, EntityChicken.eK().a()).put(EntityTypes.COD, EntityFish.m().a()).put(EntityTypes.COW, EntityCow.eK().a()).put(EntityTypes.CREEPER, EntityCreeper.m().a()).put(EntityTypes.DOLPHIN, EntityDolphin.eM().a()).put(EntityTypes.DONKEY, EntityHorseChestedAbstract.eL().a()).put(EntityTypes.DROWNED, EntityZombie.eS().a()).put(EntityTypes.ELDER_GUARDIAN, EntityGuardianElder.m().a()).put(EntityTypes.ENDERMAN, EntityEnderman.m().a()).put(EntityTypes.ENDERMITE, EntityEndermite.m().a()).put(EntityTypes.ENDER_DRAGON, EntityEnderDragon.m().a()).put(EntityTypes.EVOKER, EntityEvoker.eK().a()).put(EntityTypes.FOX, EntityFox.eK().a()).put(EntityTypes.GHAST, EntityGhast.eJ().a()).put(EntityTypes.GIANT, EntityGiantZombie.m().a()).put(EntityTypes.GUARDIAN, EntityGuardian.eM().a()).put(EntityTypes.HOGLIN, EntityHoglin.eK().a()).put(EntityTypes.HORSE, EntityHorseAbstract.fi().a()).put(EntityTypes.HUSK, EntityZombie.eS().a()).put(EntityTypes.ILLUSIONER, EntityIllagerIllusioner.eK().a()).put(EntityTypes.IRON_GOLEM, EntityIronGolem.m().a()).put(EntityTypes.LLAMA, EntityLlama.fw().a()).put(EntityTypes.MAGMA_CUBE, EntityMagmaCube.m().a()).put(EntityTypes.MOOSHROOM, EntityCow.eK().a()).put(EntityTypes.MULE, EntityHorseChestedAbstract.eL().a()).put(EntityTypes.OCELOT, EntityOcelot.eK().a()).put(EntityTypes.PANDA, EntityPanda.eY().a()).put(EntityTypes.PARROT, EntityParrot.eU().a()).put(EntityTypes.PHANTOM, EntityMonster.eR().a()).put(EntityTypes.PIG, EntityPig.eK().a()).put(EntityTypes.PIGLIN, EntityPiglin.eT().a()).put(EntityTypes.PIGLIN_BRUTE, EntityPiglinBrute.eS().a()).put(EntityTypes.PILLAGER, EntityPillager.eK().a()).put(EntityTypes.PLAYER, EntityHuman.eo().a()).put(EntityTypes.POLAR_BEAR, EntityPolarBear.eK().a()).put(EntityTypes.PUFFERFISH, EntityFish.m().a()).put(EntityTypes.RABBIT, EntityRabbit.eL().a()).put(EntityTypes.RAVAGER, EntityRavager.m().a()).put(EntityTypes.SALMON, EntityFish.m().a()).put(EntityTypes.SHEEP, EntitySheep.eK().a()).put(EntityTypes.SHULKER, EntityShulker.m().a()).put(EntityTypes.SILVERFISH, EntitySilverfish.m().a()).put(EntityTypes.SKELETON, EntitySkeletonAbstract.m().a()).put(EntityTypes.SKELETON_HORSE, EntityHorseSkeleton.eL().a()).put(EntityTypes.SLIME, EntityMonster.eR().a()).put(EntityTypes.SNOW_GOLEM, EntitySnowman.m().a()).put(EntityTypes.SPIDER, EntitySpider.eK().a()).put(EntityTypes.SQUID, EntitySquid.m().a()).put(EntityTypes.STRAY, EntitySkeletonAbstract.m().a()).put(EntityTypes.STRIDER, EntityStrider.eM().a()).put(EntityTypes.TRADER_LLAMA, EntityLlama.fw().a()).put(EntityTypes.TROPICAL_FISH, EntityFish.m().a()).put(EntityTypes.TURTLE, EntityTurtle.eM().a()).put(EntityTypes.VEX, EntityVex.m().a()).put(EntityTypes.VILLAGER, EntityVillager.eY().a()).put(EntityTypes.VINDICATOR, EntityVindicator.eK().a()).put(EntityTypes.WANDERING_TRADER, EntityInsentient.p().a()).put(EntityTypes.WITCH, EntityWitch.eK().a()).put(EntityTypes.WITHER, EntityWither.eK().a()).put(EntityTypes.WITHER_SKELETON, EntitySkeletonAbstract.m().a()).put(EntityTypes.WOLF, EntityWolf.eU().a()).put(EntityTypes.ZOGLIN, EntityZoglin.m().a()).put(EntityTypes.ZOMBIE, EntityZombie.eS().a()).put(EntityTypes.ZOMBIE_HORSE, EntityHorseZombie.eL().a()).put(EntityTypes.ZOMBIE_VILLAGER, EntityZombie.eS().a()).put(EntityTypes.ZOMBIFIED_PIGLIN, EntityPigZombie.eW().a()).build());
 
     public static AttributeProvider a(EntityTypes<? extends EntityLiving> entitytypes) {
-        return (AttributeProvider) AttributeDefaults.b.get(entitytypes);
+        return AttributeDefaults.b.get(entitytypes);
+    }
+
+    public static AttributeProvider getDefault(EntityTypes<? extends EntityLiving> entitytypes) { // Kenzie - OBFHELPER
+        return a(entitytypes);
+    }
+
+    // Kenzie - access attribute defaults
+    public static Map<EntityTypes<? extends EntityLiving>, AttributeProvider> getAttributeDefaults() {
+        return b;
     }
 
     public static boolean b(EntityTypes<?> entitytypes) {
@@ -20,14 +32,10 @@ public class AttributeDefaults {
     }
 
     public static void a() {
-        Stream stream = IRegistry.ENTITY_TYPE.g().filter((entitytypes) -> {
-            return entitytypes.e() != EnumCreatureType.MISC;
-        }).filter((entitytypes) -> {
-            return !b(entitytypes);
-        });
-        RegistryBlocks registryblocks = IRegistry.ENTITY_TYPE;
+        Stream<EntityTypes<?>> stream = IRegistry.ENTITY_TYPE.g().filter((entitytypes) -> entitytypes.e() != EnumCreatureType.MISC).filter((entitytypes) -> !b(entitytypes));
+        RegistryBlocks<EntityTypes<?>> registryblocks = IRegistry.ENTITY_TYPE;
 
-        registryblocks.getClass();
+        registryblocks.getClass(); // Loading the class?
         stream.map(registryblocks::getKey).forEach((minecraftkey) -> {
             if (SharedConstants.d) {
                 throw new IllegalStateException("Entity " + minecraftkey + " has no attributes");
diff --git a/src/main/java/net/minecraft/server/AttributeProvider.java b/src/main/java/net/minecraft/server/AttributeProvider.java
index dd235a6fc4bc731a344d7211879f9b40bb622c3e..120042783fd5b2aed8f989a08063dac40cea46dc 100644
--- a/src/main/java/net/minecraft/server/AttributeProvider.java
+++ b/src/main/java/net/minecraft/server/AttributeProvider.java
@@ -2,58 +2,73 @@ package net.minecraft.server;
 
 import com.google.common.collect.ImmutableMap;
 import com.google.common.collect.Maps;
+import org.bukkit.NamespacedKey;
+import org.bukkit.attribute.Attribute;
+
+import java.util.HashMap;
 import java.util.Map;
 import java.util.UUID;
 import java.util.function.Consumer;
 import javax.annotation.Nullable;
 
 public class AttributeProvider {
-
     private final Map<AttributeBase, AttributeModifiable> a;
 
-    public AttributeProvider(Map<AttributeBase, AttributeModifiable> map) {
-        this.a = ImmutableMap.copyOf(map);
+    public AttributeProvider(Map<AttributeBase, AttributeModifiable> var0) {
+        this.a = new HashMap<>(var0); // Kenzie - make mutable
     }
 
-    private AttributeModifiable d(AttributeBase attributebase) {
-        AttributeModifiable attributemodifiable = (AttributeModifiable) this.a.get(attributebase);
+    // Kenzie start - make map public
+    public Map<AttributeBase, AttributeModifiable> getMap() {
+        return a;
+    }
 
-        if (attributemodifiable == null) {
-            throw new IllegalArgumentException("Can't find attribute " + IRegistry.ATTRIBUTE.getKey(attributebase));
-        } else {
-            return attributemodifiable;
+    public Map<Attribute, Double> getAndConvertMap() {
+        Map<Attribute, Double> map = new HashMap<>();
+        for (Map.Entry<AttributeBase, AttributeModifiable> entry : getMap().entrySet()) {
+            MinecraftKey key = IRegistry.ATTRIBUTE.getKey(entry.getKey());
+            if (key == null) continue;
+            map.put(new Attribute(new NamespacedKey(key.namespace, key.key)), entry.getValue().getValue());
         }
+        return map;
     }
+    // Kenzie end
 
-    public double a(AttributeBase attributebase) {
-        return this.d(attributebase).getValue();
+    private AttributeModifiable d(AttributeBase var0) {
+        AttributeModifiable var1 = (AttributeModifiable)this.a.get(var0);
+        if (var1 == null) {
+            throw new IllegalArgumentException("Can't find attribute " + IRegistry.ATTRIBUTE.getKey(var0));
+        } else {
+            return var1;
+        }
     }
 
-    public double b(AttributeBase attributebase) {
-        return this.d(attributebase).getBaseValue();
+    public double a(AttributeBase var0) {
+        return this.d(var0).getValue();
     }
 
-    public double a(AttributeBase attributebase, UUID uuid) {
-        AttributeModifier attributemodifier = this.d(attributebase).a(uuid);
+    public double b(AttributeBase var0) {
+        return this.d(var0).getBaseValue();
+    }
 
-        if (attributemodifier == null) {
-            throw new IllegalArgumentException("Can't find modifier " + uuid + " on attribute " + IRegistry.ATTRIBUTE.getKey(attributebase));
+    public double a(AttributeBase var0, UUID var1) {
+        AttributeModifier var2 = this.d(var0).a(var1);
+        if (var2 == null) {
+            throw new IllegalArgumentException("Can't find modifier " + var1 + " on attribute " + IRegistry.ATTRIBUTE.getKey(var0));
         } else {
-            return attributemodifier.getAmount();
+            return var2.getAmount();
         }
     }
 
     @Nullable
-    public AttributeModifiable a(Consumer<AttributeModifiable> consumer, AttributeBase attributebase) {
-        AttributeModifiable attributemodifiable = (AttributeModifiable) this.a.get(attributebase);
-
-        if (attributemodifiable == null) {
+    public AttributeModifiable a(Consumer<AttributeModifiable> var0, AttributeBase var1) {
+        AttributeModifiable var2 = (AttributeModifiable)this.a.get(var1);
+        if (var2 == null) {
             return null;
         } else {
-            AttributeModifiable attributemodifiable1 = new AttributeModifiable(attributebase, consumer);
-
-            attributemodifiable1.a(attributemodifiable);
-            return attributemodifiable1;
+            AttributeModifiable var3 = new AttributeModifiable(var1, var0);
+            var3.a(var2);
+            return var3;
         }
     }
 
@@ -61,43 +76,40 @@ public class AttributeProvider {
         return new AttributeProvider.Builder();
     }
 
-    public boolean c(AttributeBase attributebase) {
-        return this.a.containsKey(attributebase);
+    public boolean c(AttributeBase var0) {
+        return this.a.containsKey(var0);
     }
 
-    public boolean b(AttributeBase attributebase, UUID uuid) {
-        AttributeModifiable attributemodifiable = (AttributeModifiable) this.a.get(attributebase);
-
-        return attributemodifiable != null && attributemodifiable.a(uuid) != null;
+    public boolean b(AttributeBase var0, UUID var1) {
+        AttributeModifiable var2 = (AttributeModifiable)this.a.get(var0);
+        return var2 != null && var2.a(var1) != null;
     }
 
     public static class Builder {
-
         private final Map<AttributeBase, AttributeModifiable> a = Maps.newHashMap();
         private boolean b;
 
-        public Builder() {}
+        public Builder() {
+        }
 
-        private AttributeModifiable b(AttributeBase attributebase) {
-            AttributeModifiable attributemodifiable = new AttributeModifiable(attributebase, (attributemodifiable1) -> {
+        private AttributeModifiable b(AttributeBase var0) {
+            AttributeModifiable var1 = new AttributeModifiable(var0, (var1x) -> {
                 if (this.b) {
-                    throw new UnsupportedOperationException("Tried to change value for default attribute instance: " + IRegistry.ATTRIBUTE.getKey(attributebase));
+                    throw new UnsupportedOperationException("Tried to change value for default attribute instance: " + IRegistry.ATTRIBUTE.getKey(var0));
                 }
             });
-
-            this.a.put(attributebase, attributemodifiable);
-            return attributemodifiable;
+            this.a.put(var0, var1);
+            return var1;
         }
 
-        public AttributeProvider.Builder a(AttributeBase attributebase) {
-            this.b(attributebase);
+        public AttributeProvider.Builder a(AttributeBase var0) {
+            this.b(var0);
             return this;
         }
 
-        public AttributeProvider.Builder a(AttributeBase attributebase, double d0) {
-            AttributeModifiable attributemodifiable = this.b(attributebase);
-
-            attributemodifiable.setValue(d0);
+        public AttributeProvider.Builder a(AttributeBase var0, double var1) {
+            AttributeModifiable var3 = this.b(var0);
+            var3.setValue(var1);
             return this;
         }
 
diff --git a/src/main/java/net/minecraft/server/Chunk.java b/src/main/java/net/minecraft/server/Chunk.java
index 083da88c1dd78b8ecdc8329c94430189cecb9d95..c2c067a5822b51c85f397678b20f182476b387d7 100644
--- a/src/main/java/net/minecraft/server/Chunk.java
+++ b/src/main/java/net/minecraft/server/Chunk.java
@@ -7,23 +7,23 @@ import it.unimi.dsi.fastutil.longs.LongOpenHashSet;
 import it.unimi.dsi.fastutil.longs.LongSet;
 import it.unimi.dsi.fastutil.shorts.ShortList;
 import it.unimi.dsi.fastutil.shorts.ShortListIterator;
-import java.util.Collection;
-import java.util.Collections;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Map;
+
+import java.util.*;
 import java.util.Map.Entry;
-import java.util.Set;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import java.util.function.Supplier;
 import java.util.stream.Stream;
 import java.util.stream.StreamSupport;
 import javax.annotation.Nullable;
+
+import mx.kenzie.wellspring.nbt.BlockNBTStorage;
+import mx.kenzie.wellspring.nbt.NBTCompound;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
+import org.bukkit.util.Vector;
 
-public class Chunk implements IChunkAccess {
+public class Chunk implements IChunkAccess, BlockNBTStorage { // Kenzie
 
     private static final Logger LOGGER = LogManager.getLogger();
     @Nullable
@@ -57,6 +57,30 @@ public class Chunk implements IChunkAccess {
         this(world, chunkcoordintpair, biomestorage, ChunkConverter.a, TickListEmpty.b(), TickListEmpty.b(), 0L, (ChunkSection[]) null, (Consumer) null);
     }
 
+    // Kenzie start - block NBT
+    @Override
+    public NBTCompound getNBT(org.bukkit.util.Vector position) {
+        final BlockPosition pos = new BlockPosition(position.getBlockX(), position.getBlockY(), position.getBlockZ());
+        final ChunkSection section = getSection(pos);
+        return section.getNBT(pos);
+    }
+
+    @Override
+    public void clearNBT(Vector position) {
+        final BlockPosition pos = new BlockPosition(position.getBlockX(), position.getBlockY(), position.getBlockZ());
+        getSection(pos).clearNBT(pos);
+    }
+
+    public ChunkSection getSection(BlockPosition position) { // Utility
+        final int y = position.getY();
+        final ChunkSection section = sections[y >> 4];
+        if (section == this.a() || section == null) {
+            return (sections[y >> 4] = new ChunkSection(y >> 4 << 4, this, this.world, false));
+        }
+        return section;
+    }
+    // Kenzie end
+
     // Paper start
     public final co.aikar.util.Counter<String> entityCounts = new co.aikar.util.Counter<>();
     public final co.aikar.util.Counter<String> tileEntityCounts = new co.aikar.util.Counter<>();
diff --git a/src/main/java/net/minecraft/server/ChunkRegionLoader.java b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
index 8e7da2c5f3852920ec5fbcdd2bff4d299e6aa499..96972af348ac72e4460b36c028f7a9c749e916d5 100644
--- a/src/main/java/net/minecraft/server/ChunkRegionLoader.java
+++ b/src/main/java/net/minecraft/server/ChunkRegionLoader.java
@@ -115,6 +115,22 @@ public class ChunkRegionLoader {
                 tasksToExecuteOnMain.add(() -> { // Paper - delay this task since we're executing off-main
                     villageplace.a(chunkcoordintpair, chunksection);
                 }); // Paper - delay this task since we're executing off-main
+
+                // Kenzie start - block NBT
+                if (nbttagcompound2.hasKey("BlockNBT")) {
+                    try {
+                        NBTTagList blockNBT = (NBTTagList) nbttagcompound2.getList("BlockNBT");
+                        for (NBTBase base : blockNBT) { // Exception will exit this block
+                            NBTTagCompound entry = ((NBTTagCompound) base);
+                            BlockPosition position = new BlockPosition(entry.getInt("x"), entry.getInt("y"), entry.getInt("z"));
+                            NBTTagCompound data = entry.getCompound("data");
+                            if (data == null || data.isEmpty()) continue;
+                            chunksection.blockNBT.put(position, data);
+                        }
+                    } catch (Throwable ignore) { // Numerous possibilities for upgrade-errors
+                    }
+                }
+                // Kenzie end
             }
 
             if (flag) {
@@ -441,6 +457,26 @@ public class ChunkRegionLoader {
                 nbttagcompound2.setByte("Y", (byte) (i & 255));
                 if (chunksection != Chunk.a) {
                     chunksection.getBlocks().a(nbttagcompound2, "Palette", "BlockStates");
+                    // Kenzie start - block NBT
+                    if (!chunksection.blockNBT.isEmpty()) {
+                        NBTTagList blockNBT = new NBTTagList();
+                        try {
+                            for (Entry<BlockPosition, NBTTagCompound> entry : chunksection.blockNBT.entrySet()) {
+                                if (entry.getValue() == null || entry.getValue().isEmpty() || entry.getKey() == null)
+                                    continue;
+                                BlockPosition position = entry.getKey();
+                                NBTTagCompound data = new NBTTagCompound();
+                                data.setInt("x", position.getX());
+                                data.setInt("y", position.getY());
+                                data.setInt("z", position.getZ());
+                                data.set("data", entry.getValue());
+                                blockNBT.add(data);
+                            }
+                        } catch (Throwable ignore) { // To account for plugins storing data badly
+                        }
+                        nbttagcompound2.set("BlockNBT", blockNBT);
+                    }
+                    // Kenzie end
                 }
 
                 if (nibblearray != null && !nibblearray.c()) {
diff --git a/src/main/java/net/minecraft/server/ChunkSection.java b/src/main/java/net/minecraft/server/ChunkSection.java
index e52df8096e399c84ff8a2637fdd65ea57d9001d0..920100af0bed958b7068125cdbf5a6ec9177c490 100644
--- a/src/main/java/net/minecraft/server/ChunkSection.java
+++ b/src/main/java/net/minecraft/server/ChunkSection.java
@@ -1,10 +1,17 @@
 package net.minecraft.server;
 
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
 import java.util.function.Predicate;
 import com.destroystokyo.paper.antixray.ChunkPacketInfo; // Paper - Anti-Xray - Add chunk packet info
+import mx.kenzie.wellspring.nbt.BlockNBTStorage;
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import org.bukkit.util.Vector;
+
 import javax.annotation.Nullable;
 
-public class ChunkSection {
+public class ChunkSection implements BlockNBTStorage { // Kenzie
 
     public static final DataPalette<IBlockData> GLOBAL_PALETTE = new DataPaletteGlobal<>(Block.REGISTRY_ID, Blocks.AIR.getBlockData());
     final int yPos; // Paper - private -> package-private
@@ -15,6 +22,37 @@ public class ChunkSection {
 
     final com.destroystokyo.paper.util.maplist.IBlockDataList tickingList = new com.destroystokyo.paper.util.maplist.IBlockDataList(); // Paper
 
+    // Kenzie start - block NBT
+    public final Map<BlockPosition, NBTTagCompound> blockNBT = new HashMap<>();
+
+    public void setNBT(BlockPosition position, NBTTagCompound compound) {
+        if (position != null) blockNBT.put(position, compound);
+    }
+
+    public NBTTagCompound getNBT(BlockPosition position) {
+        blockNBT.putIfAbsent(position, new NBTTagCompound());
+        return blockNBT.get(position);
+    }
+
+    public void clearNBT(BlockPosition position) {
+        blockNBT.remove(position);
+    }
+
+    public void clearNBT() {
+        blockNBT.clear();
+    }
+
+    @Override
+    public NBTCompound getNBT(Vector position) {
+        return getNBT(new BlockPosition(position.getBlockX(), position.getBlockY(), position.getBlockZ()));
+    }
+
+    @Override
+    public void clearNBT(Vector position) {
+        clearNBT(new BlockPosition(position.getBlockX(), position.getBlockY(), position.getBlockZ()));
+    }
+    // Kenzie end
+
     // Paper start - Anti-Xray - Add parameters
     @Deprecated public ChunkSection(int i) { this(i, null, null, true); } // Notice for updates: Please make sure this constructor isn't used anywhere
     public ChunkSection(int i, IChunkAccess chunk, World world, boolean initializeBlocks) {
diff --git a/src/main/java/net/minecraft/server/DefinedStructure.java b/src/main/java/net/minecraft/server/DefinedStructure.java
index 8974d7944f159b9346680c639daf0f8c06767cfe..179b09887128f1c3f4f59e0fbcf317145671dfca 100644
--- a/src/main/java/net/minecraft/server/DefinedStructure.java
+++ b/src/main/java/net/minecraft/server/DefinedStructure.java
@@ -3,6 +3,22 @@ package net.minecraft.server;
 import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.mojang.datafixers.util.Pair;
+import mx.kenzie.server.structure.Structure;
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import mx.kenzie.wellspring.nbt.NBTList;
+import mx.kenzie.wellspring.structure.StructureInfo;
+import org.bukkit.Location;
+import org.bukkit.NamespacedKey;
+import org.bukkit.block.structure.Mirror;
+import org.bukkit.block.structure.StructureRotation;
+import org.bukkit.craftbukkit.CraftWorld;
+import org.bukkit.util.BoundingBox;
+import org.bukkit.util.Vector;
+
+import java.io.*;
+import java.nio.file.Files;
+import java.nio.file.LinkOption;
+import java.nio.file.Path;
 import java.util.Collections;
 import java.util.Comparator;
 import java.util.Iterator;
@@ -13,7 +29,9 @@ import java.util.Random;
 import java.util.stream.Collectors;
 import javax.annotation.Nullable;
 
-public class DefinedStructure {
+import static net.minecraft.server.Blocks.STRUCTURE_VOID;
+
+public class DefinedStructure extends Structure {
 
     private final List<DefinedStructure.a> a = Lists.newArrayList();
     private final List<DefinedStructure.EntityInfo> b = Lists.newArrayList();
@@ -884,4 +902,131 @@ public class DefinedStructure {
             this.b.a(iblockdata, i);
         }
     }
+
+    // Kenzie start
+
+    @Override
+    public Vector getSize(StructureRotation rotation) {
+        final BlockPosition position = a(Structure.convert(rotation));
+        final int x, y ,z;
+        x = position.getX();
+        y = position.getY();
+        z = position.getZ();
+        return new Vector(x, y, z);
+    }
+
+    @Override
+    public BoundingBox getBounds(Location location, Location pivot, StructureRotation rotation, Mirror mirror) {
+        return getBounds(location.toVector(), pivot.toVector(), rotation, mirror);
+    }
+
+    @Override
+    public BoundingBox getBounds(Vector location, Vector pivot, StructureRotation rotation, Mirror mirror) {
+        BlockPosition centre, rot;
+        centre = new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+        rot = new BlockPosition(pivot.getBlockX(), pivot.getBlockY(), pivot.getBlockZ());
+        StructureBoundingBox box = a(centre, convert(rotation), rot, convert(mirror));
+        return new BoundingBox(box.a, box.b, box.c, box.d, box.e, box.f);
+    }
+
+    @Override
+    public BoundingBox getBounds(Vector target, StructureInfo data) {
+        StructureBoundingBox box =  b(((DefinedStructureInfo) data), new BlockPosition(target.getBlockX(), target.getBlockY(), target.getBlockZ()));
+        return new BoundingBox(box.a, box.b, box.c, box.d, box.e, box.f);
+    }
+
+    @Override
+    public String getAuthor() {
+        return b();
+    }
+
+    @Override
+    public void setAuthor(String author) {
+        a(author);
+    }
+
+    @Override
+    public NBTCompound save() {
+        return a(new NBTTagCompound());
+    }
+
+    @Override
+    public NBTCompound save(NBTCompound compound) {
+        return a(((NBTTagCompound) compound));
+    }
+
+    @Override
+    public void load(NBTCompound compound) {
+        b(((NBTTagCompound) compound));
+    }
+
+    @Override
+    public void loadPalette(NBTList a, NBTList b) {
+        a(((NBTTagList) a), ((NBTTagList) b));
+    }
+
+    @Override
+    public void populate(Location location, Vector size) {
+        populate(location, size, true, true);
+    }
+
+    @Override
+    public void populate(Location location, Vector size, boolean entities) {
+        populate(location, size, entities, true);
+    }
+
+    @Override
+    public void populate(Location location, Vector size, boolean entities, boolean voids) {
+        WorldServer world = ((CraftWorld) location.getWorld()).getHandle();
+        BlockPosition centre = new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+        BlockPosition bounds = new BlockPosition(size.getBlockX(), size.getBlockY(), size.getBlockZ());
+        a(world, centre, bounds, entities, voids ? null : STRUCTURE_VOID);
+    }
+
+    @Override
+    public boolean paste(Location location, StructureInfo data) {
+        WorldServer world = ((CraftWorld) location.getWorld()).getHandle();
+        BlockPosition centre = new BlockPosition(location.getBlockX(), location.getBlockY(), location.getBlockZ());
+        DefinedStructureInfo info = ((DefinedStructureInfo) data);
+        info.k();
+        return a(world, centre, centre, info, info.getSeed() != null ? info.getSeed() : world.random, 2);
+    }
+
+    @Override
+    public void saveTo(File file) {
+        if (!file.exists()) throw new IllegalArgumentException("File must exist!");
+        try {
+            FileOutputStream fileoutputstream = new FileOutputStream(file);
+            Throwable throwable = null;
+            try {
+                NBTCompressedStreamTools.a(((NBTTagCompound) getNBT()), fileoutputstream);
+            } catch (Throwable throwable1) {
+                throwable = throwable1;
+                throw throwable1;
+            } finally {
+                if (throwable != null) {
+                    try {
+                        fileoutputstream.close();
+                    } catch (Throwable throwable2) {
+                        throwable.addSuppressed(throwable2);
+                    }
+                } else {
+                    fileoutputstream.close();
+                }
+
+            }
+        } catch (Throwable ex) {
+            throw new RuntimeException(ex);
+        }
+    }
+
+    @Override
+    public void saveAs(NamespacedKey resource) {
+        MinecraftKey key = MinecraftKey.a(resource.toString());
+        DefinedStructureManager manager = MinecraftServer.getServer().getDefinedStructureManager();
+        manager.getMap().put(key, this);
+        manager.c(key);
+    }
+
+    // Kenzie end
 }
diff --git a/src/main/java/net/minecraft/server/DefinedStructureInfo.java b/src/main/java/net/minecraft/server/DefinedStructureInfo.java
index 8d3a47db3564e48bc3985bf3922ab97d2e0da5c9..c3ac8cc7bdf3f9eb4f6deb7e7cac71f020f75286 100644
--- a/src/main/java/net/minecraft/server/DefinedStructureInfo.java
+++ b/src/main/java/net/minecraft/server/DefinedStructureInfo.java
@@ -5,8 +5,14 @@ import java.util.List;
 import java.util.Random;
 import javax.annotation.Nullable;
 
-public class DefinedStructureInfo {
-
+import mx.kenzie.server.structure.Structure;
+import mx.kenzie.wellspring.structure.StructureInfo;
+import net.minecraft.server.DefinedStructure.a;
+import org.bukkit.block.structure.Mirror;
+import org.bukkit.block.structure.StructureRotation;
+import org.bukkit.util.Vector;
+
+public class DefinedStructureInfo implements StructureInfo {
     private EnumBlockMirror a;
     private EnumBlockRotation b;
     private BlockPosition c;
@@ -33,60 +39,59 @@ public class DefinedStructureInfo {
     }
 
     public DefinedStructureInfo a() {
-        DefinedStructureInfo definedstructureinfo = new DefinedStructureInfo();
-
-        definedstructureinfo.a = this.a;
-        definedstructureinfo.b = this.b;
-        definedstructureinfo.c = this.c;
-        definedstructureinfo.d = this.d;
-        definedstructureinfo.e = this.e;
-        definedstructureinfo.f = this.f;
-        definedstructureinfo.g = this.g;
-        definedstructureinfo.h = this.h;
-        definedstructureinfo.i = this.i;
-        definedstructureinfo.j.addAll(this.j);
-        definedstructureinfo.k = this.k;
-        definedstructureinfo.l = this.l;
-        return definedstructureinfo;
-    }
-
-    public DefinedStructureInfo a(EnumBlockMirror enumblockmirror) {
-        this.a = enumblockmirror;
+        DefinedStructureInfo var0 = new DefinedStructureInfo();
+        var0.a = this.a;
+        var0.b = this.b;
+        var0.c = this.c;
+        var0.d = this.d;
+        var0.e = this.e;
+        var0.f = this.f;
+        var0.g = this.g;
+        var0.h = this.h;
+        var0.i = this.i;
+        var0.j.addAll(this.j);
+        var0.k = this.k;
+        var0.l = this.l;
+        return var0;
+    }
+
+    public DefinedStructureInfo a(EnumBlockMirror var0) {
+        this.a = var0;
         return this;
     }
 
-    public DefinedStructureInfo a(EnumBlockRotation enumblockrotation) {
-        this.b = enumblockrotation;
+    public DefinedStructureInfo a(EnumBlockRotation var0) {
+        this.b = var0;
         return this;
     }
 
-    public DefinedStructureInfo a(BlockPosition blockposition) {
-        this.c = blockposition;
+    public DefinedStructureInfo a(BlockPosition var0) {
+        this.c = var0;
         return this;
     }
 
-    public DefinedStructureInfo a(boolean flag) {
-        this.d = flag;
+    public DefinedStructureInfo a(boolean var0) {
+        this.d = var0;
         return this;
     }
 
-    public DefinedStructureInfo a(ChunkCoordIntPair chunkcoordintpair) {
-        this.e = chunkcoordintpair;
+    public DefinedStructureInfo a(ChunkCoordIntPair var0) {
+        this.e = var0;
         return this;
     }
 
-    public DefinedStructureInfo a(StructureBoundingBox structureboundingbox) {
-        this.f = structureboundingbox;
+    public DefinedStructureInfo a(StructureBoundingBox var0) {
+        this.f = var0;
         return this;
     }
 
-    public DefinedStructureInfo a(@Nullable Random random) {
-        this.h = random;
+    public DefinedStructureInfo a(@Nullable Random var0) {
+        this.h = var0;
         return this;
     }
 
-    public DefinedStructureInfo c(boolean flag) {
-        this.k = flag;
+    public DefinedStructureInfo c(boolean var0) {
+        this.k = var0;
         return this;
     }
 
@@ -95,13 +100,13 @@ public class DefinedStructureInfo {
         return this;
     }
 
-    public DefinedStructureInfo a(DefinedStructureProcessor definedstructureprocessor) {
-        this.j.add(definedstructureprocessor);
+    public DefinedStructureInfo a(DefinedStructureProcessor var0) {
+        this.j.add(var0);
         return this;
     }
 
-    public DefinedStructureInfo b(DefinedStructureProcessor definedstructureprocessor) {
-        this.j.remove(definedstructureprocessor);
+    public DefinedStructureInfo b(DefinedStructureProcessor var0) {
+        this.j.remove(var0);
         return this;
     }
 
@@ -117,8 +122,12 @@ public class DefinedStructureInfo {
         return this.c;
     }
 
-    public Random b(@Nullable BlockPosition blockposition) {
-        return this.h != null ? this.h : (blockposition == null ? new Random(SystemUtils.getMonotonicMillis()) : new Random(MathHelper.a((BaseBlockPosition) blockposition)));
+    public Random b(@Nullable BlockPosition var0) {
+        if (this.h != null) {
+            return this.h;
+        } else {
+            return var0 == null ? new Random(SystemUtils.getMonotonicMillis()) : new Random(MathHelper.a(var0));
+        }
     }
 
     public boolean g() {
@@ -153,34 +162,87 @@ public class DefinedStructureInfo {
         return this.g;
     }
 
-    public DefinedStructure.a a(List<DefinedStructure.a> list, @Nullable BlockPosition blockposition) {
-        int i = list.size();
-
-        if (i == 0) {
+    public a a(List<a> var0, @Nullable BlockPosition var1) {
+        int var2 = var0.size();
+        if (var2 == 0) {
             throw new IllegalStateException("No palettes");
         } else {
-            return (DefinedStructure.a) list.get(this.b(blockposition).nextInt(i));
+            return (a)var0.get(this.b(var1).nextInt(var2));
         }
     }
 
     @Nullable
-    private StructureBoundingBox b(@Nullable ChunkCoordIntPair chunkcoordintpair) {
-        if (chunkcoordintpair == null) {
+    private StructureBoundingBox b(@Nullable ChunkCoordIntPair var0) {
+        if (var0 == null) {
             return this.f;
         } else {
-            int i = chunkcoordintpair.x * 16;
-            int j = chunkcoordintpair.z * 16;
-
-            return new StructureBoundingBox(i, 0, j, i + 16 - 1, 255, j + 16 - 1);
+            int var1 = var0.x * 16;
+            int var2 = var0.z * 16;
+            return new StructureBoundingBox(var1, 0, var2, var1 + 16 - 1, 255, var2 + 16 - 1);
         }
     }
 
-    public DefinedStructureInfo d(boolean flag) {
-        this.l = flag;
+    public DefinedStructureInfo d(boolean var0) {
+        this.l = var0;
         return this;
     }
 
     public boolean m() {
         return this.l;
     }
+
+    // Kenzie start
+
+    @Override
+    public StructureInfo setMirror(Mirror mirror) {
+        return a(Structure.convert(mirror));
+    }
+
+    @Override
+    public StructureInfo setRotation(StructureRotation rotation) {
+        return a(Structure.convert(rotation));
+    }
+
+    @Override
+    public StructureInfo keepLiquids(boolean keep) {
+        g = keep;
+        return this;
+    }
+
+    @Override
+    public StructureInfo ignoreEntities(boolean ignore) {
+        return a(ignore);
+    }
+
+    @Override
+    public StructureInfo setSeed(Random random) {
+        return a(random);
+    }
+
+    @Override
+    public StructureInfo setPivot(int x, int y, int z) {
+        return a(new BlockPosition(x, y, z));
+    }
+
+    @Override
+    public boolean isKeepLiquids() {
+        return false;
+    }
+
+    @Override
+    public boolean isIgnoreEntities() {
+        return false;
+    }
+
+    @Override
+    public Vector getPivot() {
+        return new Vector(c.getX(), c.getY(), c.getZ());
+    }
+
+    @Override
+    public Random getSeed() {
+        return h;
+    }
+
+    // Kenzie end
 }
diff --git a/src/main/java/net/minecraft/server/DefinedStructureManager.java b/src/main/java/net/minecraft/server/DefinedStructureManager.java
index 595789d2ba8571f8375a17cabd26a06040523849..b919e4c010bb8c20406a6c924d389ff1d5cf200c 100644
--- a/src/main/java/net/minecraft/server/DefinedStructureManager.java
+++ b/src/main/java/net/minecraft/server/DefinedStructureManager.java
@@ -19,7 +19,7 @@ import org.apache.logging.log4j.Logger;
 public class DefinedStructureManager {
 
     private static final Logger LOGGER = LogManager.getLogger();
-    private final Map<MinecraftKey, DefinedStructure> b = Maps.newConcurrentMap(); // SPIGOT-5287
+    private final Map<MinecraftKey, DefinedStructure> b = Maps.newConcurrentMap(); public Map<MinecraftKey, DefinedStructure> getMap() { return b; } // Kenzie - deobfuscation // SPIGOT-5287
     private final DataFixer c;
     private IResourceManager d;
     private final java.nio.file.Path e;
diff --git a/src/main/java/net/minecraft/server/Enchantment.java b/src/main/java/net/minecraft/server/Enchantment.java
index 7e2162fc78168adb96ed20651e1a3e061c29f96d..8ba31c04f12a9d6562f013dfb9442398e6279b53 100644
--- a/src/main/java/net/minecraft/server/Enchantment.java
+++ b/src/main/java/net/minecraft/server/Enchantment.java
@@ -1,40 +1,81 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Maps;
+
+import java.nio.charset.StandardCharsets;
+import java.util.HashMap;
 import java.util.Map;
+import java.util.UUID;
 import javax.annotation.Nullable;
 
 public abstract class Enchantment {
-
     private final EnumItemSlot[] a;
     private final Enchantment.Rarity d;
     public final EnchantmentSlotType itemTarget;
     @Nullable
     protected String c;
+    private final Map<AttributeBase, AttributeModifier> attributes = new HashMap<>(); // Kenzie - attributes
 
-    protected Enchantment(Enchantment.Rarity enchantment_rarity, EnchantmentSlotType enchantmentslottype, EnumItemSlot[] aenumitemslot) {
-        this.d = enchantment_rarity;
-        this.itemTarget = enchantmentslottype;
-        this.a = aenumitemslot;
+    protected Enchantment(Enchantment.Rarity var0, EnchantmentSlotType var1, EnumItemSlot[] var2) {
+        this.d = var0;
+        this.itemTarget = var1;
+        this.a = var2;
     }
 
-    public Map<EnumItemSlot, ItemStack> a(EntityLiving entityliving) {
-        Map<EnumItemSlot, ItemStack> map = Maps.newEnumMap(EnumItemSlot.class);
-        EnumItemSlot[] aenumitemslot = this.a;
-        int i = aenumitemslot.length;
+    // Kenzie start - attributes
 
-        for (int j = 0; j < i; ++j) {
-            EnumItemSlot enumitemslot = aenumitemslot[j];
-            ItemStack itemstack = entityliving.getEquipment(enumitemslot);
+    public void addAttribute(AttributeBase var0, double var2, AttributeModifier.Operation var4) {
+        AttributeModifier var5 = new AttributeModifier(UUID.nameUUIDFromBytes(f().getBytes(StandardCharsets.UTF_8)), f(), var2, var4);
+        this.attributes.put(var0, var5);
+    }
 
-            if (!itemstack.isEmpty()) {
-                map.put(enumitemslot, itemstack);
-            }
-        }
+    public void addAttribute(AttributeBase base, AttributeModifier modifier) {
+        attributes.put(base, modifier);
+    }
 
+    public Map<AttributeBase, AttributeModifier> getAttributes() {
+        return attributes;
+    }
+
+    public Map<AttributeBase, AttributeModifier> getAttributes(EnumItemSlot slot) {
+        if (isEffective(slot)) return getAttributes();
+        return new HashMap<>();
+    }
+
+    public Map<AttributeBase, AttributeModifier> cloneAttributes() {
+        Map<AttributeBase, AttributeModifier> map = new HashMap<>();
+        for (Map.Entry<AttributeBase, AttributeModifier> entry : getAttributes().entrySet()) {
+            AttributeModifier original = entry.getValue();
+            AttributeModifier value = new AttributeModifier(original.getUniqueId(), original.getName(), original.getAmount(), original.getOperation());
+            map.put(entry.getKey(), value);
+        }
         return map;
     }
 
+    public boolean isEffective(EnumItemSlot slot) {
+        for (EnumItemSlot enumItemSlot : a) {
+            if (enumItemSlot == slot) return true;
+        }
+        return false;
+    }
+
+    // Kenzie end
+
+    public Map<EnumItemSlot, ItemStack> a(EntityLiving var0) {
+        Map<EnumItemSlot, ItemStack> var1 = Maps.newEnumMap(EnumItemSlot.class);
+        EnumItemSlot[] var3 = this.a;
+        int var4 = var3.length;
+
+        for (EnumItemSlot slot : var3) { // Kenzie - decompile error
+            ItemStack var6 = var0.getEquipment(slot);
+            if (!var6.isEmpty()) {
+                var1.put(slot, var6);
+            }
+        } // Kenzie end
+
+        return var1;
+    }
+
     public Enchantment.Rarity d() {
         return this.d;
     }
@@ -47,28 +88,28 @@ public abstract class Enchantment {
         return 1;
     }
 
-    public int a(int i) {
-        return 1 + i * 10;
+    public int a(int var0) {
+        return 1 + var0 * 10;
     }
 
-    public int b(int i) {
-        return this.a(i) + 5;
+    public int b(int var0) {
+        return this.a(var0) + 5;
     }
 
-    public int a(int i, DamageSource damagesource) {
+    public int a(int var0, DamageSource var1) {
         return 0;
     }
 
-    public float a(int i, EnumMonsterType enummonstertype) {
+    public float a(int var0, EnumMonsterType var1) {
         return 0.0F;
     }
 
-    public final boolean isCompatible(Enchantment enchantment) {
-        return this.a(enchantment) && enchantment.a(this);
+    public final boolean isCompatible(Enchantment var0) {
+        return this.a(var0) && var0.a(this);
     }
 
-    protected boolean a(Enchantment enchantment) {
-        return this != enchantment;
+    protected boolean a(Enchantment var0) {
+        return this != var0;
     }
 
     protected String f() {
@@ -83,29 +124,30 @@ public abstract class Enchantment {
         return this.f();
     }
 
-    public IChatBaseComponent d(int i) {
-        ChatMessage chatmessage = new ChatMessage(this.g());
-
+    public IChatBaseComponent d(int var0) {
+        IChatMutableComponent var1 = new ChatMessage(this.g());
         if (this.c()) {
-            chatmessage.a(EnumChatFormat.RED);
+            var1.a(EnumChatFormat.RED);
         } else {
-            chatmessage.a(EnumChatFormat.GRAY);
+            var1.a(EnumChatFormat.GRAY);
         }
 
-        if (i != 1 || this.getMaxLevel() != 1) {
-            chatmessage.c(" ").addSibling(new ChatMessage("enchantment.level." + i));
+        if (var0 != 1 || this.getMaxLevel() != 1) {
+            var1.c(" ").addSibling(new ChatMessage("enchantment.level." + var0));
         }
 
-        return chatmessage;
+        return var1;
     }
 
-    public boolean canEnchant(ItemStack itemstack) {
-        return this.itemTarget.canEnchant(itemstack.getItem());
+    public boolean canEnchant(ItemStack var0) {
+        return this.itemTarget.canEnchant(var0.getItem());
     }
 
-    public void a(EntityLiving entityliving, Entity entity, int i) {}
+    public void a(EntityLiving var0, Entity var1, int var2) {
+    }
 
-    public void b(EntityLiving entityliving, Entity entity, int i) {}
+    public void b(EntityLiving var0, Entity var1, int var2) {
+    }
 
     public boolean isTreasure() {
         return false;
@@ -124,13 +166,15 @@ public abstract class Enchantment {
     }
 
     public static enum Rarity {
-
-        COMMON(10), UNCOMMON(5), RARE(2), VERY_RARE(1);
+        COMMON(10),
+        UNCOMMON(5),
+        RARE(2),
+        VERY_RARE(1);
 
         private final int e;
 
-        private Rarity(int i) {
-            this.e = i;
+        private Rarity(int var2) {
+            this.e = var2;
         }
 
         public int a() {
diff --git a/src/main/java/net/minecraft/server/Entity.java b/src/main/java/net/minecraft/server/Entity.java
index b845e488e3b9a4f19d1fcf169533046b7e72ba28..d97f8134a27bec7894c0c50071149b5ae8710601 100644
--- a/src/main/java/net/minecraft/server/Entity.java
+++ b/src/main/java/net/minecraft/server/Entity.java
@@ -18,6 +18,8 @@ import java.util.UUID;
 import java.util.concurrent.atomic.AtomicInteger;
 import java.util.stream.Stream;
 import javax.annotation.Nullable;
+
+import mx.kenzie.wellspring.event.EntityLandEvent;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
@@ -292,6 +294,10 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
         return this.f;
     }
 
+    public EntityTypes<?> getVisualType() { // Kenzie - allow for visual replacements.
+        return getEntityType();
+    }
+
     public int getId() {
         return this.id;
     }
@@ -331,6 +337,8 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
     }
 
     public void die() {
+        if (!(this instanceof EntityPlayer))
+            getBukkitEntity().attachments.dispose(); // Kenzie - attachment disposal
         this.dead = true;
     }
 
@@ -629,7 +637,11 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
             this.world.getMethodProfiler().enter("rest");
             this.positionChanged = !MathHelper.b(vec3d.x, vec3d1.x) || !MathHelper.b(vec3d.z, vec3d1.z);
             this.v = vec3d.y != vec3d1.y;
+            boolean previousOnGround = this.onGround; // Kenzie - previous
             this.onGround = this.v && vec3d.y < 0.0D;
+            if (onGround && !previousOnGround) { // Kenzie - Fall event
+                new EntityLandEvent(getBukkitEntity()).callEvent();
+            }
             BlockPosition blockposition = this.ao();
             IBlockData iblockdata = this.world.getType(blockposition);
 
@@ -1618,6 +1630,8 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
 
             // CraftBukkit start - stores eventually existing bukkit values
             if (this.bukkitEntity != null) {
+                this.bukkitEntity.attachments.request(nbttagcompound); // Kenzie - mark as data requested in case of changes
+                // Done before bukkit values to prevent any illegal editing.
                 this.bukkitEntity.storeBukkitValues(nbttagcompound);
             }
             // CraftBukkit end
@@ -1789,6 +1803,10 @@ public abstract class Entity implements INamableTileEntity, ICommandListener, Ke
                 spawnReason = org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason.DEFAULT;
             }
             // Paper end
+            // Kenzie start - attachments
+
+            this.bukkitEntity.attachments.load(nbttagcompound); // Kenzie - mark as data loaded in case of changes
+            // Done after bukkit values to prevent any illegal editing.
 
         } catch (Throwable throwable) {
             CrashReport crashreport = CrashReport.a(throwable, "Loading entity NBT");
diff --git a/src/main/java/net/minecraft/server/EntityItemFrame.java b/src/main/java/net/minecraft/server/EntityItemFrame.java
index b61876affd09b4bcd2062fd725b8525edc68b054..db6e5ec8b79380b2939cc8667c31d5a620d78711 100644
--- a/src/main/java/net/minecraft/server/EntityItemFrame.java
+++ b/src/main/java/net/minecraft/server/EntityItemFrame.java
@@ -372,6 +372,6 @@ public class EntityItemFrame extends EntityHanging {
 
     @Override
     public Packet<?> P() {
-        return new PacketPlayOutSpawnEntity(this, this.getEntityType(), this.direction.c(), this.getBlockPosition());
+        return new PacketPlayOutSpawnEntity(this, this.getVisualType(), this.direction.c(), this.getBlockPosition()); // Kenzie
     }
 }
diff --git a/src/main/java/net/minecraft/server/EntityLeash.java b/src/main/java/net/minecraft/server/EntityLeash.java
index 6bd25833bc3ff3ca46367a48da001ed9bda8c19d..639bd533b2dadaacc40db2851e93d4492c3d4cf7 100644
--- a/src/main/java/net/minecraft/server/EntityLeash.java
+++ b/src/main/java/net/minecraft/server/EntityLeash.java
@@ -157,6 +157,6 @@ public class EntityLeash extends EntityHanging {
 
     @Override
     public Packet<?> P() {
-        return new PacketPlayOutSpawnEntity(this, this.getEntityType(), 0, this.getBlockPosition());
+        return new PacketPlayOutSpawnEntity(this, this.getVisualType(), 0, this.getBlockPosition()); // Kenzie
     }
 }
diff --git a/src/main/java/net/minecraft/server/EnumItemSlot.java b/src/main/java/net/minecraft/server/EnumItemSlot.java
index 3ad9b3e69ef0ed8ad8eebcb323024670ce7599d1..da30716c90e3ca9c9d0cdf7fa11e68cbc2bcabab 100644
--- a/src/main/java/net/minecraft/server/EnumItemSlot.java
+++ b/src/main/java/net/minecraft/server/EnumItemSlot.java
@@ -1,5 +1,7 @@
 package net.minecraft.server;
 
+import org.bukkit.inventory.EquipmentSlot;
+
 public enum EnumItemSlot {
 
     MAINHAND(EnumItemSlot.Function.HAND, 0, 0, "mainhand"), OFFHAND(EnumItemSlot.Function.HAND, 1, 5, "offhand"), FEET(EnumItemSlot.Function.ARMOR, 0, 1, "feet"), LEGS(EnumItemSlot.Function.ARMOR, 1, 2, "legs"), CHEST(EnumItemSlot.Function.ARMOR, 2, 3, "chest"), HEAD(EnumItemSlot.Function.ARMOR, 3, 4, "head");
@@ -16,6 +18,33 @@ public enum EnumItemSlot {
         this.j = s;
     }
 
+    // Kenzie start - converters
+    public static EnumItemSlot[] convert(EquipmentSlot... slots) {
+        EnumItemSlot[] itemSlots = new EnumItemSlot[slots.length];
+        for (int i = 0; i < slots.length; i++) {
+            itemSlots[i] = convert(slots[i]);
+        }
+        return itemSlots;
+    }
+
+    public static EnumItemSlot convert(EquipmentSlot slot) {
+        switch (slot) {
+            case HEAD:
+                return HEAD;
+            case CHEST:
+                return CHEST;
+            case LEGS:
+                return LEGS;
+            case FEET:
+                return FEET;
+            case HAND:
+                return MAINHAND;
+            case OFF_HAND:
+                return OFFHAND;
+        }
+        return MAINHAND;
+    }
+    // Kenzie end
     public EnumItemSlot.Function getType() { return this.a(); } // Paper - OBFHELPER
     public EnumItemSlot.Function a() {
         return this.g;
diff --git a/src/main/java/net/minecraft/server/IInventory.java b/src/main/java/net/minecraft/server/IInventory.java
index 46b88056b852a7f91d32862dea7bd3a7ea4a1226..a3f2c4ebc4dd96689c3a3eebe941e9b23a007c69 100644
--- a/src/main/java/net/minecraft/server/IInventory.java
+++ b/src/main/java/net/minecraft/server/IInventory.java
@@ -1,6 +1,10 @@
 package net.minecraft.server;
 
+import java.util.List;
 import java.util.Set;
+
+import mx.kenzie.wellspring.nbt.NBT;
+import mx.kenzie.wellspring.nbt.NBTList;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity; // CraftBukkit
 
 public interface IInventory extends Clearable {
@@ -81,4 +85,34 @@ public interface IInventory extends Clearable {
 
     int MAX_STACK = 64;
     // CraftBukkit end
+
+    // Kenzie start - NBT
+    default NBTList getAsNBT() {
+        NBTList list = NBTList.create();
+        NBTTagCompound nbttagcompound;
+        int i;
+        List<ItemStack> items = getContents();
+        for (i = 0; i < items.size(); ++i) {
+            if (!items.get(i).isEmpty()) {
+                nbttagcompound = new NBTTagCompound();
+                nbttagcompound.setByte("Slot", (byte) i);
+                items.get(i).save(nbttagcompound);
+                list.add(nbttagcompound);
+            }
+        }
+        return list;
+    }
+
+    default void loadNBT(NBTList list) {
+        for (NBT nbt : list.getAsArray()) {
+            try {
+                NBTTagCompound compound = (NBTTagCompound) nbt;
+                int slot = compound.getByte("Slot");
+                ItemStack itemstack = ItemStack.a(compound);
+                setItem(slot, itemstack);
+            } catch (Throwable ignore) { // Liable to go wrong during mis-matches
+            }
+        }
+    }
+    // Kenzie end
 }
diff --git a/src/main/java/net/minecraft/server/InventorySubcontainer.java b/src/main/java/net/minecraft/server/InventorySubcontainer.java
index db5def8b1d4179a64b28366339a3634af593cd5e..56d8479402274cddffb24a2b2ff9de5b8ec7ab63 100644
--- a/src/main/java/net/minecraft/server/InventorySubcontainer.java
+++ b/src/main/java/net/minecraft/server/InventorySubcontainer.java
@@ -6,6 +6,7 @@ import java.util.List;
 import java.util.stream.Collectors;
 
 // CraftBukkit start
+import mx.kenzie.wellspring.nbt.NBTList;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
@@ -315,4 +316,16 @@ public class InventorySubcontainer implements IInventory, AutoRecipeOutput {
 
         return nbttaglist;
     }
+
+    // Kenzie start - NBT
+    @Override
+    public mx.kenzie.wellspring.nbt.NBTList getAsNBT() {
+        return g();
+    }
+
+    @Override
+    public void loadNBT(NBTList list) {
+        a((NBTTagList) list);
+    }
+    // Kenzie end
 }
diff --git a/src/main/java/net/minecraft/server/ItemStack.java b/src/main/java/net/minecraft/server/ItemStack.java
index 3adb29f004d2fee36f3ee9b21ee5417e84b64837..ed89e6baccb6a62ac2017f8e4c4e7dc84728c415 100644
--- a/src/main/java/net/minecraft/server/ItemStack.java
+++ b/src/main/java/net/minecraft/server/ItemStack.java
@@ -9,22 +9,17 @@ import com.mojang.serialization.Codec;
 import com.mojang.serialization.codecs.RecordCodecBuilder;
 import java.text.DecimalFormat;
 import java.text.DecimalFormatSymbols;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Locale;
-import java.util.Objects;
-import java.util.Optional;
-import java.util.Random;
+import java.util.*;
 import java.util.function.Consumer;
 import java.util.function.Predicate;
 import javax.annotation.Nullable;
+
+import mx.kenzie.wellspring.nbt.NBTCompound;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 // CraftBukkit start
 import com.mojang.serialization.Dynamic;
-import java.util.List;
-import java.util.Map;
 
 import org.bukkit.Location;
 import org.bukkit.TreeType;
@@ -159,7 +154,7 @@ public final class ItemStack {
     }
 
     // CraftBukkit - break into own method
-    private void load(NBTTagCompound nbttagcompound) {
+    public void load(NBTTagCompound nbttagcompound) { // Kenzie - make public
         this.item = (Item) IRegistry.ITEM.get(new MinecraftKey(nbttagcompound.getString("id")));
         this.count = nbttagcompound.getByte("Count");
         if (nbttagcompound.hasKeyOfType("tag", 10)) {
@@ -848,10 +843,30 @@ public final class ItemStack {
                 }
             }
         } else {
-            object = this.getItem().a(enumitemslot);
+            object = HashMultimap.create(this.getItem().a(enumitemslot));
+        }
+
+        // Kenzie start - enchant attributes
+        Multimap<AttributeBase, AttributeModifier> map = (Multimap) object;
+
+        if (hasEnchantments()) {
+            for (NBTBase base : getEnchantments()) {
+                NBTCompound compound = ((NBTTagCompound) base);
+                MinecraftKey key = MinecraftKey.a(compound.getString("id"));
+                Enchantment enchantment = IRegistry.ENCHANTMENT.get(key);
+                if (enchantment == null) continue;
+                int level = MathHelper.clamp(compound.getInt("lvl"), 0, 255);
+                Map<AttributeBase, AttributeModifier> modifiers = enchantment.getAttributes(enumitemslot);
+                for (Map.Entry<AttributeBase, AttributeModifier> entry : modifiers.entrySet()) {
+                    AttributeModifier value = entry.getValue();
+                    AttributeModifier modifier = new AttributeModifier(value.getUniqueId(), value.getName(), value.getAmount() * level, value.getOperation());
+                    map.put(entry.getKey(), modifier);
+                }
+            }
         }
 
-        return (Multimap) object;
+        return map;
+        // Kenzie end
     }
 
     public void a(AttributeBase attributebase, AttributeModifier attributemodifier, @Nullable EnumItemSlot enumitemslot) {
diff --git a/src/main/java/net/minecraft/server/NBTBase.java b/src/main/java/net/minecraft/server/NBTBase.java
index 8b9e47b4c7f5dc464fa617a59583df9e30a54045..e2451962f8f6c7a00d9b2d743d58e4d5fc48feba 100644
--- a/src/main/java/net/minecraft/server/NBTBase.java
+++ b/src/main/java/net/minecraft/server/NBTBase.java
@@ -1,9 +1,17 @@
 package net.minecraft.server;
 
+import mx.kenzie.wellspring.nbt.NBT;
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import mx.kenzie.wellspring.nbt.NBTList;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
+
 import java.io.DataOutput;
 import java.io.IOException;
+import java.lang.reflect.Field;
+import java.util.UUID;
 
-public interface NBTBase {
+public interface NBTBase extends NBT {
 
     EnumChatFormat d = EnumChatFormat.AQUA;
     EnumChatFormat e = EnumChatFormat.GREEN;
@@ -29,4 +37,61 @@ public interface NBTBase {
     }
 
     IChatBaseComponent a(String s, int i);
+
+    // Kenzie start
+
+    @Override
+    default BaseComponent[] display() { // Kenzie - NBT interface
+        return ComponentSerializer.parse(IChatBaseComponent.ChatSerializer.componentToJson(l()));
+    }
+
+    @Override
+    default BaseComponent[] display(int indentation, String unit) { // Kenzie - NBT interface
+        return ComponentSerializer.parse(IChatBaseComponent.ChatSerializer.componentToJson(a(unit, indentation)));
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    default <T> T getAsObject() {
+        try {
+            switch (getType()) {
+                case BOOLEAN:
+                    return (T) (Object) (((NBTTagByte) this).asByte() != (byte) 0);
+                case BYTE:
+                    return (T) (Object) ((NBTTagByte) this).asByte();
+                case INT:
+                    return (T) (Object) ((NBTTagInt) this).asInt();
+                case SHORT:
+                    return (T) (Object) ((NBTTagShort) this).asShort();
+                case LONG:
+                    return (T) (Object) ((NBTTagLong) this).asLong();
+                case FLOAT:
+                    return (T) (Object) ((NBTTagFloat) this).asFloat();
+                case DOUBLE:
+                    return (T) (Object) ((NBTTagDouble) this).asDouble();
+                case STRING:
+                    return (T) this.asString();
+                case INT_ARRAY:
+                    try { // Assume it is int[]
+                        return (T) ((NBTTagIntArray) this).getInts();
+                    } catch (ClassCastException ex) { // Could be UUID - known only from cast
+                        final int[] array = ((NBTTagIntArray) this).getInts();
+                        return (T) new UUID(array[0], array[1]);
+                    }
+                case BYTE_ARRAY:
+                    return (T) ((NBTTagByteArray) this).getBytes();
+                case LONG_ARRAY:
+                    return (T) ((NBTTagLongArray) this).getLongs();
+                case LIST:
+                case COMPOUND:
+                    return (T) this;
+            }
+            Field field = this.getClass().getDeclaredField("data");
+            return (T) field.get(this);
+        } catch (Throwable ex) {
+            throw new RuntimeException("Unknown error encountered when accessing NBT object.", ex);
+        }
+    }
+
+    // Kenzie end
 }
diff --git a/src/main/java/net/minecraft/server/NBTTagCompound.java b/src/main/java/net/minecraft/server/NBTTagCompound.java
index 06d5acab794e3ee139a11f9b068e8a359c46db2c..65b144364357c5d4e0587f153ffff62415e61893 100644
--- a/src/main/java/net/minecraft/server/NBTTagCompound.java
+++ b/src/main/java/net/minecraft/server/NBTTagCompound.java
@@ -2,7 +2,6 @@ package net.minecraft.server;
 
 import com.google.common.base.Strings;
 import com.google.common.collect.Lists;
-import com.google.common.collect.Maps;
 import com.mojang.serialization.Codec;
 import com.mojang.serialization.DataResult;
 import com.mojang.serialization.Dynamic;
@@ -21,18 +20,18 @@ import java.util.UUID;
 import java.util.regex.Pattern;
 import javax.annotation.Nullable;
 import it.unimi.dsi.fastutil.objects.Object2ObjectOpenHashMap; // Paper
+import mx.kenzie.wellspring.nbt.NBT;
+import mx.kenzie.wellspring.nbt.NBTCompound;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
-public class NBTTagCompound implements NBTBase {
+public class NBTTagCompound implements NBTBase, NBTCompound { // Kenzie - whole class edited
 
     public static final Codec<NBTTagCompound> a = Codec.PASSTHROUGH.comapFlatMap((dynamic) -> {
-        NBTBase nbtbase = (NBTBase) dynamic.convert(DynamicOpsNBT.a).getValue();
+        NBTBase nbtbase = dynamic.convert(DynamicOpsNBT.a).getValue();
 
         return nbtbase instanceof NBTTagCompound ? DataResult.success((NBTTagCompound) nbtbase) : DataResult.error("Not a compound tag: " + nbtbase);
-    }, (nbttagcompound) -> {
-        return new Dynamic(DynamicOpsNBT.a, nbttagcompound);
-    });
+    }, (nbttagcompound) -> new Dynamic(DynamicOpsNBT.a, nbttagcompound));
     private static final Logger LOGGER = LogManager.getLogger();
     private static final Pattern h = Pattern.compile("[A-Za-z0-9._+-]+");
     public static final NBTTagType<NBTTagCompound> b = new NBTTagType<NBTTagCompound>() {
@@ -49,7 +48,7 @@ public class NBTTagCompound implements NBTBase {
                 while ((b0 = NBTTagCompound.c(datainput, nbtreadlimiter)) != 0) {
                     String s = NBTTagCompound.d(datainput, nbtreadlimiter);
 
-                    nbtreadlimiter.a((long) (224 + 16 * s.length()));
+                    nbtreadlimiter.a(224 + 16 * s.length());
                     NBTBase nbtbase = NBTTagCompound.b(NBTTagTypes.a(b0), s, datainput, i + 1, nbtreadlimiter);
 
                     if (hashmap.put(s, nbtbase) != null) {
@@ -113,27 +112,42 @@ public class NBTTagCompound implements NBTBase {
         return this.map.size();
     }
 
+    @Override
+    public int size() { // Kenzie - NBT interface
+        return e();
+    }
+
+    @Override
+    public void set(String key, NBT value) {
+        set(key, (NBTBase) value);
+    }
+
     @Nullable
     public NBTBase set(String s, NBTBase nbtbase) {
-        return (NBTBase) this.map.put(s, nbtbase);
+        return this.map.put(s, nbtbase);
     }
 
+    @Override
     public void setByte(String s, byte b0) {
         this.map.put(s, NBTTagByte.a(b0));
     }
 
+    @Override
     public void setShort(String s, short short0) {
         this.map.put(s, NBTTagShort.a(short0));
     }
 
+    @Override
     public void setInt(String s, int i) {
         this.map.put(s, NBTTagInt.a(i));
     }
 
+    @Override
     public void setLong(String s, long i) {
         this.map.put(s, NBTTagLong.a(i));
     }
 
+    @Override
     public void setUUID(String prefix, UUID uuid) { a(prefix, uuid); } // Paper - OBFHELPER
     public void a(String s, UUID uuid) {
         // Paper start - support old format
@@ -145,7 +159,7 @@ public class NBTTagCompound implements NBTBase {
         this.map.put(s, GameProfileSerializer.a(uuid));
     }
 
-
+    @Override
     @Nullable public UUID getUUID(String prefix) { return a(prefix); } // Paper - OBFHELPER
     @Nullable
     public UUID a(String s) {
@@ -157,6 +171,7 @@ public class NBTTagCompound implements NBTBase {
         return GameProfileSerializer.a(this.get(s));
     }
 
+    @Override
     public final boolean hasUUID(String s) { return this.b(s); } // Paper - OBFHELPER
     public boolean b(String s) {
         // Paper start - support old format
@@ -169,26 +184,41 @@ public class NBTTagCompound implements NBTBase {
         return nbtbase != null && nbtbase.b() == NBTTagIntArray.a && ((NBTTagIntArray) nbtbase).getInts().length == 4;
     }
 
+    @Override
     public void setFloat(String s, float f) {
         this.map.put(s, NBTTagFloat.a(f));
     }
 
+    @Override
     public void setDouble(String s, double d0) {
         this.map.put(s, NBTTagDouble.a(d0));
     }
 
+    @Override
     public void setString(String s, String s1) {
         this.map.put(s, NBTTagString.a(s1));
     }
 
+    @Override
     public void setByteArray(String s, byte[] abyte) {
         this.map.put(s, new NBTTagByteArray(abyte));
     }
 
+    @Override
     public void setIntArray(String s, int[] aint) {
         this.map.put(s, new NBTTagIntArray(aint));
     }
 
+    @Override
+    public void setLongArray(String key, long[] longs) {
+        this.map.put(key, new NBTTagLongArray(longs));
+    }
+
+    @Override
+    public void setList(String key, mx.kenzie.wellspring.nbt.NBTList list) {
+        this.map.put(key, (NBTTagList) list);
+    }
+
     public void b(String s, List<Integer> list) {
         this.map.put(s, new NBTTagIntArray(list));
     }
@@ -220,6 +250,16 @@ public class NBTTagCompound implements NBTBase {
         return this.map.containsKey(s);
     }
 
+    @Override
+    public boolean containsKey(String key, int rawType) {
+        return hasKeyOfType(key, rawType);
+    }
+
+    @Override
+    public boolean containsKey(String key) {
+        return hasKey(key);
+    }
+
     public boolean hasKeyOfType(String s, int i) {
         byte b0 = this.d(s);
 
@@ -358,6 +398,12 @@ public class NBTTagCompound implements NBTBase {
         return new NBTTagCompound();
     }
 
+    @Override
+    public mx.kenzie.wellspring.nbt.NBTList getList(String key) { // Kenzie
+        NBTBase base = get(key);
+        return base instanceof NBTTagList ? (mx.kenzie.wellspring.nbt.NBTList) base : null;
+    }
+
     public NBTTagList getList(String s, int i) {
         try {
             if (this.d(s) == 9) {
@@ -476,12 +522,17 @@ public class NBTTagCompound implements NBTBase {
         }
     }
 
+    @Override
+    public NBTCompound merge(NBTCompound compound) {
+        if (!(compound instanceof NBTTagCompound)) throw new IllegalArgumentException("Unknown compound extender type!");
+        NBTTagCompound raw = ((NBTTagCompound) compound);
+        return this.a(raw);
+    }
+
     public NBTTagCompound a(NBTTagCompound nbttagcompound) {
-        Iterator iterator = nbttagcompound.map.keySet().iterator();
 
-        while (iterator.hasNext()) {
-            String s = (String) iterator.next();
-            NBTBase nbtbase = (NBTBase) nbttagcompound.map.get(s);
+        for (String s : nbttagcompound.map.keySet()) {
+            NBTBase nbtbase = nbttagcompound.map.get(s);
 
             if (nbtbase.getTypeId() == 10) {
                 if (this.hasKeyOfType(s, 10)) {
@@ -539,7 +590,7 @@ public class NBTTagCompound implements NBTBase {
             for (Iterator iterator = ((Collection) collection).iterator(); iterator.hasNext(); chatcomponenttext.addSibling(ichatmutablecomponent)) {
                 String s1 = (String) iterator.next();
 
-                ichatmutablecomponent = (new ChatComponentText(Strings.repeat(s, i + 1))).addSibling(t(s1)).c(String.valueOf(':')).c(" ").addSibling(((NBTBase) this.map.get(s1)).a(s, i + 1));
+                ichatmutablecomponent = (new ChatComponentText(Strings.repeat(s, i + 1))).addSibling(t(s1)).c(String.valueOf(':')).c(" ").addSibling(this.map.get(s1).a(s, i + 1));
                 if (iterator.hasNext()) {
                     ichatmutablecomponent.c(String.valueOf(',')).c(s.isEmpty() ? " " : "\n");
                 }
@@ -554,6 +605,16 @@ public class NBTTagCompound implements NBTBase {
         }
     }
 
+    @Override
+    public void clear() { // Kenzie
+        map.clear();
+    }
+
+    @Override
+    public Map<String, NBT> getAsMap() {
+        return new HashMap<>(h());
+    }
+
     protected Map<String, NBTBase> h() {
         return Collections.unmodifiableMap(this.map);
     }
diff --git a/src/main/java/net/minecraft/server/NBTTagList.java b/src/main/java/net/minecraft/server/NBTTagList.java
index ad4807e0bdd6409bd798f995da8f43cec1d0b385..c4c592d4871c83d61f6b5e62bd846b55e084cc9c 100644
--- a/src/main/java/net/minecraft/server/NBTTagList.java
+++ b/src/main/java/net/minecraft/server/NBTTagList.java
@@ -5,15 +5,14 @@ import com.google.common.collect.Iterables;
 import com.google.common.collect.Lists;
 import it.unimi.dsi.fastutil.bytes.ByteOpenHashSet;
 import it.unimi.dsi.fastutil.bytes.ByteSet;
+import mx.kenzie.wellspring.nbt.NBT;
+
 import java.io.DataInput;
 import java.io.DataOutput;
 import java.io.IOException;
-import java.util.Arrays;
-import java.util.Iterator;
-import java.util.List;
-import java.util.Objects;
+import java.util.*;
 
-public class NBTTagList extends NBTList<NBTBase> {
+public class NBTTagList extends NBTList<NBTBase> implements mx.kenzie.wellspring.nbt.NBTList {
 
     public static final NBTTagType<NBTTagList> a = new NBTTagType<NBTTagList>() {
         @Override
@@ -356,4 +355,34 @@ public class NBTTagList extends NBTList<NBTBase> {
         this.list.clear();
         this.type = 0;
     }
+
+    // Kenzie start
+
+    @Override
+    public void add(NBT base) {
+        super.add((NBTBase) base);
+    }
+
+    @Override
+    public void remove(NBT entry) {
+        super.remove(entry);
+    }
+
+    @Override
+    public Collection<NBT> getAsList() {
+        return Arrays.asList(this.getAsArray());
+    }
+
+    @Override
+    public NBT[] getAsArray() {
+        return this.toArray(new NBT[0]);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public Iterator<NBT> getIterator() {
+        return (Iterator<NBT>) (Iterator<?>) iterator();
+    }
+
+    // Kenzie end
 }
diff --git a/src/main/java/net/minecraft/server/Packet.java b/src/main/java/net/minecraft/server/Packet.java
index 545dbe6ddcce1d172f465b4a7ab85654ee5fdbb4..e4be8e61c005a897151b4dc82be04a70aa829bd1 100644
--- a/src/main/java/net/minecraft/server/Packet.java
+++ b/src/main/java/net/minecraft/server/Packet.java
@@ -3,7 +3,7 @@ package net.minecraft.server;
 import io.netty.channel.ChannelFuture; // Paper
 import java.io.IOException;
 
-public interface Packet<T extends PacketListener> {
+public interface Packet<T extends PacketListener> extends mx.kenzie.wellspring.packet.Packet { // Kenzie
 
     void a(PacketDataSerializer packetdataserializer) throws IOException;
 
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntity.java b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntity.java
index 5172fb5ab86d0e60cca85282f321ee2892c95915..d6af9f4ca10bec207c28703d828d0c97130c7325 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntity.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntity.java
@@ -40,7 +40,7 @@ public class PacketPlayOutSpawnEntity implements Packet<PacketListenerPlayOut> {
     }
 
     public PacketPlayOutSpawnEntity(Entity entity, int i) {
-        this(entity.getId(), entity.getUniqueID(), entity.locX(), entity.locY(), entity.locZ(), entity.pitch, entity.yaw, entity.getEntityType(), i, entity.getMot());
+        this(entity.getId(), entity.getUniqueID(), entity.locX(), entity.locY(), entity.locZ(), entity.pitch, entity.yaw, entity.getVisualType(), i, entity.getMot()); // Kenzie
     }
 
     public PacketPlayOutSpawnEntity(Entity entity, EntityTypes<?> entitytypes, int i, BlockPosition blockposition) {
@@ -67,7 +67,7 @@ public class PacketPlayOutSpawnEntity implements Packet<PacketListenerPlayOut> {
     public void b(PacketDataSerializer packetdataserializer) throws IOException {
         packetdataserializer.d(this.a);
         packetdataserializer.a(this.b);
-        packetdataserializer.d(IRegistry.ENTITY_TYPE.a((Object) this.k));
+        packetdataserializer.d(IRegistry.ENTITY_TYPE.a(this.k));
         packetdataserializer.writeDouble(this.c);
         packetdataserializer.writeDouble(this.d);
         packetdataserializer.writeDouble(this.e);
diff --git a/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityLiving.java b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityLiving.java
index 2ce69d8feae9a4f1281c9e0422459ad23c2aab5f..058be773161b4f0b4d3d852656a24633e364bd9a 100644
--- a/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityLiving.java
+++ b/src/main/java/net/minecraft/server/PacketPlayOutSpawnEntityLiving.java
@@ -20,10 +20,34 @@ public class PacketPlayOutSpawnEntityLiving implements Packet<PacketListenerPlay
 
     public PacketPlayOutSpawnEntityLiving() {}
 
+    // Kenzie start - for packets
+    public PacketPlayOutSpawnEntityLiving(int id, UUID uuid, int type, double x, double y, double z, Vec3D vec3d, float yaw, float pitch, float headRot) {
+        a = id;
+        b = uuid;
+        c = type;
+        d = x;
+        e = y;
+        f = z;
+
+        this.j = (byte) ((int) (yaw * 256.0F / 360.0F));
+        this.k = (byte) ((int) (pitch * 256.0F / 360.0F));
+        this.l = (byte) ((int) (headRot * 256.0F / 360.0F));
+
+        double d1 = MathHelper.a(vec3d.x, -3.9D, 3.9D);
+        double d2 = MathHelper.a(vec3d.y, -3.9D, 3.9D);
+        double d3 = MathHelper.a(vec3d.z, -3.9D, 3.9D);
+
+        this.g = (int) (d1 * 8000.0D);
+        this.h = (int) (d2 * 8000.0D);
+        this.i = (int) (d3 * 8000.0D);
+    }
+
+    // Kenzie end
+
     public PacketPlayOutSpawnEntityLiving(EntityLiving entityliving) {
         this.a = entityliving.getId();
         this.b = entityliving.getUniqueID();
-        this.c = IRegistry.ENTITY_TYPE.a((Object) entityliving.getEntityType());
+        this.c = IRegistry.ENTITY_TYPE.a(entityliving.getVisualType());
         this.d = entityliving.locX();
         this.e = entityliving.locY();
         this.f = entityliving.locZ();
diff --git a/src/main/java/net/minecraft/server/PlayerInventory.java b/src/main/java/net/minecraft/server/PlayerInventory.java
index 3b65711b91c51ac7b4b5b2b0144ffd279fe60eeb..1a326a60f2330b05ac59b08c9196a4e4a0a88f78 100644
--- a/src/main/java/net/minecraft/server/PlayerInventory.java
+++ b/src/main/java/net/minecraft/server/PlayerInventory.java
@@ -7,6 +7,8 @@ import java.util.function.Predicate;
 
 // CraftBukkit start
 import java.util.ArrayList;
+
+import mx.kenzie.wellspring.nbt.NBTList;
 import org.bukkit.Location;
 import org.bukkit.craftbukkit.entity.CraftHumanEntity;
 import org.bukkit.entity.HumanEntity;
@@ -657,4 +659,16 @@ public class PlayerInventory implements IInventory, INamableTileEntity {
         }
 
     }
+
+    // Kenzie start - NBT
+    @Override
+    public NBTList getAsNBT() {
+        return a(new NBTTagList());
+    }
+
+    @Override
+    public void loadNBT(NBTList list) {
+        b((NBTTagList) list);
+    }
+    // Kenzie end
 }
diff --git a/src/main/java/net/minecraft/server/StructurePiece.java b/src/main/java/net/minecraft/server/StructurePiece.java
index 391ad288bba58dcef3e55d0137bf4483178269f5..32ae5e59e0446d57ad5f2593fc52ec29d4425765 100644
--- a/src/main/java/net/minecraft/server/StructurePiece.java
+++ b/src/main/java/net/minecraft/server/StructurePiece.java
@@ -7,9 +7,15 @@ import java.util.Random;
 import java.util.Set;
 import javax.annotation.Nullable;
 
-public abstract class StructurePiece {
-
-    protected static final IBlockData m = Blocks.CAVE_AIR.getBlockData();
+import mx.kenzie.wellspring.structure.WorldStructurePart;
+import net.minecraft.server.BlockPosition.MutableBlockPosition;
+import net.minecraft.server.EnumDirection.EnumDirectionLimit;
+import net.minecraft.server.HeightMap.Type;
+import org.bukkit.NamespacedKey;
+import org.bukkit.util.BoundingBox;
+
+public abstract class StructurePiece implements WorldStructurePart { // Kenzie
+    protected static final IBlockData m;
     protected StructureBoundingBox n;
     @Nullable
     private EnumDirection a;
@@ -17,42 +23,52 @@ public abstract class StructurePiece {
     private EnumBlockRotation c;
     protected int o;
     private final WorldGenFeatureStructurePieceType d;
-    private static final Set<Block> e = ImmutableSet.builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build();
+    private static final Set<Block> e;
 
-    protected StructurePiece(WorldGenFeatureStructurePieceType worldgenfeaturestructurepiecetype, int i) {
-        this.d = worldgenfeaturestructurepiecetype;
-        this.o = i;
+    // Kenzie start - structure parts
+    @Override
+    public BoundingBox getBoundingBox() {
+        return new BoundingBox(n.a, n.b, n.c, n.d, n.e, n.f);
     }
 
-    public StructurePiece(WorldGenFeatureStructurePieceType worldgenfeaturestructurepiecetype, NBTTagCompound nbttagcompound) {
-        this(worldgenfeaturestructurepiecetype, nbttagcompound.getInt("GD"));
-        if (nbttagcompound.hasKey("BB")) {
-            this.n = new StructureBoundingBox(nbttagcompound.getIntArray("BB"));
-        }
-
-        int i = nbttagcompound.getInt("O");
+    @Override
+    public NamespacedKey getKey() {
+        return NamespacedKey.createFrom(IRegistry.STRUCTURE_PIECE.getKey(d).toString());
+    }
+    // Kenzie end
 
-        this.a(i == -1 ? null : EnumDirection.fromType2(i));
+    protected StructurePiece(WorldGenFeatureStructurePieceType var0, int var1) {
+        this.d = var0;
+        this.o = var1;
     }
 
-    public final NBTTagCompound f() {
-        NBTTagCompound nbttagcompound = new NBTTagCompound();
+    public StructurePiece(WorldGenFeatureStructurePieceType var0, NBTTagCompound var1) {
+        this(var0, var1.getInt("GD"));
+        if (var1.hasKey("BB")) {
+            this.n = new StructureBoundingBox(var1.getIntArray("BB"));
+        }
 
-        nbttagcompound.setString("id", IRegistry.STRUCTURE_PIECE.getKey(this.k()).toString());
-        nbttagcompound.set("BB", this.n.h());
-        EnumDirection enumdirection = this.i();
+        int var2 = var1.getInt("O");
+        this.a(var2 == -1 ? null : EnumDirection.fromType2(var2));
+    }
 
-        nbttagcompound.setInt("O", enumdirection == null ? -1 : enumdirection.get2DRotationValue());
-        nbttagcompound.setInt("GD", this.o);
-        this.a(nbttagcompound);
-        return nbttagcompound;
+    public final NBTTagCompound f() {
+        NBTTagCompound var0 = new NBTTagCompound();
+        var0.setString("id", IRegistry.STRUCTURE_PIECE.getKey(this.k()).toString());
+        var0.set("BB", this.n.h());
+        EnumDirection var1 = this.i();
+        var0.setInt("O", var1 == null ? -1 : var1.get2DRotationValue());
+        var0.setInt("GD", this.o);
+        this.a(var0);
+        return var0;
     }
 
-    protected abstract void a(NBTTagCompound nbttagcompound);
+    protected abstract void a(NBTTagCompound var1);
 
-    public void a(StructurePiece structurepiece, List<StructurePiece> list, Random random) {}
+    public void a(StructurePiece var0, List<StructurePiece> var1, Random var2) {
+    }
 
-    public abstract boolean a(GeneratorAccessSeed generatoraccessseed, StructureManager structuremanager, ChunkGenerator chunkgenerator, Random random, StructureBoundingBox structureboundingbox, ChunkCoordIntPair chunkcoordintpair, BlockPosition blockposition);
+    public abstract boolean a(GeneratorAccessSeed var1, StructureManager var2, ChunkGenerator var3, Random var4, StructureBoundingBox var5, ChunkCoordIntPair var6, BlockPosition var7);
 
     public StructureBoundingBox g() {
         return this.n;
@@ -62,72 +78,69 @@ public abstract class StructurePiece {
         return this.o;
     }
 
-    public boolean a(ChunkCoordIntPair chunkcoordintpair, int i) {
-        int j = chunkcoordintpair.x << 4;
-        int k = chunkcoordintpair.z << 4;
-
-        return this.n.a(j - i, k - i, j + 15 + i, k + 15 + i);
+    public boolean a(ChunkCoordIntPair var0, int var1) {
+        int var2 = var0.x << 4;
+        int var3 = var0.z << 4;
+        return this.n.a(var2 - var1, var3 - var1, var2 + 15 + var1, var3 + 15 + var1);
     }
 
-    public static StructurePiece a(List<StructurePiece> list, StructureBoundingBox structureboundingbox) {
-        Iterator iterator = list.iterator();
-
-        StructurePiece structurepiece;
+    public static StructurePiece a(List<StructurePiece> var0, StructureBoundingBox var1) {
+        Iterator var2 = var0.iterator();
 
+        StructurePiece var3;
         do {
-            if (!iterator.hasNext()) {
+            if (!var2.hasNext()) {
                 return null;
             }
 
-            structurepiece = (StructurePiece) iterator.next();
-        } while (structurepiece.g() == null || !structurepiece.g().b(structureboundingbox));
+            var3 = (StructurePiece)var2.next();
+        } while(var3.g() == null || !var3.g().b(var1));
 
-        return structurepiece;
+        return var3;
     }
 
-    protected boolean a(IBlockAccess iblockaccess, StructureBoundingBox structureboundingbox) {
-        int i = Math.max(this.n.a - 1, structureboundingbox.a);
-        int j = Math.max(this.n.b - 1, structureboundingbox.b);
-        int k = Math.max(this.n.c - 1, structureboundingbox.c);
-        int l = Math.min(this.n.d + 1, structureboundingbox.d);
-        int i1 = Math.min(this.n.e + 1, structureboundingbox.e);
-        int j1 = Math.min(this.n.f + 1, structureboundingbox.f);
-        BlockPosition.MutableBlockPosition blockposition_mutableblockposition = new BlockPosition.MutableBlockPosition();
-
-        int k1;
-        int l1;
-
-        for (k1 = i; k1 <= l; ++k1) {
-            for (l1 = k; l1 <= j1; ++l1) {
-                if (iblockaccess.getType(blockposition_mutableblockposition.d(k1, j, l1)).getMaterial().isLiquid()) {
+    protected boolean a(IBlockAccess var0, StructureBoundingBox var1) {
+        int var2 = Math.max(this.n.a - 1, var1.a);
+        int var3 = Math.max(this.n.b - 1, var1.b);
+        int var4 = Math.max(this.n.c - 1, var1.c);
+        int var5 = Math.min(this.n.d + 1, var1.d);
+        int var6 = Math.min(this.n.e + 1, var1.e);
+        int var7 = Math.min(this.n.f + 1, var1.f);
+        MutableBlockPosition var8 = new MutableBlockPosition();
+
+        int var9;
+        int var10;
+        for(var9 = var2; var9 <= var5; ++var9) {
+            for(var10 = var4; var10 <= var7; ++var10) {
+                if (var0.getType(var8.d(var9, var3, var10)).getMaterial().isLiquid()) {
                     return true;
                 }
 
-                if (iblockaccess.getType(blockposition_mutableblockposition.d(k1, i1, l1)).getMaterial().isLiquid()) {
+                if (var0.getType(var8.d(var9, var6, var10)).getMaterial().isLiquid()) {
                     return true;
                 }
             }
         }
 
-        for (k1 = i; k1 <= l; ++k1) {
-            for (l1 = j; l1 <= i1; ++l1) {
-                if (iblockaccess.getType(blockposition_mutableblockposition.d(k1, l1, k)).getMaterial().isLiquid()) {
+        for(var9 = var2; var9 <= var5; ++var9) {
+            for(var10 = var3; var10 <= var6; ++var10) {
+                if (var0.getType(var8.d(var9, var10, var4)).getMaterial().isLiquid()) {
                     return true;
                 }
 
-                if (iblockaccess.getType(blockposition_mutableblockposition.d(k1, l1, j1)).getMaterial().isLiquid()) {
+                if (var0.getType(var8.d(var9, var10, var7)).getMaterial().isLiquid()) {
                     return true;
                 }
             }
         }
 
-        for (k1 = k; k1 <= j1; ++k1) {
-            for (l1 = j; l1 <= i1; ++l1) {
-                if (iblockaccess.getType(blockposition_mutableblockposition.d(i, l1, k1)).getMaterial().isLiquid()) {
+        for(var9 = var4; var9 <= var7; ++var9) {
+            for(var10 = var3; var10 <= var6; ++var10) {
+                if (var0.getType(var8.d(var2, var10, var9)).getMaterial().isLiquid()) {
                     return true;
                 }
 
-                if (iblockaccess.getType(blockposition_mutableblockposition.d(l, l1, k1)).getMaterial().isLiquid()) {
+                if (var0.getType(var8.d(var5, var10, var9)).getMaterial().isLiquid()) {
                     return true;
                 }
             }
@@ -136,114 +149,112 @@ public abstract class StructurePiece {
         return false;
     }
 
-    protected int a(int i, int j) {
-        EnumDirection enumdirection = this.i();
-
-        if (enumdirection == null) {
-            return i;
+    protected int a(int var0, int var1) {
+        EnumDirection var2 = this.i();
+        if (var2 == null) {
+            return var0;
         } else {
-            switch (enumdirection) {
+            switch(var2) {
                 case NORTH:
                 case SOUTH:
-                    return this.n.a + i;
+                    return this.n.a + var0;
                 case WEST:
-                    return this.n.d - j;
+                    return this.n.d - var1;
                 case EAST:
-                    return this.n.a + j;
+                    return this.n.a + var1;
                 default:
-                    return i;
+                    return var0;
             }
         }
     }
 
-    protected int d(int i) {
-        return this.i() == null ? i : i + this.n.b;
+    protected int d(int var0) {
+        return this.i() == null ? var0 : var0 + this.n.b;
     }
 
-    protected int b(int i, int j) {
-        EnumDirection enumdirection = this.i();
-
-        if (enumdirection == null) {
-            return j;
+    protected int b(int var0, int var1) {
+        EnumDirection var2 = this.i();
+        if (var2 == null) {
+            return var1;
         } else {
-            switch (enumdirection) {
+            switch(var2) {
                 case NORTH:
-                    return this.n.f - j;
+                    return this.n.f - var1;
                 case SOUTH:
-                    return this.n.c + j;
+                    return this.n.c + var1;
                 case WEST:
                 case EAST:
-                    return this.n.c + i;
+                    return this.n.c + var0;
                 default:
-                    return j;
+                    return var1;
             }
         }
     }
 
-    protected void a(GeneratorAccessSeed generatoraccessseed, IBlockData iblockdata, int i, int j, int k, StructureBoundingBox structureboundingbox) {
-        BlockPosition blockposition = new BlockPosition(this.a(i, k), this.d(j), this.b(i, k));
-
-        if (structureboundingbox.b((BaseBlockPosition) blockposition)) {
+    protected void a(GeneratorAccessSeed var0, IBlockData var1, int var2, int var3, int var4, StructureBoundingBox var5) {
+        BlockPosition var6 = new BlockPosition(this.a(var2, var4), this.d(var3), this.b(var2, var4));
+        if (var5.b(var6)) {
             if (this.b != EnumBlockMirror.NONE) {
-                iblockdata = iblockdata.a(this.b);
+                var1 = var1.a(this.b);
             }
 
             if (this.c != EnumBlockRotation.NONE) {
-                iblockdata = iblockdata.a(this.c);
+                var1 = var1.a(this.c);
             }
 
-            generatoraccessseed.setTypeAndData(blockposition, iblockdata, 2);
-            Fluid fluid = generatoraccessseed.getFluid(blockposition);
-
-            if (!fluid.isEmpty()) {
-                generatoraccessseed.getFluidTickList().a(blockposition, fluid.getType(), 0);
+            var0.setTypeAndData(var6, var1, 2);
+            Fluid var7 = var0.getFluid(var6);
+            if (!var7.isEmpty()) {
+                var0.getFluidTickList().a(var6, var7.getType(), 0);
             }
 
-            if (StructurePiece.e.contains(iblockdata.getBlock())) {
-                generatoraccessseed.z(blockposition).e(blockposition);
+            if (e.contains(var1.getBlock())) {
+                var0.z(var6).e(var6);
             }
 
         }
     }
 
-    protected IBlockData a(IBlockAccess iblockaccess, int i, int j, int k, StructureBoundingBox structureboundingbox) {
-        int l = this.a(i, k);
-        int i1 = this.d(j);
-        int j1 = this.b(i, k);
-        BlockPosition blockposition = new BlockPosition(l, i1, j1);
-
-        return !structureboundingbox.b((BaseBlockPosition) blockposition) ? Blocks.AIR.getBlockData() : iblockaccess.getType(blockposition);
+    protected IBlockData a(IBlockAccess var0, int var1, int var2, int var3, StructureBoundingBox var4) {
+        int var5 = this.a(var1, var3);
+        int var6 = this.d(var2);
+        int var7 = this.b(var1, var3);
+        BlockPosition var8 = new BlockPosition(var5, var6, var7);
+        return !var4.b(var8) ? Blocks.AIR.getBlockData() : var0.getType(var8);
     }
 
-    protected boolean a(IWorldReader iworldreader, int i, int j, int k, StructureBoundingBox structureboundingbox) {
-        int l = this.a(i, k);
-        int i1 = this.d(j + 1);
-        int j1 = this.b(i, k);
-        BlockPosition blockposition = new BlockPosition(l, i1, j1);
-
-        return !structureboundingbox.b((BaseBlockPosition) blockposition) ? false : i1 < iworldreader.a(HeightMap.Type.OCEAN_FLOOR_WG, l, j1);
+    protected boolean a(IWorldReader var0, int var1, int var2, int var3, StructureBoundingBox var4) {
+        int var5 = this.a(var1, var3);
+        int var6 = this.d(var2 + 1);
+        int var7 = this.b(var1, var3);
+        BlockPosition var8 = new BlockPosition(var5, var6, var7);
+        if (!var4.b(var8)) {
+            return false;
+        } else {
+            return var6 < var0.a(Type.OCEAN_FLOOR_WG, var5, var7);
+        }
     }
 
-    protected void b(GeneratorAccessSeed generatoraccessseed, StructureBoundingBox structureboundingbox, int i, int j, int k, int l, int i1, int j1) {
-        for (int k1 = j; k1 <= i1; ++k1) {
-            for (int l1 = i; l1 <= l; ++l1) {
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    this.a(generatoraccessseed, Blocks.AIR.getBlockData(), l1, k1, i2, structureboundingbox);
+    protected void b(GeneratorAccessSeed var0, StructureBoundingBox var1, int var2, int var3, int var4, int var5, int var6, int var7) {
+        for(int var8 = var3; var8 <= var6; ++var8) {
+            for(int var9 = var2; var9 <= var5; ++var9) {
+                for(int var10 = var4; var10 <= var7; ++var10) {
+                    this.a(var0, Blocks.AIR.getBlockData(), var9, var8, var10, var1);
                 }
             }
         }
 
     }
 
-    protected void a(GeneratorAccessSeed generatoraccessseed, StructureBoundingBox structureboundingbox, int i, int j, int k, int l, int i1, int j1, IBlockData iblockdata, IBlockData iblockdata1, boolean flag) {
-        for (int k1 = j; k1 <= i1; ++k1) {
-            for (int l1 = i; l1 <= l; ++l1) {
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    if (!flag || !this.a((IBlockAccess) generatoraccessseed, l1, k1, i2, structureboundingbox).isAir()) {
-                        if (k1 != j && k1 != i1 && l1 != i && l1 != l && i2 != k && i2 != j1) {
-                            this.a(generatoraccessseed, iblockdata1, l1, k1, i2, structureboundingbox);
+    protected void a(GeneratorAccessSeed var0, StructureBoundingBox var1, int var2, int var3, int var4, int var5, int var6, int var7, IBlockData var8, IBlockData var9, boolean var10) {
+        for(int var11 = var3; var11 <= var6; ++var11) {
+            for(int var12 = var2; var12 <= var5; ++var12) {
+                for(int var13 = var4; var13 <= var7; ++var13) {
+                    if (!var10 || !this.a((IBlockAccess)var0, var12, var11, var13, var1).isAir()) {
+                        if (var11 != var3 && var11 != var6 && var12 != var2 && var12 != var5 && var13 != var4 && var13 != var7) {
+                            this.a(var0, var9, var12, var11, var13, var1);
                         } else {
-                            this.a(generatoraccessseed, iblockdata, l1, k1, i2, structureboundingbox);
+                            this.a(var0, var8, var12, var11, var13, var1);
                         }
                     }
                 }
@@ -252,13 +263,13 @@ public abstract class StructurePiece {
 
     }
 
-    protected void a(GeneratorAccessSeed generatoraccessseed, StructureBoundingBox structureboundingbox, int i, int j, int k, int l, int i1, int j1, boolean flag, Random random, StructurePiece.StructurePieceBlockSelector structurepiece_structurepieceblockselector) {
-        for (int k1 = j; k1 <= i1; ++k1) {
-            for (int l1 = i; l1 <= l; ++l1) {
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    if (!flag || !this.a((IBlockAccess) generatoraccessseed, l1, k1, i2, structureboundingbox).isAir()) {
-                        structurepiece_structurepieceblockselector.a(random, l1, k1, i2, k1 == j || k1 == i1 || l1 == i || l1 == l || i2 == k || i2 == j1);
-                        this.a(generatoraccessseed, structurepiece_structurepieceblockselector.a(), l1, k1, i2, structureboundingbox);
+    protected void a(GeneratorAccessSeed var0, StructureBoundingBox var1, int var2, int var3, int var4, int var5, int var6, int var7, boolean var8, Random var9, StructurePiece.StructurePieceBlockSelector var10) {
+        for(int var11 = var3; var11 <= var6; ++var11) {
+            for(int var12 = var2; var12 <= var5; ++var12) {
+                for(int var13 = var4; var13 <= var7; ++var13) {
+                    if (!var8 || !this.a((IBlockAccess)var0, var12, var11, var13, var1).isAir()) {
+                        var10.a(var9, var12, var11, var13, var11 == var3 || var11 == var6 || var12 == var2 || var12 == var5 || var13 == var4 || var13 == var7);
+                        this.a(var0, var10.a(), var12, var11, var13, var1);
                     }
                 }
             }
@@ -266,15 +277,15 @@ public abstract class StructurePiece {
 
     }
 
-    protected void a(GeneratorAccessSeed generatoraccessseed, StructureBoundingBox structureboundingbox, Random random, float f, int i, int j, int k, int l, int i1, int j1, IBlockData iblockdata, IBlockData iblockdata1, boolean flag, boolean flag1) {
-        for (int k1 = j; k1 <= i1; ++k1) {
-            for (int l1 = i; l1 <= l; ++l1) {
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    if (random.nextFloat() <= f && (!flag || !this.a((IBlockAccess) generatoraccessseed, l1, k1, i2, structureboundingbox).isAir()) && (!flag1 || this.a((IWorldReader) generatoraccessseed, l1, k1, i2, structureboundingbox))) {
-                        if (k1 != j && k1 != i1 && l1 != i && l1 != l && i2 != k && i2 != j1) {
-                            this.a(generatoraccessseed, iblockdata1, l1, k1, i2, structureboundingbox);
+    protected void a(GeneratorAccessSeed var0, StructureBoundingBox var1, Random var2, float var3, int var4, int var5, int var6, int var7, int var8, int var9, IBlockData var10, IBlockData var11, boolean var12, boolean var13) {
+        for(int var14 = var5; var14 <= var8; ++var14) {
+            for(int var15 = var4; var15 <= var7; ++var15) {
+                for(int var16 = var6; var16 <= var9; ++var16) {
+                    if (var2.nextFloat() <= var3 && (!var12 || !this.a((IBlockAccess)var0, var15, var14, var16, var1).isAir()) && (!var13 || this.a((IWorldReader)var0, var15, var14, var16, var1))) {
+                        if (var14 != var5 && var14 != var8 && var15 != var4 && var15 != var7 && var16 != var6 && var16 != var9) {
+                            this.a(var0, var11, var15, var14, var16, var1);
                         } else {
-                            this.a(generatoraccessseed, iblockdata, l1, k1, i2, structureboundingbox);
+                            this.a(var0, var10, var15, var14, var16, var1);
                         }
                     }
                 }
@@ -283,34 +294,32 @@ public abstract class StructurePiece {
 
     }
 
-    protected void a(GeneratorAccessSeed generatoraccessseed, StructureBoundingBox structureboundingbox, Random random, float f, int i, int j, int k, IBlockData iblockdata) {
-        if (random.nextFloat() < f) {
-            this.a(generatoraccessseed, iblockdata, i, j, k, structureboundingbox);
+    protected void a(GeneratorAccessSeed var0, StructureBoundingBox var1, Random var2, float var3, int var4, int var5, int var6, IBlockData var7) {
+        if (var2.nextFloat() < var3) {
+            this.a(var0, var7, var4, var5, var6, var1);
         }
 
     }
 
-    protected void a(GeneratorAccessSeed generatoraccessseed, StructureBoundingBox structureboundingbox, int i, int j, int k, int l, int i1, int j1, IBlockData iblockdata, boolean flag) {
-        float f = (float) (l - i + 1);
-        float f1 = (float) (i1 - j + 1);
-        float f2 = (float) (j1 - k + 1);
-        float f3 = (float) i + f / 2.0F;
-        float f4 = (float) k + f2 / 2.0F;
-
-        for (int k1 = j; k1 <= i1; ++k1) {
-            float f5 = (float) (k1 - j) / f1;
-
-            for (int l1 = i; l1 <= l; ++l1) {
-                float f6 = ((float) l1 - f3) / (f * 0.5F);
-
-                for (int i2 = k; i2 <= j1; ++i2) {
-                    float f7 = ((float) i2 - f4) / (f2 * 0.5F);
-
-                    if (!flag || !this.a((IBlockAccess) generatoraccessseed, l1, k1, i2, structureboundingbox).isAir()) {
-                        float f8 = f6 * f6 + f5 * f5 + f7 * f7;
-
-                        if (f8 <= 1.05F) {
-                            this.a(generatoraccessseed, iblockdata, l1, k1, i2, structureboundingbox);
+    protected void a(GeneratorAccessSeed var0, StructureBoundingBox var1, int var2, int var3, int var4, int var5, int var6, int var7, IBlockData var8, boolean var9) {
+        float var10 = (float)(var5 - var2 + 1);
+        float var11 = (float)(var6 - var3 + 1);
+        float var12 = (float)(var7 - var4 + 1);
+        float var13 = (float)var2 + var10 / 2.0F;
+        float var14 = (float)var4 + var12 / 2.0F;
+
+        for(int var15 = var3; var15 <= var6; ++var15) {
+            float var16 = (float)(var15 - var3) / var11;
+
+            for(int var17 = var2; var17 <= var5; ++var17) {
+                float var18 = ((float)var17 - var13) / (var10 * 0.5F);
+
+                for(int var19 = var4; var19 <= var7; ++var19) {
+                    float var20 = ((float)var19 - var14) / (var12 * 0.5F);
+                    if (!var9 || !this.a((IBlockAccess)var0, var17, var15, var19, var1).isAir()) {
+                        float var21 = var18 * var18 + var16 * var16 + var20 * var20;
+                        if (var21 <= 1.05F) {
+                            this.a(var0, var8, var17, var15, var19, var1);
                         }
                     }
                 }
@@ -319,85 +328,78 @@ public abstract class StructurePiece {
 
     }
 
-    protected void b(GeneratorAccessSeed generatoraccessseed, IBlockData iblockdata, int i, int j, int k, StructureBoundingBox structureboundingbox) {
-        int l = this.a(i, k);
-        int i1 = this.d(j);
-        int j1 = this.b(i, k);
-
-        if (structureboundingbox.b((BaseBlockPosition) (new BlockPosition(l, i1, j1)))) {
-            while ((generatoraccessseed.isEmpty(new BlockPosition(l, i1, j1)) || generatoraccessseed.getType(new BlockPosition(l, i1, j1)).getMaterial().isLiquid()) && i1 > 1) {
-                generatoraccessseed.setTypeAndData(new BlockPosition(l, i1, j1), iblockdata, 2);
-                --i1;
+    protected void b(GeneratorAccessSeed var0, IBlockData var1, int var2, int var3, int var4, StructureBoundingBox var5) {
+        int var6 = this.a(var2, var4);
+        int var7 = this.d(var3);
+        int var8 = this.b(var2, var4);
+        if (var5.b(new BlockPosition(var6, var7, var8))) {
+            while((var0.isEmpty(new BlockPosition(var6, var7, var8)) || var0.getType(new BlockPosition(var6, var7, var8)).getMaterial().isLiquid()) && var7 > 1) {
+                var0.setTypeAndData(new BlockPosition(var6, var7, var8), var1, 2);
+                --var7;
             }
 
         }
     }
 
-    protected boolean a(GeneratorAccessSeed generatoraccessseed, StructureBoundingBox structureboundingbox, Random random, int i, int j, int k, MinecraftKey minecraftkey) {
-        BlockPosition blockposition = new BlockPosition(this.a(i, k), this.d(j), this.b(i, k));
-
-        return this.a(generatoraccessseed, structureboundingbox, random, blockposition, minecraftkey, (IBlockData) null);
+    protected boolean a(GeneratorAccessSeed var0, StructureBoundingBox var1, Random var2, int var3, int var4, int var5, MinecraftKey var6) {
+        BlockPosition var7 = new BlockPosition(this.a(var3, var5), this.d(var4), this.b(var3, var5));
+        return this.a(var0, var1, var2, var7, var6, (IBlockData)null);
     }
 
-    public static IBlockData a(IBlockAccess iblockaccess, BlockPosition blockposition, IBlockData iblockdata) {
-        EnumDirection enumdirection = null;
-        Iterator iterator = EnumDirection.EnumDirectionLimit.HORIZONTAL.iterator();
-
-        while (iterator.hasNext()) {
-            EnumDirection enumdirection1 = (EnumDirection) iterator.next();
-            BlockPosition blockposition1 = blockposition.shift(enumdirection1);
-            IBlockData iblockdata1 = iblockaccess.getType(blockposition1);
+    public static IBlockData a(IBlockAccess var0, BlockPosition var1, IBlockData var2) {
+        EnumDirection var3 = null;
 
-            if (iblockdata1.a(Blocks.CHEST)) {
-                return iblockdata;
+        for (EnumDirection var5 : EnumDirectionLimit.HORIZONTAL) { // Kenzie - decompile error
+            BlockPosition var6 = var1.shift(var5);
+            IBlockData var7 = var0.getType(var6);
+            if (var7.a(Blocks.CHEST)) {
+                return var2;
             }
 
-            if (iblockdata1.i(iblockaccess, blockposition1)) {
-                if (enumdirection != null) {
-                    enumdirection = null;
+            if (var7.i(var0, var6)) {
+                if (var3 != null) {
+                    var3 = null;
                     break;
                 }
 
-                enumdirection = enumdirection1;
+                var3 = var5;
             }
         }
 
-        if (enumdirection != null) {
-            return (IBlockData) iblockdata.set(BlockFacingHorizontal.FACING, enumdirection.opposite());
+        if (var3 != null) {
+            return (IBlockData)var2.set(BlockFacingHorizontal.FACING, var3.opposite());
         } else {
-            EnumDirection enumdirection2 = (EnumDirection) iblockdata.get(BlockFacingHorizontal.FACING);
-            BlockPosition blockposition2 = blockposition.shift(enumdirection2);
-
-            if (iblockaccess.getType(blockposition2).i(iblockaccess, blockposition2)) {
-                enumdirection2 = enumdirection2.opposite();
-                blockposition2 = blockposition.shift(enumdirection2);
+            EnumDirection var4 = (EnumDirection)var2.get(BlockFacingHorizontal.FACING);
+            BlockPosition var5 = var1.shift(var4);
+            if (var0.getType(var5).i(var0, var5)) {
+                var4 = var4.opposite();
+                var5 = var1.shift(var4);
             }
 
-            if (iblockaccess.getType(blockposition2).i(iblockaccess, blockposition2)) {
-                enumdirection2 = enumdirection2.g();
-                blockposition2 = blockposition.shift(enumdirection2);
+            if (var0.getType(var5).i(var0, var5)) {
+                var4 = var4.g();
+                var5 = var1.shift(var4);
             }
 
-            if (iblockaccess.getType(blockposition2).i(iblockaccess, blockposition2)) {
-                enumdirection2 = enumdirection2.opposite();
-                blockposition.shift(enumdirection2);
+            if (var0.getType(var5).i(var0, var5)) {
+                var4 = var4.opposite();
+                var1.shift(var4);
             }
 
-            return (IBlockData) iblockdata.set(BlockFacingHorizontal.FACING, enumdirection2);
+            return (IBlockData)var2.set(BlockFacingHorizontal.FACING, var4);
         }
     }
 
-    protected boolean a(WorldAccess worldaccess, StructureBoundingBox structureboundingbox, Random random, BlockPosition blockposition, MinecraftKey minecraftkey, @Nullable IBlockData iblockdata) {
-        if (structureboundingbox.b((BaseBlockPosition) blockposition) && !worldaccess.getType(blockposition).a(Blocks.CHEST)) {
-            if (iblockdata == null) {
-                iblockdata = a((IBlockAccess) worldaccess, blockposition, Blocks.CHEST.getBlockData());
+    protected boolean a(WorldAccess var0, StructureBoundingBox var1, Random var2, BlockPosition var3, MinecraftKey var4, @Nullable IBlockData var5) {
+        if (var1.b(var3) && !var0.getType(var3).a(Blocks.CHEST)) {
+            if (var5 == null) {
+                var5 = a((IBlockAccess)var0, (BlockPosition)var3, (IBlockData)Blocks.CHEST.getBlockData());
             }
 
-            worldaccess.setTypeAndData(blockposition, iblockdata, 2);
-            TileEntity tileentity = worldaccess.getTileEntity(blockposition);
-
-            if (tileentity instanceof TileEntityChest) {
-                ((TileEntityChest) tileentity).setLootTable(minecraftkey, random.nextLong());
+            var0.setTypeAndData(var3, var5, 2);
+            TileEntity var6 = var0.getTileEntity(var3);
+            if (var6 instanceof TileEntityChest) {
+                ((TileEntityChest)var6).setLootTable(var4, var2.nextLong());
             }
 
             return true;
@@ -406,15 +408,13 @@ public abstract class StructurePiece {
         }
     }
 
-    protected boolean a(GeneratorAccessSeed generatoraccessseed, StructureBoundingBox structureboundingbox, Random random, int i, int j, int k, EnumDirection enumdirection, MinecraftKey minecraftkey) {
-        BlockPosition blockposition = new BlockPosition(this.a(i, k), this.d(j), this.b(i, k));
-
-        if (structureboundingbox.b((BaseBlockPosition) blockposition) && !generatoraccessseed.getType(blockposition).a(Blocks.DISPENSER)) {
-            this.a(generatoraccessseed, (IBlockData) Blocks.DISPENSER.getBlockData().set(BlockDispenser.FACING, enumdirection), i, j, k, structureboundingbox);
-            TileEntity tileentity = generatoraccessseed.getTileEntity(blockposition);
-
-            if (tileentity instanceof TileEntityDispenser) {
-                ((TileEntityDispenser) tileentity).setLootTable(minecraftkey, random.nextLong());
+    protected boolean a(GeneratorAccessSeed var0, StructureBoundingBox var1, Random var2, int var3, int var4, int var5, EnumDirection var6, MinecraftKey var7) {
+        BlockPosition var8 = new BlockPosition(this.a(var3, var5), this.d(var4), this.b(var3, var5));
+        if (var1.b(var8) && !var0.getType(var8).a(Blocks.DISPENSER)) {
+            this.a(var0, (IBlockData)Blocks.DISPENSER.getBlockData().set(BlockDispenser.FACING, var6), var3, var4, var5, var1);
+            TileEntity var9 = var0.getTileEntity(var8);
+            if (var9 instanceof TileEntityDispenser) {
+                ((TileEntityDispenser)var9).setLootTable(var7, var2.nextLong());
             }
 
             return true;
@@ -423,8 +423,8 @@ public abstract class StructurePiece {
         }
     }
 
-    public void a(int i, int j, int k) {
-        this.n.a(i, j, k);
+    public void a(int var0, int var1, int var2) {
+        this.n.a(var0, var1, var2);
     }
 
     @Nullable
@@ -432,13 +432,13 @@ public abstract class StructurePiece {
         return this.a;
     }
 
-    public void a(@Nullable EnumDirection enumdirection) {
-        this.a = enumdirection;
-        if (enumdirection == null) {
+    public void a(@Nullable EnumDirection var0) {
+        this.a = var0;
+        if (var0 == null) {
             this.c = EnumBlockRotation.NONE;
             this.b = EnumBlockMirror.NONE;
         } else {
-            switch (enumdirection) {
+            switch(var0) {
                 case SOUTH:
                     this.b = EnumBlockMirror.LEFT_RIGHT;
                     this.c = EnumBlockRotation.NONE;
@@ -467,15 +467,19 @@ public abstract class StructurePiece {
         return this.d;
     }
 
-    public abstract static class StructurePieceBlockSelector {
+    static {
+        m = Blocks.CAVE_AIR.getBlockData();
+        e = ImmutableSet.<Block>builder().add(Blocks.NETHER_BRICK_FENCE).add(Blocks.TORCH).add(Blocks.WALL_TORCH).add(Blocks.OAK_FENCE).add(Blocks.SPRUCE_FENCE).add(Blocks.DARK_OAK_FENCE).add(Blocks.ACACIA_FENCE).add(Blocks.BIRCH_FENCE).add(Blocks.JUNGLE_FENCE).add(Blocks.LADDER).add(Blocks.IRON_BARS).build(); // Kenzie - decompile error
+    }
 
+    public abstract static class StructurePieceBlockSelector {
         protected IBlockData a;
 
         protected StructurePieceBlockSelector() {
             this.a = Blocks.AIR.getBlockData();
         }
 
-        public abstract void a(Random random, int i, int j, int k, boolean flag);
+        public abstract void a(Random var1, int var2, int var3, int var4, boolean var5);
 
         public IBlockData a() {
             return this.a;
diff --git a/src/main/java/net/minecraft/server/StructureStart.java b/src/main/java/net/minecraft/server/StructureStart.java
index d27b4be211cce4f8754732021f0a31852d748b17..e3ddcf9fc41da4969d017ec9548a25dd5647aaa2 100644
--- a/src/main/java/net/minecraft/server/StructureStart.java
+++ b/src/main/java/net/minecraft/server/StructureStart.java
@@ -1,15 +1,18 @@
 package net.minecraft.server;
 
 import com.google.common.collect.Lists;
+import mx.kenzie.wellspring.structure.WorldStructure;
+import mx.kenzie.wellspring.structure.WorldStructurePart;
+import org.bukkit.NamespacedKey;
+import org.bukkit.util.BoundingBox;
+
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 import java.util.Random;
 
-public abstract class StructureStart<C extends WorldGenFeatureConfiguration> {
-
-    public static final StructureStart<?> a = new StructureStart<WorldGenMineshaftConfiguration>(StructureGenerator.MINESHAFT, 0, 0, StructureBoundingBox.a(), 0, 0L) {
-        public void a(IRegistryCustom iregistrycustom, ChunkGenerator chunkgenerator, DefinedStructureManager definedstructuremanager, int i, int j, BiomeBase biomebase, WorldGenMineshaftConfiguration worldgenmineshaftconfiguration) {}
-    };
+public abstract class StructureStart<C extends WorldGenFeatureConfiguration> implements WorldStructure { // Kenzie
+    public static final StructureStart<?> a;
     private final StructureGenerator<C> e;
     protected final List<StructurePiece> b = Lists.newArrayList();
     protected StructureBoundingBox c;
@@ -18,17 +21,34 @@ public abstract class StructureStart<C extends WorldGenFeatureConfiguration> {
     private int h;
     protected final SeededRandom d;
 
-    public StructureStart(StructureGenerator<C> structuregenerator, int i, int j, StructureBoundingBox structureboundingbox, int k, long l) {
-        this.e = structuregenerator;
-        this.f = i;
-        this.g = j;
-        this.h = k;
+    // Kenzie start - structure parts
+    @Override
+    public BoundingBox getBoundingBox() {
+        return new BoundingBox(c.a, c.b, c.c, c.d, c.e, c.f);
+    }
+
+    @Override
+    public List<WorldStructurePart> getParts() {
+        return new ArrayList<>(b); // Don't back with original copy
+    }
+
+    @Override
+    public NamespacedKey getKey() {
+        return NamespacedKey.createFrom(IRegistry.STRUCTURE_FEATURE.getKey(e).toString());
+    }
+    // Kenzie end
+
+    public StructureStart(StructureGenerator<C> var0, int var1, int var2, StructureBoundingBox var3, int var4, long var5) {
+        this.e = var0;
+        this.f = var1;
+        this.g = var2;
+        this.h = var4;
         this.d = new SeededRandom();
-        this.d.c(l, i, j);
-        this.c = structureboundingbox;
+        this.d.c(var5, var1, var2);
+        this.c = var3;
     }
 
-    public abstract void a(IRegistryCustom iregistrycustom, ChunkGenerator chunkgenerator, DefinedStructureManager definedstructuremanager, int i, int j, BiomeBase biomebase, C c0);
+    public abstract void a(IRegistryCustom var1, ChunkGenerator var2, DefinedStructureManager var3, int var4, int var5, BiomeBase var6, C var7);
 
     public StructureBoundingBox c() {
         return this.c;
@@ -38,21 +58,18 @@ public abstract class StructureStart<C extends WorldGenFeatureConfiguration> {
         return this.b;
     }
 
-    public void a(GeneratorAccessSeed generatoraccessseed, StructureManager structuremanager, ChunkGenerator chunkgenerator, Random random, StructureBoundingBox structureboundingbox, ChunkCoordIntPair chunkcoordintpair) {
-        List list = this.b;
-
-        synchronized (this.b) {
+    public void a(GeneratorAccessSeed var0, StructureManager var1, ChunkGenerator var2, Random var3, StructureBoundingBox var4, ChunkCoordIntPair var5) {
+        synchronized(this.b) {
             if (!this.b.isEmpty()) {
-                StructureBoundingBox structureboundingbox1 = ((StructurePiece) this.b.get(0)).n;
-                BaseBlockPosition baseblockposition = structureboundingbox1.g();
-                BlockPosition blockposition = new BlockPosition(baseblockposition.getX(), structureboundingbox1.b, baseblockposition.getZ());
-                Iterator iterator = this.b.iterator();
-
-                while (iterator.hasNext()) {
-                    StructurePiece structurepiece = (StructurePiece) iterator.next();
-
-                    if (structurepiece.g().b(structureboundingbox) && !structurepiece.a(generatoraccessseed, structuremanager, chunkgenerator, random, structureboundingbox, chunkcoordintpair, blockposition)) {
-                        iterator.remove();
+                StructureBoundingBox var7 = ((StructurePiece)this.b.get(0)).n;
+                BaseBlockPosition var8 = var7.g();
+                BlockPosition var9 = new BlockPosition(var8.getX(), var7.b, var8.getZ());
+                Iterator var10 = this.b.iterator();
+
+                while(var10.hasNext()) {
+                    StructurePiece var11 = (StructurePiece)var10.next();
+                    if (var11.g().b(var4) && !var11.a(var0, var1, var2, var3, var4, var5, var9)) {
+                        var10.remove();
                     }
                 }
 
@@ -63,86 +80,70 @@ public abstract class StructureStart<C extends WorldGenFeatureConfiguration> {
 
     protected void b() {
         this.c = StructureBoundingBox.a();
-        Iterator iterator = this.b.iterator();
-
-        while (iterator.hasNext()) {
-            StructurePiece structurepiece = (StructurePiece) iterator.next();
-
-            this.c.c(structurepiece.g());
+        for (StructurePiece var1 : this.b) { // Kenzie - decompile error
+            this.c.c(var1.g());
         }
 
     }
 
-    public NBTTagCompound a(int i, int j) {
-        NBTTagCompound nbttagcompound = new NBTTagCompound();
-
+    public NBTTagCompound a(int var0, int var1) {
+        NBTTagCompound var2 = new NBTTagCompound();
         if (this.e()) {
-            nbttagcompound.setString("id", IRegistry.STRUCTURE_FEATURE.getKey(this.l()).toString());
-            nbttagcompound.setInt("ChunkX", i);
-            nbttagcompound.setInt("ChunkZ", j);
-            nbttagcompound.setInt("references", this.h);
-            nbttagcompound.set("BB", this.c.h());
-            NBTTagList nbttaglist = new NBTTagList();
-            List list = this.b;
-
-            synchronized (this.b) {
-                Iterator iterator = this.b.iterator();
-
-                while (iterator.hasNext()) {
-                    StructurePiece structurepiece = (StructurePiece) iterator.next();
+            var2.setString("id", IRegistry.STRUCTURE_FEATURE.getKey(this.l()).toString());
+            var2.setInt("ChunkX", var0);
+            var2.setInt("ChunkZ", var1);
+            var2.setInt("references", this.h);
+            var2.set("BB", this.c.h());
+            NBTTagList var3 = new NBTTagList();
+            synchronized(this.b) {
+                Iterator var6 = this.b.iterator();
+
+                while(true) {
+                    if (!var6.hasNext()) {
+                        break;
+                    }
 
-                    nbttaglist.add(structurepiece.f());
+                    StructurePiece piece = (StructurePiece)var6.next(); // Kenzie - decompile error
+                    var3.add(piece.f());
                 }
             }
 
-            nbttagcompound.set("Children", nbttaglist);
-            return nbttagcompound;
+            var2.set("Children", var3);
+            return var2;
         } else {
-            nbttagcompound.setString("id", "INVALID");
-            return nbttagcompound;
+            var2.setString("id", "INVALID");
+            return var2;
         }
     }
 
-    protected void a(int i, Random random, int j) {
-        int k = i - j;
-        int l = this.c.e() + 1;
-
-        if (l < k) {
-            l += random.nextInt(k - l);
+    protected void a(int var0, Random var1, int var2) {
+        int var3 = var0 - var2;
+        int var4 = this.c.e() + 1;
+        if (var4 < var3) {
+            var4 += var1.nextInt(var3 - var4);
         }
 
-        int i1 = l - this.c.e;
-
-        this.c.a(0, i1, 0);
-        Iterator iterator = this.b.iterator();
-
-        while (iterator.hasNext()) {
-            StructurePiece structurepiece = (StructurePiece) iterator.next();
-
-            structurepiece.a(0, i1, 0);
+        int var5 = var4 - this.c.e;
+        this.c.a(0, var5, 0);
+        for (StructurePiece var7 : this.b) { // Kenzie - decompile error
+            var7.a(0, var5, 0);
         }
 
     }
 
-    protected void a(Random random, int i, int j) {
-        int k = j - i + 1 - this.c.e();
-        int l;
-
-        if (k > 1) {
-            l = i + random.nextInt(k);
+    protected void a(Random var0, int var1, int var2) {
+        int var3 = var2 - var1 + 1 - this.c.e();
+        int var4;
+        if (var3 > 1) {
+            var4 = var1 + var0.nextInt(var3);
         } else {
-            l = i;
+            var4 = var1;
         }
 
-        int i1 = l - this.c.b;
-
-        this.c.a(0, i1, 0);
-        Iterator iterator = this.b.iterator();
-
-        while (iterator.hasNext()) {
-            StructurePiece structurepiece = (StructurePiece) iterator.next();
-
-            structurepiece.a(0, i1, 0);
+        int var5 = var4 - this.c.b;
+        this.c.a(0, var5, 0);
+        for (StructurePiece var7 : this.b) { // Kenzie - decompile error
+            var7.a(0, var5, 0);
         }
 
     }
@@ -182,4 +183,11 @@ public abstract class StructureStart<C extends WorldGenFeatureConfiguration> {
     public StructureGenerator<?> l() {
         return this.e;
     }
+
+    static {
+        a = new StructureStart<WorldGenMineshaftConfiguration>(StructureGenerator.MINESHAFT, 0, 0, StructureBoundingBox.a(), 0, 0L) {
+            public void a(IRegistryCustom var0, ChunkGenerator var1, DefinedStructureManager var2, int var3, int var4, BiomeBase var5, WorldGenMineshaftConfiguration var6) {
+            }
+        };
+    }
 }
diff --git a/src/main/java/net/minecraft/server/TileEntity.java b/src/main/java/net/minecraft/server/TileEntity.java
index 58d958a88ac5af5b889d719d9f1ea90ce45cf184..9a679e0b5142b4d315344be40f501a611195bfe7 100644
--- a/src/main/java/net/minecraft/server/TileEntity.java
+++ b/src/main/java/net/minecraft/server/TileEntity.java
@@ -1,10 +1,22 @@
 package net.minecraft.server;
 
 import javax.annotation.Nullable;
+
+import mx.kenzie.server.attachment.AttachmentHolder;
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import mx.kenzie.wellspring.nbt.NBTHolder;
+import mx.kenzie.wellspring.tile.TileType;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.apache.logging.log4j.util.Supplier;
 // CraftBukkit start
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.attachment.Attachable;
+import org.bukkit.attachment.Attachment;
+import org.bukkit.block.TileState;
+import org.bukkit.craftbukkit.CraftServer;
+import org.bukkit.craftbukkit.block.CraftBlockEntityState;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
 import org.bukkit.inventory.InventoryHolder;
@@ -12,7 +24,7 @@ import org.bukkit.inventory.InventoryHolder;
 import co.aikar.timings.MinecraftTimings; // Paper
 import co.aikar.timings.Timing; // Paper
 
-public abstract class TileEntity implements KeyedObject { // Paper
+public abstract class TileEntity implements KeyedObject, mx.kenzie.wellspring.tile.TileEntity { // Kenzie // Paper
 
     public Timing tickTimer = MinecraftTimings.getTileEntityTimings(this); // Paper
     // CraftBukkit start - data containers
@@ -29,11 +41,70 @@ public abstract class TileEntity implements KeyedObject { // Paper
     @Nullable
     private IBlockData c;
     private boolean g;
+    public final AttachmentHolder attachments; // Kenzie
+
+    // Kenzie start - attachments and NBT
+    public TileState state;
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T extends Attachment<?>> T getAttachment(Class<T> attachmentClass) {
+        T attachment = (T) attachments.getByClass(attachmentClass); // This cast is fine
+        if (attachment == null) {
+            throw new NullPointerException("No attachment for this class has been registered.");
+        }
+        return attachment;
+    }
+
+    @Override
+    public <T extends Attachment<?>> boolean hasAttachment(Class<T> attachmentClass) {
+        return attachments.containsByClass(attachmentClass);
+    }
+
+    @Override
+    public NBTCompound getNBT() {
+        return this.save(new NBTTagCompound());
+    }
+
+    @Override
+    public void loadNBT(NBTCompound compound) {
+        this.load(this.getBlock(), ((NBTTagCompound) compound));
+    }
+
+    @Override
+    public TileState getState() {
+        final Location location = getLocation();
+        if (state == null && location != null) {
+            state = (TileState) location.getBlock().getState(false);
+        }
+        return state;
+    }
+
+    @Override
+    public Location getLocation() {
+        if (world == null) return null;
+        return new Location(world.getWorld(), position.getX(), position.getY(), position.getZ());
+    }
+
+    @Override
+    public TileType getType() {
+        return TileType.get(getMinecraftKey() != null ? getMinecraftKey().key : "unknown");
+    }
+    // Kenzie end
 
     public TileEntity(TileEntityTypes<?> tileentitytypes) {
         this.position = BlockPosition.ZERO;
         this.tileType = tileentitytypes;
         persistentDataContainer = new CraftPersistentDataContainer(DATA_TYPE_REGISTRY); // Paper - always init
+
+        // Kenzie start - attachments
+        this.attachments = new AttachmentHolder(this);
+        if (Bukkit.getServer() instanceof CraftServer) { // this allows the ItemMetaState test to pass
+            CraftServer server = ((CraftServer) Bukkit.getServer());
+            server.attachmentFactory.addAttachments(this, attachments);
+            server.attachmentFactory.registerAttachmentHolder(attachments);
+        }
+        // Kenzie end
     }
 
     // Paper start
@@ -72,6 +143,7 @@ public abstract class TileEntity implements KeyedObject { // Paper
     }
 
     public void setLocation(World world, BlockPosition blockposition) {
+        attachments.removeByClass(TileState.class); // Kenzie - reconstitute tile states
         this.world = world;
         this.position = blockposition.immutableCopy();
     }
@@ -81,7 +153,14 @@ public abstract class TileEntity implements KeyedObject { // Paper
     }
 
     public void load(IBlockData iblockdata, NBTTagCompound nbttagcompound) {
-        this.position = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
+        // Kenzie start - check for reconstitution
+        final BlockPosition prev = this.position;
+        final BlockPosition repl = new BlockPosition(nbttagcompound.getInt("x"), nbttagcompound.getInt("y"), nbttagcompound.getInt("z"));
+        if (!prev.equals(repl)) {
+            attachments.removeByClass(TileState.class);
+            this.position = repl;
+        }
+        // Kenzie end
         // CraftBukkit start - read container
         this.persistentDataContainer.clear(); // Paper - clear instead of reinit
 
@@ -90,6 +169,7 @@ public abstract class TileEntity implements KeyedObject { // Paper
             this.persistentDataContainer.putAll((NBTTagCompound) persistentDataTag);
         }
         // CraftBukkit end
+        attachments.load(nbttagcompound); // Kenzie - mark as data loaded in case of changes
     }
 
     public NBTTagCompound save(NBTTagCompound nbttagcompound) {
@@ -111,6 +191,7 @@ public abstract class TileEntity implements KeyedObject { // Paper
                 nbttagcompound.set("PublicBukkitValues", this.persistentDataContainer.toTagCompound());
             }
             // CraftBukkit end
+            attachments.request(nbttagcompound); // Kenzie - mark as data requested in case of changes
             return nbttagcompound;
         }
     }
diff --git a/src/main/java/net/minecraft/server/TileEntityTypes.java b/src/main/java/net/minecraft/server/TileEntityTypes.java
index 5fc302bf0631d4e0b887b7c2a4e0e5a3c78d6875..86c957a8ce84f85b35c7efd6a606c4cbd59c6b95 100644
--- a/src/main/java/net/minecraft/server/TileEntityTypes.java
+++ b/src/main/java/net/minecraft/server/TileEntityTypes.java
@@ -5,102 +5,140 @@ import com.mojang.datafixers.types.Type;
 import java.util.Set;
 import java.util.function.Supplier;
 import javax.annotation.Nullable;
+
+import mx.kenzie.wellspring.Provider;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 
 public class TileEntityTypes<T extends TileEntity> {
-
     private static final Logger LOGGER = LogManager.getLogger();
-    public static final TileEntityTypes<TileEntityFurnaceFurnace> FURNACE = a("furnace", TileEntityTypes.a.a(TileEntityFurnaceFurnace::new, Blocks.FURNACE));
-    public static final TileEntityTypes<TileEntityChest> CHEST = a("chest", TileEntityTypes.a.a(TileEntityChest::new, Blocks.CHEST));
-    public static final TileEntityTypes<TileEntityChestTrapped> TRAPPED_CHEST = a("trapped_chest", TileEntityTypes.a.a(TileEntityChestTrapped::new, Blocks.TRAPPED_CHEST));
-    public static final TileEntityTypes<TileEntityEnderChest> ENDER_CHEST = a("ender_chest", TileEntityTypes.a.a(TileEntityEnderChest::new, Blocks.ENDER_CHEST));
-    public static final TileEntityTypes<TileEntityJukeBox> JUKEBOX = a("jukebox", TileEntityTypes.a.a(TileEntityJukeBox::new, Blocks.JUKEBOX));
-    public static final TileEntityTypes<TileEntityDispenser> DISPENSER = a("dispenser", TileEntityTypes.a.a(TileEntityDispenser::new, Blocks.DISPENSER));
-    public static final TileEntityTypes<TileEntityDropper> DROPPER = a("dropper", TileEntityTypes.a.a(TileEntityDropper::new, Blocks.DROPPER));
-    public static final TileEntityTypes<TileEntitySign> SIGN = a("sign", TileEntityTypes.a.a(TileEntitySign::new, Blocks.OAK_SIGN, Blocks.SPRUCE_SIGN, Blocks.BIRCH_SIGN, Blocks.ACACIA_SIGN, Blocks.JUNGLE_SIGN, Blocks.DARK_OAK_SIGN, Blocks.OAK_WALL_SIGN, Blocks.SPRUCE_WALL_SIGN, Blocks.BIRCH_WALL_SIGN, Blocks.ACACIA_WALL_SIGN, Blocks.JUNGLE_WALL_SIGN, Blocks.DARK_OAK_WALL_SIGN, Blocks.CRIMSON_SIGN, Blocks.CRIMSON_WALL_SIGN, Blocks.WARPED_SIGN, Blocks.WARPED_WALL_SIGN));
-    public static final TileEntityTypes<TileEntityMobSpawner> MOB_SPAWNER = a("mob_spawner", TileEntityTypes.a.a(TileEntityMobSpawner::new, Blocks.SPAWNER));
-    public static final TileEntityTypes<TileEntityPiston> PISTON = a("piston", TileEntityTypes.a.a(TileEntityPiston::new, Blocks.MOVING_PISTON));
-    public static final TileEntityTypes<TileEntityBrewingStand> BREWING_STAND = a("brewing_stand", TileEntityTypes.a.a(TileEntityBrewingStand::new, Blocks.BREWING_STAND));
-    public static final TileEntityTypes<TileEntityEnchantTable> ENCHANTING_TABLE = a("enchanting_table", TileEntityTypes.a.a(TileEntityEnchantTable::new, Blocks.ENCHANTING_TABLE));
-    public static final TileEntityTypes<TileEntityEnderPortal> END_PORTAL = a("end_portal", TileEntityTypes.a.a(TileEntityEnderPortal::new, Blocks.END_PORTAL));
-    public static final TileEntityTypes<TileEntityBeacon> BEACON = a("beacon", TileEntityTypes.a.a(TileEntityBeacon::new, Blocks.BEACON));
-    public static final TileEntityTypes<TileEntitySkull> SKULL = a("skull", TileEntityTypes.a.a(TileEntitySkull::new, Blocks.SKELETON_SKULL, Blocks.SKELETON_WALL_SKULL, Blocks.CREEPER_HEAD, Blocks.CREEPER_WALL_HEAD, Blocks.DRAGON_HEAD, Blocks.DRAGON_WALL_HEAD, Blocks.ZOMBIE_HEAD, Blocks.ZOMBIE_WALL_HEAD, Blocks.WITHER_SKELETON_SKULL, Blocks.WITHER_SKELETON_WALL_SKULL, Blocks.PLAYER_HEAD, Blocks.PLAYER_WALL_HEAD));
-    public static final TileEntityTypes<TileEntityLightDetector> DAYLIGHT_DETECTOR = a("daylight_detector", TileEntityTypes.a.a(TileEntityLightDetector::new, Blocks.DAYLIGHT_DETECTOR));
-    public static final TileEntityTypes<TileEntityHopper> HOPPER = a("hopper", TileEntityTypes.a.a(TileEntityHopper::new, Blocks.HOPPER));
-    public static final TileEntityTypes<TileEntityComparator> COMPARATOR = a("comparator", TileEntityTypes.a.a(TileEntityComparator::new, Blocks.COMPARATOR));
-    public static final TileEntityTypes<TileEntityBanner> BANNER = a("banner", TileEntityTypes.a.a(TileEntityBanner::new, Blocks.WHITE_BANNER, Blocks.ORANGE_BANNER, Blocks.MAGENTA_BANNER, Blocks.LIGHT_BLUE_BANNER, Blocks.YELLOW_BANNER, Blocks.LIME_BANNER, Blocks.PINK_BANNER, Blocks.GRAY_BANNER, Blocks.LIGHT_GRAY_BANNER, Blocks.CYAN_BANNER, Blocks.PURPLE_BANNER, Blocks.BLUE_BANNER, Blocks.BROWN_BANNER, Blocks.GREEN_BANNER, Blocks.RED_BANNER, Blocks.BLACK_BANNER, Blocks.WHITE_WALL_BANNER, Blocks.ORANGE_WALL_BANNER, Blocks.MAGENTA_WALL_BANNER, Blocks.LIGHT_BLUE_WALL_BANNER, Blocks.YELLOW_WALL_BANNER, Blocks.LIME_WALL_BANNER, Blocks.PINK_WALL_BANNER, Blocks.GRAY_WALL_BANNER, Blocks.LIGHT_GRAY_WALL_BANNER, Blocks.CYAN_WALL_BANNER, Blocks.PURPLE_WALL_BANNER, Blocks.BLUE_WALL_BANNER, Blocks.BROWN_WALL_BANNER, Blocks.GREEN_WALL_BANNER, Blocks.RED_WALL_BANNER, Blocks.BLACK_WALL_BANNER));
-    public static final TileEntityTypes<TileEntityStructure> STRUCTURE_BLOCK = a("structure_block", TileEntityTypes.a.a(TileEntityStructure::new, Blocks.STRUCTURE_BLOCK));
-    public static final TileEntityTypes<TileEntityEndGateway> END_GATEWAY = a("end_gateway", TileEntityTypes.a.a(TileEntityEndGateway::new, Blocks.END_GATEWAY));
-    public static final TileEntityTypes<TileEntityCommand> COMMAND_BLOCK = a("command_block", TileEntityTypes.a.a(TileEntityCommand::new, Blocks.COMMAND_BLOCK, Blocks.CHAIN_COMMAND_BLOCK, Blocks.REPEATING_COMMAND_BLOCK));
-    public static final TileEntityTypes<TileEntityShulkerBox> SHULKER_BOX = a("shulker_box", TileEntityTypes.a.a(TileEntityShulkerBox::new, Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX));
-    public static final TileEntityTypes<TileEntityBed> BED = a("bed", TileEntityTypes.a.a(TileEntityBed::new, Blocks.RED_BED, Blocks.BLACK_BED, Blocks.BLUE_BED, Blocks.BROWN_BED, Blocks.CYAN_BED, Blocks.GRAY_BED, Blocks.GREEN_BED, Blocks.LIGHT_BLUE_BED, Blocks.LIGHT_GRAY_BED, Blocks.LIME_BED, Blocks.MAGENTA_BED, Blocks.ORANGE_BED, Blocks.PINK_BED, Blocks.PURPLE_BED, Blocks.WHITE_BED, Blocks.YELLOW_BED));
-    public static final TileEntityTypes<TileEntityConduit> CONDUIT = a("conduit", TileEntityTypes.a.a(TileEntityConduit::new, Blocks.CONDUIT));
-    public static final TileEntityTypes<TileEntityBarrel> BARREL = a("barrel", TileEntityTypes.a.a(TileEntityBarrel::new, Blocks.BARREL));
-    public static final TileEntityTypes<TileEntitySmoker> SMOKER = a("smoker", TileEntityTypes.a.a(TileEntitySmoker::new, Blocks.SMOKER));
-    public static final TileEntityTypes<TileEntityBlastFurnace> BLAST_FURNACE = a("blast_furnace", TileEntityTypes.a.a(TileEntityBlastFurnace::new, Blocks.BLAST_FURNACE));
-    public static final TileEntityTypes<TileEntityLectern> LECTERN = a("lectern", TileEntityTypes.a.a(TileEntityLectern::new, Blocks.LECTERN));
-    public static final TileEntityTypes<TileEntityBell> BELL = a("bell", TileEntityTypes.a.a(TileEntityBell::new, Blocks.BELL));
-    public static final TileEntityTypes<TileEntityJigsaw> JIGSAW = a("jigsaw", TileEntityTypes.a.a(TileEntityJigsaw::new, Blocks.JIGSAW));
-    public static final TileEntityTypes<TileEntityCampfire> CAMPFIRE = a("campfire", TileEntityTypes.a.a(TileEntityCampfire::new, Blocks.CAMPFIRE, Blocks.SOUL_CAMPFIRE));
-    public static final TileEntityTypes<TileEntityBeehive> BEEHIVE = a("beehive", TileEntityTypes.a.a(TileEntityBeehive::new, Blocks.BEE_NEST, Blocks.BEEHIVE));
-    private final Supplier<? extends T> I;
+    public static final TileEntityTypes<TileEntityFurnaceFurnace> FURNACE;
+    public static final TileEntityTypes<TileEntityChest> CHEST;
+    public static final TileEntityTypes<TileEntityChestTrapped> TRAPPED_CHEST;
+    public static final TileEntityTypes<TileEntityEnderChest> ENDER_CHEST;
+    public static final TileEntityTypes<TileEntityJukeBox> JUKEBOX;
+    public static final TileEntityTypes<TileEntityDispenser> DISPENSER;
+    public static final TileEntityTypes<TileEntityDropper> DROPPER;
+    public static final TileEntityTypes<TileEntitySign> SIGN;
+    public static final TileEntityTypes<TileEntityMobSpawner> MOB_SPAWNER;
+    public static final TileEntityTypes<TileEntityPiston> PISTON;
+    public static final TileEntityTypes<TileEntityBrewingStand> BREWING_STAND;
+    public static final TileEntityTypes<TileEntityEnchantTable> ENCHANTING_TABLE;
+    public static final TileEntityTypes<TileEntityEnderPortal> END_PORTAL;
+    public static final TileEntityTypes<TileEntityBeacon> BEACON;
+    public static final TileEntityTypes<TileEntitySkull> SKULL;
+    public static final TileEntityTypes<TileEntityLightDetector> DAYLIGHT_DETECTOR;
+    public static final TileEntityTypes<TileEntityHopper> HOPPER;
+    public static final TileEntityTypes<TileEntityComparator> COMPARATOR;
+    public static final TileEntityTypes<TileEntityBanner> BANNER;
+    public static final TileEntityTypes<TileEntityStructure> STRUCTURE_BLOCK;
+    public static final TileEntityTypes<TileEntityEndGateway> END_GATEWAY;
+    public static final TileEntityTypes<TileEntityCommand> COMMAND_BLOCK;
+    public static final TileEntityTypes<TileEntityShulkerBox> SHULKER_BOX;
+    public static final TileEntityTypes<TileEntityBed> BED;
+    public static final TileEntityTypes<TileEntityConduit> CONDUIT;
+    public static final TileEntityTypes<TileEntityBarrel> BARREL;
+    public static final TileEntityTypes<TileEntitySmoker> SMOKER;
+    public static final TileEntityTypes<TileEntityBlastFurnace> BLAST_FURNACE;
+    public static final TileEntityTypes<TileEntityLectern> LECTERN;
+    public static final TileEntityTypes<TileEntityBell> BELL;
+    public static final TileEntityTypes<TileEntityJigsaw> JIGSAW;
+    public static final TileEntityTypes<TileEntityCampfire> CAMPFIRE;
+    public static final TileEntityTypes<TileEntityBeehive> BEEHIVE;
+    private final Provider<? extends T> I; // Kenzie - typed providers
     private final Set<Block> J;
     private final Type<?> K;
 
+    public Provider<? extends T> getProvider() { // Kenzie - whole method getter
+        return I;
+    }
+
     @Nullable
-    public static MinecraftKey a(TileEntityTypes<?> tileentitytypes) {
-        return IRegistry.BLOCK_ENTITY_TYPE.getKey(tileentitytypes);
+    public static MinecraftKey a(TileEntityTypes<?> var0) {
+        return IRegistry.BLOCK_ENTITY_TYPE.getKey(var0);
     }
 
-    private static <T extends TileEntity> TileEntityTypes<T> a(String s, TileEntityTypes.a<T> tileentitytypes_a) {
-        if (tileentitytypes_a.b.isEmpty()) {
-            TileEntityTypes.LOGGER.warn("Block entity type {} requires at least one valid block to be defined!", s);
+    private static <T extends TileEntity> TileEntityTypes<T> a(String var0, TileEntityTypes.a<T> var1) {
+        if (var1.b.isEmpty()) {
+            LOGGER.warn("Block entity type {} requires at least one valid block to be defined!", var0);
         }
 
-        Type<?> type = SystemUtils.a(DataConverterTypes.BLOCK_ENTITY, s);
-
-        return (TileEntityTypes) IRegistry.a(IRegistry.BLOCK_ENTITY_TYPE, s, (Object) tileentitytypes_a.a(type));
+        Type<?> var2 = SystemUtils.a(DataConverterTypes.BLOCK_ENTITY, var0);
+        return (TileEntityTypes)IRegistry.a(IRegistry.BLOCK_ENTITY_TYPE, var0, var1.a(var2));
     }
 
-    public TileEntityTypes(Supplier<? extends T> supplier, Set<Block> set, Type<?> type) {
-        this.I = supplier;
-        this.J = set;
-        this.K = type;
+    public TileEntityTypes(Provider<? extends T> var0, Set<Block> var1, Type<?> var2) { // Kenzie - typed providers
+        this.I = var0;
+        this.J = var1;
+        this.K = var2;
     }
 
     @Nullable
     public T a() {
-        return (TileEntity) this.I.get();
+        return this.I.get(); // Kenzie - decompile error
     }
 
-    public boolean isValidBlock(Block block) {
-        return this.J.contains(block);
+    public boolean isValidBlock(Block var0) {
+        return this.J.contains(var0);
     }
 
     @Nullable
-    public T a(IBlockAccess iblockaccess, BlockPosition blockposition) {
-        TileEntity tileentity = iblockaccess.getTileEntity(blockposition);
+    public T a(IBlockAccess var0, BlockPosition var1) {
+        TileEntity var2 = var0.getTileEntity(var1);
+        return var2 != null && var2.getTileType() == this ? (T) var2 : null; // Kenzie - decompile error
+    }
 
-        return tileentity != null && tileentity.getTileType() == this ? tileentity : null;
+    static {
+        FURNACE = a("furnace", TileEntityTypes.a.a(TileEntityFurnaceFurnace::new, Blocks.FURNACE));
+        CHEST = a("chest", TileEntityTypes.a.a(TileEntityChest::new, Blocks.CHEST));
+        TRAPPED_CHEST = a("trapped_chest", TileEntityTypes.a.a(TileEntityChestTrapped::new, Blocks.TRAPPED_CHEST));
+        ENDER_CHEST = a("ender_chest", TileEntityTypes.a.a(TileEntityEnderChest::new, Blocks.ENDER_CHEST));
+        JUKEBOX = a("jukebox", TileEntityTypes.a.a(TileEntityJukeBox::new, Blocks.JUKEBOX));
+        DISPENSER = a("dispenser", TileEntityTypes.a.a(TileEntityDispenser::new, Blocks.DISPENSER));
+        DROPPER = a("dropper", TileEntityTypes.a.a(TileEntityDropper::new, Blocks.DROPPER));
+        SIGN = a("sign", TileEntityTypes.a.a(TileEntitySign::new, Blocks.OAK_SIGN, Blocks.SPRUCE_SIGN, Blocks.BIRCH_SIGN, Blocks.ACACIA_SIGN, Blocks.JUNGLE_SIGN, Blocks.DARK_OAK_SIGN, Blocks.OAK_WALL_SIGN, Blocks.SPRUCE_WALL_SIGN, Blocks.BIRCH_WALL_SIGN, Blocks.ACACIA_WALL_SIGN, Blocks.JUNGLE_WALL_SIGN, Blocks.DARK_OAK_WALL_SIGN, Blocks.CRIMSON_SIGN, Blocks.CRIMSON_WALL_SIGN, Blocks.WARPED_SIGN, Blocks.WARPED_WALL_SIGN));
+        MOB_SPAWNER = a("mob_spawner", TileEntityTypes.a.a(TileEntityMobSpawner::new, Blocks.SPAWNER));
+        PISTON = a("piston", TileEntityTypes.a.a(TileEntityPiston::new, Blocks.MOVING_PISTON));
+        BREWING_STAND = a("brewing_stand", TileEntityTypes.a.a(TileEntityBrewingStand::new, Blocks.BREWING_STAND));
+        ENCHANTING_TABLE = a("enchanting_table", TileEntityTypes.a.a(TileEntityEnchantTable::new, Blocks.ENCHANTING_TABLE));
+        END_PORTAL = a("end_portal", TileEntityTypes.a.a(TileEntityEnderPortal::new, Blocks.END_PORTAL));
+        BEACON = a("beacon", TileEntityTypes.a.a(TileEntityBeacon::new, Blocks.BEACON));
+        SKULL = a("skull", TileEntityTypes.a.a(TileEntitySkull::new, Blocks.SKELETON_SKULL, Blocks.SKELETON_WALL_SKULL, Blocks.CREEPER_HEAD, Blocks.CREEPER_WALL_HEAD, Blocks.DRAGON_HEAD, Blocks.DRAGON_WALL_HEAD, Blocks.ZOMBIE_HEAD, Blocks.ZOMBIE_WALL_HEAD, Blocks.WITHER_SKELETON_SKULL, Blocks.WITHER_SKELETON_WALL_SKULL, Blocks.PLAYER_HEAD, Blocks.PLAYER_WALL_HEAD));
+        DAYLIGHT_DETECTOR = a("daylight_detector", TileEntityTypes.a.a(TileEntityLightDetector::new, Blocks.DAYLIGHT_DETECTOR));
+        HOPPER = a("hopper", TileEntityTypes.a.a(TileEntityHopper::new, Blocks.HOPPER));
+        COMPARATOR = a("comparator", TileEntityTypes.a.a(TileEntityComparator::new, Blocks.COMPARATOR));
+        BANNER = a("banner", TileEntityTypes.a.a(TileEntityBanner::new, Blocks.WHITE_BANNER, Blocks.ORANGE_BANNER, Blocks.MAGENTA_BANNER, Blocks.LIGHT_BLUE_BANNER, Blocks.YELLOW_BANNER, Blocks.LIME_BANNER, Blocks.PINK_BANNER, Blocks.GRAY_BANNER, Blocks.LIGHT_GRAY_BANNER, Blocks.CYAN_BANNER, Blocks.PURPLE_BANNER, Blocks.BLUE_BANNER, Blocks.BROWN_BANNER, Blocks.GREEN_BANNER, Blocks.RED_BANNER, Blocks.BLACK_BANNER, Blocks.WHITE_WALL_BANNER, Blocks.ORANGE_WALL_BANNER, Blocks.MAGENTA_WALL_BANNER, Blocks.LIGHT_BLUE_WALL_BANNER, Blocks.YELLOW_WALL_BANNER, Blocks.LIME_WALL_BANNER, Blocks.PINK_WALL_BANNER, Blocks.GRAY_WALL_BANNER, Blocks.LIGHT_GRAY_WALL_BANNER, Blocks.CYAN_WALL_BANNER, Blocks.PURPLE_WALL_BANNER, Blocks.BLUE_WALL_BANNER, Blocks.BROWN_WALL_BANNER, Blocks.GREEN_WALL_BANNER, Blocks.RED_WALL_BANNER, Blocks.BLACK_WALL_BANNER));
+        STRUCTURE_BLOCK = a("structure_block", TileEntityTypes.a.a(TileEntityStructure::new, Blocks.STRUCTURE_BLOCK));
+        END_GATEWAY = a("end_gateway", TileEntityTypes.a.a(TileEntityEndGateway::new, Blocks.END_GATEWAY));
+        COMMAND_BLOCK = a("command_block", TileEntityTypes.a.a(TileEntityCommand::new, Blocks.COMMAND_BLOCK, Blocks.CHAIN_COMMAND_BLOCK, Blocks.REPEATING_COMMAND_BLOCK));
+        SHULKER_BOX = a("shulker_box", TileEntityTypes.a.a(TileEntityShulkerBox::new, Blocks.SHULKER_BOX, Blocks.BLACK_SHULKER_BOX, Blocks.BLUE_SHULKER_BOX, Blocks.BROWN_SHULKER_BOX, Blocks.CYAN_SHULKER_BOX, Blocks.GRAY_SHULKER_BOX, Blocks.GREEN_SHULKER_BOX, Blocks.LIGHT_BLUE_SHULKER_BOX, Blocks.LIGHT_GRAY_SHULKER_BOX, Blocks.LIME_SHULKER_BOX, Blocks.MAGENTA_SHULKER_BOX, Blocks.ORANGE_SHULKER_BOX, Blocks.PINK_SHULKER_BOX, Blocks.PURPLE_SHULKER_BOX, Blocks.RED_SHULKER_BOX, Blocks.WHITE_SHULKER_BOX, Blocks.YELLOW_SHULKER_BOX));
+        BED = a("bed", TileEntityTypes.a.a(TileEntityBed::new, Blocks.RED_BED, Blocks.BLACK_BED, Blocks.BLUE_BED, Blocks.BROWN_BED, Blocks.CYAN_BED, Blocks.GRAY_BED, Blocks.GREEN_BED, Blocks.LIGHT_BLUE_BED, Blocks.LIGHT_GRAY_BED, Blocks.LIME_BED, Blocks.MAGENTA_BED, Blocks.ORANGE_BED, Blocks.PINK_BED, Blocks.PURPLE_BED, Blocks.WHITE_BED, Blocks.YELLOW_BED));
+        CONDUIT = a("conduit", TileEntityTypes.a.a(TileEntityConduit::new, Blocks.CONDUIT));
+        BARREL = a("barrel", TileEntityTypes.a.a(TileEntityBarrel::new, Blocks.BARREL));
+        SMOKER = a("smoker", TileEntityTypes.a.a(TileEntitySmoker::new, Blocks.SMOKER));
+        BLAST_FURNACE = a("blast_furnace", TileEntityTypes.a.a(TileEntityBlastFurnace::new, Blocks.BLAST_FURNACE));
+        LECTERN = a("lectern", TileEntityTypes.a.a(TileEntityLectern::new, Blocks.LECTERN));
+        BELL = a("bell", TileEntityTypes.a.a(TileEntityBell::new, Blocks.BELL));
+        JIGSAW = a("jigsaw", TileEntityTypes.a.a(TileEntityJigsaw::new, Blocks.JIGSAW));
+        CAMPFIRE = a("campfire", TileEntityTypes.a.a(TileEntityCampfire::new, Blocks.CAMPFIRE, Blocks.SOUL_CAMPFIRE));
+        BEEHIVE = a("beehive", TileEntityTypes.a.a(TileEntityBeehive::new, Blocks.BEE_NEST, Blocks.BEEHIVE));
     }
 
     public static final class a<T extends TileEntity> {
-
-        private final Supplier<? extends T> a;
+        private final Provider<? extends T> a; // Kenzie - typed providers
         private final Set<Block> b;
 
-        private a(Supplier<? extends T> supplier, Set<Block> set) {
-            this.a = supplier;
-            this.b = set;
+        private a(Provider<? extends T> var0, Set<Block> var1) { // Kenzie - typed providers
+            this.a = var0;
+            this.b = var1;
         }
 
-        public static <T extends TileEntity> TileEntityTypes.a<T> a(Supplier<? extends T> supplier, Block... ablock) {
-            return new TileEntityTypes.a<>(supplier, ImmutableSet.copyOf(ablock));
+        public static <T extends TileEntity> TileEntityTypes.a<T> a(Provider<? extends T> var0, Block... var1) { // Kenzie - typed providers
+            return new TileEntityTypes.a(var0, ImmutableSet.copyOf(var1));
         }
 
-        public TileEntityTypes<T> a(Type<?> type) {
-            return new TileEntityTypes<>(this.a, this.b, type);
+        public TileEntityTypes<T> a(Type<?> var0) {
+            return new TileEntityTypes(this.a, this.b, var0);
         }
     }
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index d8d29d14559169f5e8d8b4cf63d8b427b823eb2f..b68c29b5ef87c97d12567a1c89e5c6e2aa32ec1d 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -8,6 +8,7 @@ import com.google.common.collect.ImmutableSet;
 import com.google.common.collect.Iterators;
 import com.google.common.collect.Lists;
 import com.google.common.collect.MapMaker;
+import com.google.common.reflect.TypeToken;
 import com.mojang.authlib.GameProfile;
 import com.mojang.brigadier.StringReader;
 import com.mojang.brigadier.exceptions.CommandSyntaxException;
@@ -47,63 +48,20 @@ import java.util.logging.Level;
 import java.util.logging.Logger;
 import javax.imageio.ImageIO;
 //import jline.console.ConsoleReader; // Paper
-import net.minecraft.server.Advancement;
-import net.minecraft.server.ArgumentEntity;
-import net.minecraft.server.BiomeManager;
-import net.minecraft.server.Block;
-import net.minecraft.server.BlockPosition;
-import net.minecraft.server.BossBattleCustom;
-import net.minecraft.server.CommandDispatcher;
-import net.minecraft.server.CommandListenerWrapper;
-import net.minecraft.server.CommandReload;
-import net.minecraft.server.Convertable;
-import net.minecraft.server.DataConverterRegistry;
-import net.minecraft.server.DedicatedPlayerList;
-import net.minecraft.server.DedicatedServer;
-import net.minecraft.server.DedicatedServerProperties;
-import net.minecraft.server.DedicatedServerSettings;
-import net.minecraft.server.DimensionManager;
-import net.minecraft.server.DynamicOpsNBT;
-import net.minecraft.server.Enchantments;
-import net.minecraft.server.EntityPlayer;
-import net.minecraft.server.EnumDifficulty;
-import net.minecraft.server.EnumGamemode;
-import net.minecraft.server.FluidType;
-import net.minecraft.server.GameRules;
-import net.minecraft.server.GeneratorSettings;
-import net.minecraft.server.IRecipe;
-import net.minecraft.server.IRegistry;
-import net.minecraft.server.IRegistryCustom;
-import net.minecraft.server.Item;
-import net.minecraft.server.ItemWorldMap;
-import net.minecraft.server.Items;
-import net.minecraft.server.JsonListEntry;
-import net.minecraft.server.LootTableRegistry;
-import net.minecraft.server.MapIcon;
-import net.minecraft.server.MinecraftKey;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.MobEffects;
-import net.minecraft.server.MobSpawner;
-import net.minecraft.server.MobSpawnerCat;
-import net.minecraft.server.MobSpawnerPatrol;
-import net.minecraft.server.MobSpawnerPhantom;
-import net.minecraft.server.MobSpawnerTrader;
-import net.minecraft.server.NBTBase;
-import net.minecraft.server.PlayerList;
-import net.minecraft.server.RegistryMaterials;
-import net.minecraft.server.RegistryReadOps;
-import net.minecraft.server.ResourceKey;
-import net.minecraft.server.ServerCommand;
-import net.minecraft.server.Tags;
-import net.minecraft.server.TicketType;
-import net.minecraft.server.Vec3D;
-import net.minecraft.server.VillageSiege;
-import net.minecraft.server.WorldDataServer;
-import net.minecraft.server.WorldDimension;
-import net.minecraft.server.WorldMap;
-import net.minecraft.server.WorldNBTStorage;
-import net.minecraft.server.WorldServer;
-import net.minecraft.server.WorldSettings;
+import mx.kenzie.server.CraftBridge;
+import mx.kenzie.server.enchantment.EnchantmentBuilderImplementation;
+import mx.kenzie.server.nbt.NBTFactoryImplementation;
+import mx.kenzie.server.potion.PotionBuilderImpl;
+import mx.kenzie.wellspring.Wellspring;
+import mx.kenzie.wellspring.enchantment.EnchantmentBuilder;
+import mx.kenzie.wellspring.nbt.NBT;
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import mx.kenzie.wellspring.nbt.NBTFactory;
+import mx.kenzie.wellspring.nbt.NBTList;
+import mx.kenzie.wellspring.packet.PacketFactory;
+import mx.kenzie.wellspring.potion.PotionBuilder;
+import mx.kenzie.wellspring.tile.TileType;
+import net.minecraft.server.*;
 import org.apache.commons.lang.Validate;
 import org.apache.commons.lang3.StringUtils;
 import org.bukkit.BanList;
@@ -121,6 +79,10 @@ import org.bukkit.Warning.WarningState;
 import org.bukkit.World;
 import org.bukkit.World.Environment;
 import org.bukkit.WorldCreator;
+import org.bukkit.attachment.Attachable;
+import org.bukkit.attachment.Attachment;
+import org.bukkit.attribute.Attribute;
+import org.bukkit.block.TileState;
 import org.bukkit.block.data.BlockData;
 import org.bukkit.boss.BarColor;
 import org.bukkit.boss.BarFlag;
@@ -137,12 +99,14 @@ import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.configuration.file.YamlConfiguration;
 import org.bukkit.configuration.serialization.ConfigurationSerialization;
 import org.bukkit.conversations.Conversable;
+import mx.kenzie.server.attachment.AttachmentFactory;
 import org.bukkit.craftbukkit.block.data.CraftBlockData;
 import org.bukkit.craftbukkit.boss.CraftBossBar;
 import org.bukkit.craftbukkit.boss.CraftKeyedBossbar;
 import org.bukkit.craftbukkit.command.BukkitCommandWrapper;
 import org.bukkit.craftbukkit.command.CraftCommandMap;
 import org.bukkit.craftbukkit.command.VanillaCommandWrapper;
+import org.bukkit.craftbukkit.entity.CraftEntity;
 import org.bukkit.craftbukkit.entity.CraftPlayer;
 import org.bukkit.craftbukkit.generator.CraftChunkData;
 import org.bukkit.craftbukkit.help.SimpleHelpMap;
@@ -164,6 +128,7 @@ import org.bukkit.craftbukkit.map.CraftMapView;
 import org.bukkit.craftbukkit.metadata.EntityMetadataStore;
 import org.bukkit.craftbukkit.metadata.PlayerMetadataStore;
 import org.bukkit.craftbukkit.metadata.WorldMetadataStore;
+import mx.kenzie.server.packet.PacketFactoryImpl;
 import org.bukkit.craftbukkit.potion.CraftPotionBrewer;
 import org.bukkit.craftbukkit.scheduler.CraftScheduler;
 import org.bukkit.craftbukkit.scoreboard.CraftScoreboardManager;
@@ -178,6 +143,7 @@ import org.bukkit.craftbukkit.util.DatFileFilter;
 import org.bukkit.craftbukkit.util.Versioning;
 import org.bukkit.craftbukkit.util.permissions.CraftDefaultPermissions;
 import org.bukkit.entity.Entity;
+import org.bukkit.entity.EntityType;
 import org.bukkit.entity.Player;
 import org.bukkit.event.command.UnknownCommandEvent; // Paper
 import org.bukkit.event.inventory.InventoryType;
@@ -231,8 +197,8 @@ import net.md_5.bungee.api.chat.BaseComponent; // Spigot
 import javax.annotation.Nullable; // Paper
 import javax.annotation.Nonnull; // Paper
 
-public final class CraftServer implements Server {
-    private final String serverName = "Paper"; // Paper
+public final class CraftServer implements Server, Wellspring { // Kenzie - Secondary abstract layer
+    private final String serverName = "Wellspring"; // Kenzie - give us a version! :)
     private final String serverVersion;
     private final String bukkitVersion = Versioning.getBukkitVersion();
     private final Logger logger = Logger.getLogger("Minecraft");
@@ -269,6 +235,10 @@ public final class CraftServer implements Server {
     private final List<CraftPlayer> playerView;
     public int reloadCount;
     public static Exception excessiveVelEx; // Paper - Velocity warnings
+    public final AttachmentFactory attachmentFactory = new AttachmentFactory(this); // Kenzie
+    public final NBTFactory nbtFactory; // Kenzie
+    public final PacketFactoryImpl packetFactory = new PacketFactoryImpl(); // Kenzie
+    public final CraftBridge bridge = new CraftBridge(); // Kenzie
 
     static {
         ConfigurationSerialization.registerClass(CraftOfflinePlayer.class);
@@ -288,6 +258,8 @@ public final class CraftServer implements Server {
 
         Bukkit.setServer(this);
 
+        nbtFactory = new NBTFactoryImplementation(); // Kenzie
+
         // Register all the Enchantments and PotionTypes now so we can stop new registration immediately after
         Enchantments.DAMAGE_ALL.getClass();
         org.bukkit.enchantments.Enchantment.stopAcceptingRegistrations();
@@ -892,6 +864,9 @@ public final class CraftServer implements Server {
             world.paperConfig.init(); // Paper
         }
 
+        logger.log(Level.WARNING, "Disposing of all attachments.");
+        attachmentFactory.disposeOfAll(); // Kenzie
+
         Plugin[] pluginClone = pluginManager.getPlugins().clone(); // Paper
         pluginManager.clearPlugins();
         commandMap.clearCommands();
@@ -2386,5 +2361,79 @@ public final class CraftServer implements Server {
     public com.destroystokyo.paper.entity.ai.MobGoals getMobGoals() {
         return mobGoals;
     }
+    
+    // Kenzie start
+    @Override
+    public void registerAttachment(Plugin plugin, java.util.function.Function<Entity, Attachment<?>> creatorFunction, TileType... types) {
+        for (TileType type : types) {
+            final Class<? extends Attachable> cls;
+            TileEntityTypes<?> entityTypes = IRegistry.BLOCK_ENTITY_TYPE.get(MinecraftKey.a(type.getKey().toString()));
+            if (entityTypes == null) continue;
+            cls = entityTypes.getProvider().getType();
+            attachmentFactory.registerAttachment(plugin, cls, (java.util.function.Function<Attachable, Attachment<?>>) (java.util.function.Function) creatorFunction);
+        }
+    }
+
+    @Override
+    public void registerAttachment(Plugin plugin, java.util.function.Function<Entity, Attachment<?>> creatorFunction, EntityType... types) {
+        for (EntityType type : types) {
+            attachmentFactory.registerAttachment(plugin, (Class<? extends Attachable>) type.getEntityClass(), (java.util.function.Function<Attachable, Attachment<?>>) (java.util.function.Function) creatorFunction);
+        }
+    }
+
+    @Override
+    public <T extends Attachable> void registerAttachment(Plugin plugin, java.util.function.Function<? extends T, Attachment<?>> creatorFunction, Class<T> target) {
+        if (TileState.class.isAssignableFrom(target)) {
+            registerAttachment(plugin, (java.util.function.Function<Entity, Attachment<?>>) creatorFunction, TileType.get((Class<? extends TileState>) target));
+            return;
+        }
+        attachmentFactory.registerAttachment(plugin, target, (java.util.function.Function<Attachable, Attachment<?>>) creatorFunction);
+    }
+
+    @Override
+    public void unregisterAttachments(Plugin plugin) {
+        logger.log(Level.WARNING, "Disposing of attachments from: " + plugin.getName());
+        attachmentFactory.removeAll(plugin);
+    }
+
+    @Override
+    public NBTFactory getNBTFactory() {
+        return nbtFactory;
+    }
+
+    @Override
+    public PacketFactory getPacketFactory() {
+        return packetFactory;
+    }
+
+    @Override
+    public PotionBuilder createPotionEffect(NamespacedKey key, String name) {
+        return new PotionBuilderImpl(key, name);
+    }
+
+    @Override
+    public EnchantmentBuilder createEnchantment(NamespacedKey key, String name) {
+        return new EnchantmentBuilderImplementation(key, name);
+    }
+
+    @Override
+    public Attribute registerAttribute(NamespacedKey key, double defaultValue) {
+        IRegistry.a(IRegistry.ATTRIBUTE, key.toString(), new AttributeBase(key.getKey(), defaultValue) {
+        });
+        return new Attribute(key);
+    }
+
+    @Override
+    public Attribute registerAttribute(NamespacedKey key, double defaultValue, double min, double max) {
+        IRegistry.a(IRegistry.ATTRIBUTE, key.toString(), new AttributeRanged(key.getKey(), defaultValue, min, max));
+        return new Attribute(key);
+    }
+
+    @Override
+    public Bridge getBridge() {
+        return bridge;
+    }
+
+    // Kenzie end
     // Paper end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
index 299f57ca2a65887a0d7e7c584fc1bd5c783b0db2..1ac015b5484604c0188ee5f2c9d115a691457bde 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftWorld.java
@@ -3,6 +3,7 @@ package org.bukkit.craftbukkit;
 import com.google.common.base.Preconditions;
 import com.google.common.collect.ImmutableList;
 import com.google.common.collect.ImmutableMap;
+import io.papermc.paper.world.MoonPhase;
 import it.unimi.dsi.fastutil.longs.Long2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import java.io.File;
@@ -22,77 +23,10 @@ import java.util.UUID;
 import java.util.concurrent.CompletableFuture;
 import java.util.function.Predicate;
 import java.util.stream.Collectors;
-import net.minecraft.server.ArraySetSorted;
-import net.minecraft.server.AxisAlignedBB;
-import net.minecraft.server.BiomeBase;
-import net.minecraft.server.BiomeDecoratorGroups;
-import net.minecraft.server.BlockChorusFlower;
-import net.minecraft.server.BlockDiodeAbstract;
-import net.minecraft.server.BlockPosition;
-import net.minecraft.server.Blocks;
-import net.minecraft.server.ChunkCoordIntPair;
-import net.minecraft.server.ChunkMapDistance;
-import net.minecraft.server.ChunkStatus;
-import net.minecraft.server.EntityAreaEffectCloud;
-import net.minecraft.server.EntityArmorStand;
-import net.minecraft.server.EntityArrow;
-import net.minecraft.server.EntityBoat;
-import net.minecraft.server.EntityEgg;
-import net.minecraft.server.EntityEnderSignal;
-import net.minecraft.server.EntityEvokerFangs;
-import net.minecraft.server.EntityExperienceOrb;
-import net.minecraft.server.EntityFallingBlock;
-import net.minecraft.server.EntityFireball;
-import net.minecraft.server.EntityFireworks;
-import net.minecraft.server.EntityHanging;
-import net.minecraft.server.EntityHuman;
-import net.minecraft.server.EntityInsentient;
-import net.minecraft.server.EntityItem;
-import net.minecraft.server.EntityItemFrame;
-import net.minecraft.server.EntityLeash;
-import net.minecraft.server.EntityLightning;
-import net.minecraft.server.EntityMinecartChest;
-import net.minecraft.server.EntityMinecartCommandBlock;
-import net.minecraft.server.EntityMinecartFurnace;
-import net.minecraft.server.EntityMinecartHopper;
-import net.minecraft.server.EntityMinecartMobSpawner;
-import net.minecraft.server.EntityMinecartRideable;
-import net.minecraft.server.EntityMinecartTNT;
-import net.minecraft.server.EntityPainting;
-import net.minecraft.server.EntityPotion;
-import net.minecraft.server.EntitySnowball;
-import net.minecraft.server.EntityTNTPrimed;
-import net.minecraft.server.EntityTippedArrow;
-import net.minecraft.server.EntityTypes;
-import net.minecraft.server.EntityZombie;
-import net.minecraft.server.EnumDifficulty;
-import net.minecraft.server.EnumDirection;
-import net.minecraft.server.EnumMobSpawn;
-import net.minecraft.server.Explosion;
-import net.minecraft.server.GameRules;
-import net.minecraft.server.GroupDataEntity;
-import net.minecraft.server.IBlockData;
-import net.minecraft.server.IChunkAccess;
-import net.minecraft.server.IRegistry;
-import net.minecraft.server.MCUtil;
-import net.minecraft.server.MinecraftKey;
-import net.minecraft.server.MinecraftServer;
-import net.minecraft.server.MovingObjectPosition;
-import net.minecraft.server.PacketPlayOutCustomSoundEffect;
-import net.minecraft.server.PacketPlayOutUpdateTime;
-import net.minecraft.server.PacketPlayOutWorldEvent;
-import net.minecraft.server.PersistentRaid;
-import net.minecraft.server.PlayerChunk;
-import net.minecraft.server.ProtoChunkExtension;
-import net.minecraft.server.RayTrace;
-import net.minecraft.server.SavedFile;
-import net.minecraft.server.SoundCategory;
-import net.minecraft.server.StructureGenerator;
-import net.minecraft.server.Ticket;
-import net.minecraft.server.TicketType;
-import net.minecraft.server.Unit;
-import net.minecraft.server.Vec3D;
-import net.minecraft.server.WorldServer;
+
+import mx.kenzie.server.attachment.AttachmentHolder;
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import net.minecraft.server.*;
 import org.apache.commons.lang.Validate;
 import org.bukkit.BlockChangeDelegate;
 import org.bukkit.Bukkit;
@@ -110,6 +44,7 @@ import org.bukkit.StructureType;
 import org.bukkit.TreeType;
 import org.bukkit.World;
 import org.bukkit.WorldBorder;
+import org.bukkit.attachment.Attachment;
 import org.bukkit.block.Biome;
 import org.bukkit.block.Block;
 import org.bukkit.block.BlockFace;
@@ -252,7 +187,6 @@ import org.bukkit.entity.minecart.PoweredMinecart;
 import org.bukkit.entity.minecart.SpawnerMinecart;
 import org.bukkit.entity.minecart.StorageMinecart;
 import org.bukkit.event.entity.CreatureSpawnEvent.SpawnReason;
-import org.bukkit.event.world.SpawnChangeEvent;
 import org.bukkit.event.world.TimeSkipEvent;
 import org.bukkit.generator.BlockPopulator;
 import org.bukkit.generator.ChunkGenerator;
@@ -284,6 +218,8 @@ public class CraftWorld implements World {
     private int waterAmbientSpawn = -1;
     private int ambientSpawn = -1;
 
+    public final AttachmentHolder attachments; // Kenzie
+
     // Paper start - Provide fast information methods
     public int getEntityCount() {
         int ret = 0;
@@ -329,8 +265,8 @@ public class CraftWorld implements World {
     }
 
     @Override
-    public io.papermc.paper.world.MoonPhase getMoonPhase() {
-        return io.papermc.paper.world.MoonPhase.getPhase(getFullTime() / 24000L);
+    public MoonPhase getMoonPhase() {
+        return MoonPhase.getPhase(getFullTime() / 24000L);
     }
     // Paper end
 
@@ -341,6 +277,11 @@ public class CraftWorld implements World {
         this.generator = gen;
 
         environment = env;
+        // Kenzie start - attachments
+        this.attachments = new AttachmentHolder(this);
+        server.attachmentFactory.addAttachments(this, attachments);
+        server.attachmentFactory.registerAttachmentHolder(attachments);
+        // Kenzie end
     }
 
     @Override
@@ -2608,5 +2549,60 @@ public class CraftWorld implements World {
     {
         return spigot;
     }
+    
+    // Kenzie start
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T extends Attachment<?>> T getAttachment(Class<T> attachmentClass) {
+        T attachment = (T) attachments.getByClass(attachmentClass); // This cast is fine
+        if (attachment == null) {
+            throw new NullPointerException("No attachment for this class has been registered.");
+        }
+        return attachment;
+    }
+
+    @Override
+    public <T extends Attachment<?>> boolean hasAttachment(Class<T> attachmentClass) {
+        return attachments.containsByClass(attachmentClass);
+    }
+
+    @Override
+    public NBTCompound getDragonFightNBT() {
+        return getHandle().worldDataServer.C();
+    }
+
+    @Override
+    public void setDragonFightNBT(NBTCompound compound) {
+        getHandle().worldDataServer.a(((NBTTagCompound) compound));
+    }
+
+    @Override
+    public NBTCompound getCustomBossNBT() {
+        NBTTagCompound compound = getHandle().worldDataServer.getCustomBossEvents();
+        return compound != null ? compound : new NBTTagCompound();
+    }
+
+    @Override
+    public void setCustomBossNBT(NBTCompound compound) {
+        getHandle().worldDataServer.setCustomBossEvents(((NBTTagCompound) compound));
+    }
+
+    @Override
+    public NBTCompound getNBT(Vector position) {
+        final int x = position.getBlockX() >> 4, z = position.getBlockZ() >> 4;
+        net.minecraft.server.Chunk chunk = world.getChunkProvider().getChunkAtIfLoadedImmediately(x, z);
+        if (chunk == null) chunk = this.world.getChunkProvider().getChunkAt(x, z, true);
+        return chunk.getNBT(position);
+    }
+
+    @Override
+    public void clearNBT(Vector position) {
+        final int x = position.getBlockX() >> 4, z = position.getBlockZ() >> 4;
+        net.minecraft.server.Chunk chunk = world.getChunkProvider().getChunkAtIfLoadedImmediately(x, z);
+        if (chunk == null) chunk = this.world.getChunkProvider().getChunkAt(x, z, true);
+        chunk.clearNBT(position);
+    }
+
+    // Kenzie end
     // Spigot end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementProgress.java b/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementProgress.java
index 60fc5aff80697cb4c85080350542c0f46056f74a..747335433374bd7be3eaf262cdd8449448e81535 100644
--- a/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementProgress.java
+++ b/src/main/java/org/bukkit/craftbukkit/advancement/CraftAdvancementProgress.java
@@ -15,6 +15,10 @@ public class CraftAdvancementProgress implements AdvancementProgress {
     private final AdvancementDataPlayer playerData;
     private final net.minecraft.server.AdvancementProgress handle;
 
+    public net.minecraft.server.AdvancementProgress getHandle() { // Kenzie
+        return handle;
+    }
+
     public CraftAdvancementProgress(CraftAdvancement advancement, AdvancementDataPlayer player, net.minecraft.server.AdvancementProgress handle) {
         this.advancement = advancement;
         this.playerData = player;
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
index 3baf7b75c65c9beba40945ba904315251b5b7a64..350ca26e81ef67a02174f34240430bf7cdfae542 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlock.java
@@ -5,6 +5,9 @@ import java.util.Collection;
 import java.util.Collections;
 import java.util.List;
 import java.util.stream.Collectors;
+
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import mx.kenzie.wellspring.nbt.NBTHolder;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.BiomeBase;
 import net.minecraft.server.BlockPosition;
@@ -62,6 +65,28 @@ public class CraftBlock implements Block {
     private final net.minecraft.server.GeneratorAccess world;
     private final BlockPosition position;
 
+    // Kenzie start - block nbt
+
+    public
+    @Override
+    NBTCompound getNBT() {
+        return this.getWorld().getNBT(this);
+    }
+
+    @Override
+    public void mergeNBT(NBTCompound compound) {
+        this.getNBT().merge(compound);
+    }
+
+    @Override
+    public void loadNBT(NBTCompound compound) {
+        final NBTCompound nbt = this.getNBT();
+        nbt.clear();
+        nbt.merge(compound);
+    }
+
+    // Kenzie end
+
     public CraftBlock(GeneratorAccess world, BlockPosition position) {
         this.world = world;
         this.position = position.immutableCopy();
diff --git a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
index dc0e6e49e9eb5004e53d24304bce095bcef8f4c2..9f5e7316099e8af5e2c66c53fb141e122f78a682 100644
--- a/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
+++ b/src/main/java/org/bukkit/craftbukkit/block/CraftBlockEntityState.java
@@ -1,21 +1,48 @@
 package org.bukkit.craftbukkit.block;
 
 import com.google.common.base.Preconditions;
+import mx.kenzie.server.attachment.AttachmentHolder;
+import mx.kenzie.wellspring.nbt.NBTCompound;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.NBTTagCompound;
 import net.minecraft.server.TileEntity;
+import org.bukkit.Bukkit;
 import org.bukkit.Material;
+import org.bukkit.attachment.Attachment;
 import org.bukkit.block.Block;
 import org.bukkit.block.TileState;
+import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
 import org.bukkit.persistence.PersistentDataContainer;
 
-public class CraftBlockEntityState<T extends TileEntity> extends CraftBlockState implements TileState {
+public class CraftBlockEntityState<T extends TileEntity & mx.kenzie.wellspring.tile.TileEntity> extends CraftBlockState implements TileState { // Kenzie
 
     private final Class<T> tileEntityClass;
     private final T tileEntity;
     private final T snapshot;
 
+    // Kenzie start - attachments and NBT
+    @Override
+    public NBTCompound getNBT() {
+        return tileEntity.getNBT();
+    }
+
+    @Override
+    public void loadNBT(NBTCompound compound) {
+        tileEntity.loadNBT(compound);
+    }
+
+    @Override
+    public <T extends Attachment<?>> T getAttachment(Class<T> attachmentClass) throws NullPointerException {
+        return tileEntity.getAttachment(attachmentClass);
+    }
+
+    @Override
+    public <T extends Attachment<?>> boolean hasAttachment(Class<T> attachmentClass) {
+        return tileEntity.hasAttachment(attachmentClass);
+    }
+    // Kenzie end
+
     public CraftBlockEntityState(Block block, Class<T> tileEntityClass) {
         super(block);
 
@@ -48,6 +75,11 @@ public class CraftBlockEntityState<T extends TileEntity> extends CraftBlockState
             throw new RuntimeException("Failed to read BlockState at: world: " + block.getWorld().getName() + " location: (" + block.getX() + ", " + block.getY() + ", " + block.getZ() + ")", thr);
         }
         // Paper end
+        try { // Kenzie start
+            BlockPosition position = new BlockPosition(getX(), getY(), getZ());
+            if (!DISABLE_SNAPSHOT)
+                world.getHandle().getTileEntity(position).getState(); // initialise attachments?
+        } catch (Throwable ignore) {} // Kenzie end
     }
 
     public final boolean snapshotDisabled; // Paper
diff --git a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
index f7d751348ca358a80bafc7f92c635eac316bc4cb..762c4f5998248ec6087503cdb822515394e98c78 100644
--- a/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
+++ b/src/main/java/org/bukkit/craftbukkit/entity/CraftEntity.java
@@ -6,6 +6,9 @@ import com.google.common.collect.Lists;
 import java.util.List;
 import java.util.Set;
 import java.util.UUID;
+
+import mx.kenzie.server.CraftBridge;
+import mx.kenzie.wellspring.nbt.NBTCompound;
 import net.minecraft.server.AxisAlignedBB;
 import net.minecraft.server.BlockPosition;
 import net.minecraft.server.DamageSource;
@@ -149,15 +152,18 @@ import org.bukkit.EntityEffect;
 import org.bukkit.Location;
 import org.bukkit.Server;
 import org.bukkit.World;
+import org.bukkit.attachment.Attachment;
 import org.bukkit.block.BlockFace;
 import org.bukkit.block.PistonMoveReaction;
 import org.bukkit.craftbukkit.CraftServer;
 import org.bukkit.craftbukkit.CraftWorld;
+import mx.kenzie.server.attachment.AttachmentHolder;
 import org.bukkit.craftbukkit.block.CraftBlock;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataContainer;
 import org.bukkit.craftbukkit.persistence.CraftPersistentDataTypeRegistry;
 import org.bukkit.craftbukkit.util.CraftChatMessage;
 import org.bukkit.craftbukkit.util.CraftVector;
+import org.bukkit.enchantments.Enchantment;
 import org.bukkit.entity.Pose;
 import org.bukkit.event.entity.EntityDamageEvent;
 import org.bukkit.event.player.PlayerTeleportEvent.TeleportCause;
@@ -180,12 +186,90 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     protected Entity entity;
     private EntityDamageEvent lastDamageEvent;
     private final CraftPersistentDataContainer persistentDataContainer = new CraftPersistentDataContainer(DATA_TYPE_REGISTRY);
+    public final AttachmentHolder attachments; // Kenzie
+    public boolean fake; // Kenzie - public so implementations can change it
 
     public CraftEntity(final CraftServer server, final Entity entity) {
         this.server = server;
         this.entity = entity;
+        // Kenzie start - attachments
+        this.attachments = new AttachmentHolder(this);
+        server.attachmentFactory.addAttachments(this, attachments);
+        server.attachmentFactory.registerAttachmentHolder(attachments);
+        fake = false;
+        // Kenzie end
+    }
+
+    // Kenzie start - NBT holder, enchantments and fakes
+
+    @Override
+    public int getMaxPresentLevel(Enchantment enchantment) {
+        if (!(this instanceof CraftLivingEntity)) return 0;
+        return ((CraftBridge) server.getBridge()).getMaxPresentLevel(enchantment, this);
+    }
+
+    @Override
+    public int getCumulativeLevel(Enchantment enchantment) {
+        if (!(this instanceof CraftLivingEntity)) return 0;
+        return ((CraftBridge) server.getBridge()).getCumulativeLevel(enchantment, this);
+    }
+
+    @Override
+    public boolean isFake() {
+        return fake;
+    }
+
+    public void setFake(boolean boo) {
+        fake = boo;
+    }
+
+    @Override
+    public NBTCompound getNBT() {
+        NBTTagCompound compound = new NBTTagCompound();
+        return getHandle().save(compound);
+    }
+
+    @Override
+    public void mergeNBT(NBTCompound compound) {
+        try {
+            NBTTagCompound nbt = (NBTTagCompound) compound;
+            NBTTagCompound original = new NBTTagCompound();
+            getHandle().save(original);
+            original.merge(nbt);
+            getHandle().load(original);
+        } catch (Throwable ex) {
+            throw new IllegalArgumentException("Illegal compound was merged!", ex);
+        }
     }
 
+    @Override
+    public void loadNBT(NBTCompound compound) {
+        try {
+            getHandle().load((NBTTagCompound) compound);
+        } catch (Throwable ex) {
+            throw new IllegalArgumentException("Illegal compound was loaded!", ex);
+        }
+    }
+    // Kenzie end
+
+    // Kenzie start - attachment system
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public <T extends Attachment<?>> T getAttachment(Class<T> attachmentClass) {
+        T attachment = (T) attachments.getByClass(attachmentClass); // This cast is fine
+        if (attachment == null) {
+            throw new NullPointerException("No attachment for this class has been registered.");
+        }
+        return attachment;
+    }
+
+    @Override
+    public <T extends Attachment<?>> boolean hasAttachment(Class<T> attachmentClass) {
+        return attachments.containsByClass(attachmentClass);
+    }
+    // Kenzie end
+
     @Override
     public Chunk getChunk() {
         net.minecraft.server.Chunk currentChunk = entity.getCurrentChunk();
@@ -1108,7 +1192,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     public boolean isInWater() {
         return getHandle().isInWater();
     }
-    
+
     public boolean isInRain() {
         return getHandle().isInRain();
     }
@@ -1124,7 +1208,7 @@ public abstract class CraftEntity implements org.bukkit.entity.Entity {
     public boolean isInWaterOrBubbleColumn() {
         return getHandle().isInWaterOrBubbleColumn();
     }
-    
+
     public boolean isInWaterOrRainOrBubbleColumn() {
         return getHandle().isInWaterOrRainOrBubble();
     }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
index bba9bddc1c0aacade9b7ad56afb1e630caa078fc..630abc559cc543848601c3d805d9b3986c965c6d 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftInventory.java
@@ -3,22 +3,12 @@ package org.bukkit.craftbukkit.inventory;
 import java.util.HashMap;
 import java.util.List;
 import java.util.ListIterator;
-import net.minecraft.server.IHopper;
-import net.minecraft.server.IInventory;
-import net.minecraft.server.InventoryCrafting;
-import net.minecraft.server.InventoryEnderChest;
-import net.minecraft.server.InventoryMerchant;
-import net.minecraft.server.PlayerInventory;
-import net.minecraft.server.TileEntityBarrel;
-import net.minecraft.server.TileEntityBlastFurnace;
-import net.minecraft.server.TileEntityBrewingStand;
-import net.minecraft.server.TileEntityDispenser;
-import net.minecraft.server.TileEntityDropper;
-import net.minecraft.server.TileEntityFurnace;
-import net.minecraft.server.TileEntityLectern;
-import net.minecraft.server.TileEntityShulkerBox;
-import net.minecraft.server.TileEntitySmoker;
+
+import mx.kenzie.wellspring.nbt.NBTCompound;
+import mx.kenzie.wellspring.nbt.NBTList;
+import net.minecraft.server.*;
 import org.apache.commons.lang.Validate;
+import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.Material;
 import org.bukkit.craftbukkit.util.CraftLegacy;
@@ -557,4 +547,35 @@ public class CraftInventory implements Inventory {
     public Location getLocation() {
         return inventory.getLocation();
     }
+
+    // Kenzie start - handle and NBT
+    public IInventory getHandle() {
+        return inventory;
+    }
+    public NBTList getAsNBT() {
+        return getHandle().getAsNBT();
+    }
+
+    public void loadNBT(NBTList list) {
+        getHandle().loadNBT(list);
+    }
+
+    @Override
+    public NBTCompound getNBT() {
+        NBTCompound compound = NBTCompound.create();
+        compound.set("Inventory", getAsNBT());
+        return compound;
+    }
+
+    @Override
+    public void loadNBT(NBTCompound compound) {
+        try {
+            NBTList list = compound.getList("Inventory");
+            loadNBT(list);
+        } catch (Throwable ex) {
+            Bukkit.getLogger().warning("Inventory " + this.toString() + " experienced an error while loading NBT.");
+        }
+    }
+
+    // Kenzie end
 }
diff --git a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
index 4616b3e99b511a83b349d607c7d9faac79baf8df..2e589274b0160bb592209f5aab78b22f155c5bb4 100644
--- a/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
+++ b/src/main/java/org/bukkit/craftbukkit/inventory/CraftMetaItem.java
@@ -52,6 +52,7 @@ import org.apache.commons.codec.binary.Base64;
 import org.apache.commons.lang.Validate;
 import org.apache.commons.lang3.EnumUtils;
 import org.bukkit.Material;
+import org.bukkit.NamespacedKey;
 import org.bukkit.attribute.Attribute;
 import org.bukkit.attribute.AttributeModifier;
 import org.bukkit.block.data.BlockData;
@@ -684,10 +685,10 @@ class CraftMetaItem implements ItemMeta, Damageable, Repairable, BlockDataMeta {
                     continue;
                 }
                 AttributeModifier modifier = (AttributeModifier) o;
-                Attribute attribute = EnumUtils.getEnum(Attribute.class, attributeName.toUpperCase(Locale.ROOT));
-                if (attribute == null) {
-                    continue;
-                }
+                // Kenzie start - custom attributes
+                String[] parts = attributeName.split(":");
+                Attribute attribute = new Attribute(new NamespacedKey(parts[0], parts[1]));
+                // Kenzie end
 
                 result.put(attribute, modifier);
             }
diff --git a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
index 02c2cf33e821ff7d80395f2df1ea34b7e5b2f8f9..674096cab190d62622f9947853b056f57d43a2a5 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/Versioning.java
@@ -11,7 +11,7 @@ public final class Versioning {
     public static String getBukkitVersion() {
         String result = "Unknown-Version";
 
-        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/mx.kenzie.wellspring/wellspring-api/pom.properties"); // Wellspring
+        InputStream stream = Bukkit.class.getClassLoader().getResourceAsStream("META-INF/maven/com.destroystokyo.paper/paper-api/pom.properties");
         Properties properties = new Properties();
 
         if (stream != null) {
